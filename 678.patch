From 2fda4af5384f8b852a1f864f8a161b74958451be Mon Sep 17 00:00:00 2001
From: Sebastien Boeuf <sebastien.boeuf@intel.com>
Date: Wed, 4 Oct 2017 15:25:59 -0700
Subject: [PATCH] vendor: Update virtcontainers, ciao and logrus vendorings

The most important part of virtcontainers re-vendoring is the fix
related to the pod locking which will solve our CRI-O testing issues
that we have encountered through our CI.
It also includes important patches adding the support of VFIO, and
patches fixing the network.

As a side effect, this commit replaces github.com/Sirupsen/logrus
package with github.com/sirupsen/logrus since the compatibility was
broken. Also, it revendors ciao package to have latest structures
included and make the build passing.

Shortlog of virtcontainers vendoring since the last one:

3802796 tests: Fix oci tests for device handling.
64e868c container: Implement custom devices marshalling routines
7b8ee42 hyperstart: Temporarily revert rootfs ro support
f2ba9f1 Networking: Ignore invalid and unconfigured interfaces
24c8394 api: Add missing pod locks
51a6d33 qemu: Increase the timeout when stopping the VM
77b5ef7 devices: Add attachDevices and detachDevices for pods and ...
f23109c vfio: Handle attaching vfio devices.
7e607e2 qemu: Add vfio-passthrough to qemu.
3a40fdd tests: Add tests for creating devices.
98af546 vendor: Vendor github.com/go-ini/ini
efc00b9 devices: Parse Linux devices from oci spec.
a9f589f pod: VMs: more logging, better timeouts
149d90c 1.0.2 release
ad8449a vendor: Weekly update
27902cf Huge Page Support: Add support for huge pages
e6b2988 logging: Add source field
0b6d279 OWNERS: Add James O. D. Hunt
ab657b5 hyperstart: Pass the read only flag to the rootfs bind mount
bcb61c9 approvers: dlespiau no longer working on this
742c575 Nesting: Disable nesting checks
b1022d0 1.0.1 release

Fixes #622

Signed-off-by: Sebastien Boeuf <sebastien.boeuf@intel.com>
---
 Gopkg.lock                                         |  26 +-
 Gopkg.toml                                         |   8 +-
 cc-check.go                                        |   2 +-
 config.go                                          |   2 +-
 create.go                                          |   2 +-
 logger.go                                          |   2 +-
 logger_test.go                                     |   2 +-
 main.go                                            |   2 +-
 main_test.go                                       |   2 +-
 oci.go                                             |   2 +-
 vendor/github.com/01org/ciao/.travis.yml           |  16 +-
 vendor/github.com/01org/ciao/CONTRIBUTING.md       |  27 +-
 .../github.com/01org/ciao/DeveloperQuickStart.md   | 339 --------
 vendor/github.com/01org/ciao/README.md             |  60 +-
 vendor/github.com/01org/ciao/packages.json         |   9 +-
 vendor/github.com/01org/ciao/qemu/examples_test.go |   2 +-
 vendor/github.com/01org/ciao/qemu/qemu.go          |  50 +-
 vendor/github.com/01org/ciao/qemu/qemu_test.go     |  12 +-
 vendor/github.com/01org/ciao/qemu/qmp_test.go      |   2 +-
 vendor/github.com/01org/ciao/ssntp/README.md       | 114 +--
 vendor/github.com/01org/ciao/ssntp/client.go       |   4 +-
 .../01org/ciao/ssntp/example_client_test.go        |   2 +-
 .../01org/ciao/ssntp/example_server_test.go        |   2 +-
 vendor/github.com/01org/ciao/ssntp/frame.go        |   4 +-
 vendor/github.com/01org/ciao/ssntp/server.go       |   4 +-
 vendor/github.com/01org/ciao/ssntp/session.go      |   2 +-
 vendor/github.com/01org/ciao/ssntp/ssntp.go        |  49 +-
 vendor/github.com/01org/ciao/ssntp/ssntp_test.go   |  13 +-
 vendor/github.com/Sirupsen/logrus/.travis.yml      |   9 -
 .../Sirupsen/logrus/terminal_appengine.go          |  10 -
 vendor/github.com/Sirupsen/logrus/terminal_bsd.go  |  10 -
 .../Sirupsen/logrus/terminal_notwindows.go         |  28 -
 .../github.com/Sirupsen/logrus/terminal_solaris.go |  21 -
 .../github.com/Sirupsen/logrus/terminal_windows.go |  33 -
 .../containers/virtcontainers/.pullapprove.yml     |   2 +-
 .../containers/virtcontainers/Gopkg.lock           |  40 +-
 .../containers/virtcontainers/Gopkg.toml           |  12 +-
 vendor/github.com/containers/virtcontainers/NEWS   |  18 +
 vendor/github.com/containers/virtcontainers/OWNERS |   2 +-
 vendor/github.com/containers/virtcontainers/api.go |  16 +-
 .../containers/virtcontainers/container.go         | 144 +++-
 .../github.com/containers/virtcontainers/device.go | 338 ++++++++
 .../containers/virtcontainers/device_test.go       | 237 +++++
 .../containers/virtcontainers/hypervisor.go        |  10 +
 .../containers/virtcontainers/implementation.go    |   2 +-
 .../containers/virtcontainers/interfaces.go        |   2 +-
 .../containers/virtcontainers/network.go           |   9 +
 .../containers/virtcontainers/network_test.go      |  20 +-
 .../virtcontainers/pkg/hyperstart/hyperstart.go    |   2 +-
 .../containers/virtcontainers/pkg/oci/utils.go     |  53 +-
 .../virtcontainers/pkg/oci/utils_test.go           |  74 +-
 .../virtcontainers/pkg/oci/utils_test_config.go    |  10 +
 .../containers/virtcontainers/pkg/vcMock/mock.go   |   2 +-
 .../virtcontainers/pkg/vcMock/mock_test.go         |   2 +-
 .../containers/virtcontainers/pkg/vcMock/types.go  |   2 +-
 vendor/github.com/containers/virtcontainers/pod.go |  34 +-
 .../containers/virtcontainers/pod_test.go          |  58 ++
 .../github.com/containers/virtcontainers/qemu.go   |  32 +-
 .../containers/virtcontainers/qemu_test.go         |  19 +
 .../virtcontainers/virtcontainers_test.go          |   2 +-
 vendor/github.com/go-ini/ini/.gitignore            |   5 +
 vendor/github.com/go-ini/ini/.travis.yml           |  13 +
 vendor/github.com/go-ini/ini/LICENSE               | 191 +++++
 vendor/github.com/go-ini/ini/Makefile              |  12 +
 vendor/github.com/go-ini/ini/README.md             | 746 ++++++++++++++++
 vendor/github.com/go-ini/ini/README_ZH.md          | 733 ++++++++++++++++
 vendor/github.com/go-ini/ini/error.go              |  32 +
 vendor/github.com/go-ini/ini/ini.go                | 556 ++++++++++++
 vendor/github.com/go-ini/ini/ini_test.go           | 491 +++++++++++
 vendor/github.com/go-ini/ini/key.go                | 699 +++++++++++++++
 vendor/github.com/go-ini/ini/key_test.go           | 573 +++++++++++++
 vendor/github.com/go-ini/ini/parser.go             | 361 ++++++++
 vendor/github.com/go-ini/ini/parser_test.go        |  42 +
 vendor/github.com/go-ini/ini/section.go            | 248 ++++++
 vendor/github.com/go-ini/ini/section_test.go       |  75 ++
 vendor/github.com/go-ini/ini/struct.go             | 500 +++++++++++
 vendor/github.com/go-ini/ini/struct_test.go        | 352 ++++++++
 .../{Sirupsen => sirupsen}/logrus/.gitignore       |   0
 vendor/github.com/sirupsen/logrus/.travis.yml      |  15 +
 .../{Sirupsen => sirupsen}/logrus/CHANGELOG.md     |  19 +
 .../{Sirupsen => sirupsen}/logrus/LICENSE          |   0
 .../{Sirupsen => sirupsen}/logrus/README.md        |  47 +-
 .../{Sirupsen => sirupsen}/logrus/alt_exit.go      |   0
 .../{Sirupsen => sirupsen}/logrus/alt_exit_test.go |  25 +-
 vendor/github.com/sirupsen/logrus/appveyor.yml     |  14 +
 .../{Sirupsen => sirupsen}/logrus/doc.go           |   0
 .../{Sirupsen => sirupsen}/logrus/entry.go         |   6 +-
 .../{Sirupsen => sirupsen}/logrus/entry_test.go    |   0
 .../sirupsen/logrus/example_basic_test.go          |  69 ++
 .../sirupsen/logrus/example_hook_test.go           |  35 +
 .../{Sirupsen => sirupsen}/logrus/exported.go      |   2 +-
 .../{Sirupsen => sirupsen}/logrus/formatter.go     |   2 +-
 .../logrus/formatter_bench_test.go                 |   0
 .../{Sirupsen => sirupsen}/logrus/hook_test.go     |  22 +
 .../{Sirupsen => sirupsen}/logrus/hooks.go         |   0
 .../logrus/json_formatter.go                       |   9 +-
 .../logrus/json_formatter_test.go                  |   0
 .../{Sirupsen => sirupsen}/logrus/logger.go        |  10 +-
 .../logrus/logger_bench_test.go                    |   0
 .../{Sirupsen => sirupsen}/logrus/logrus.go        |   0
 .../{Sirupsen => sirupsen}/logrus/logrus_test.go   |   0
 vendor/github.com/sirupsen/logrus/terminal_bsd.go  |  10 +
 .../logrus/terminal_linux.go                       |   6 +-
 .../logrus/text_formatter.go                       |  60 +-
 .../logrus/text_formatter_test.go                  |  84 +-
 .../{Sirupsen => sirupsen}/logrus/writer.go        |   0
 .../golang.org/x/crypto/ssh/terminal/terminal.go   | 951 +++++++++++++++++++++
 .../x/crypto/ssh/terminal/terminal_test.go         | 350 ++++++++
 vendor/golang.org/x/crypto/ssh/terminal/util.go    | 119 +++
 .../golang.org/x/crypto/ssh/terminal/util_bsd.go   |  12 +
 .../golang.org/x/crypto/ssh/terminal/util_linux.go |  11 +
 .../golang.org/x/crypto/ssh/terminal/util_plan9.go |  58 ++
 .../x/crypto/ssh/terminal/util_solaris.go          | 128 +++
 .../x/crypto/ssh/terminal/util_windows.go          | 155 ++++
 114 files changed, 9014 insertions(+), 848 deletions(-)
 delete mode 100644 vendor/github.com/01org/ciao/DeveloperQuickStart.md
 delete mode 100644 vendor/github.com/Sirupsen/logrus/.travis.yml
 delete mode 100644 vendor/github.com/Sirupsen/logrus/terminal_appengine.go
 delete mode 100644 vendor/github.com/Sirupsen/logrus/terminal_bsd.go
 delete mode 100644 vendor/github.com/Sirupsen/logrus/terminal_notwindows.go
 delete mode 100644 vendor/github.com/Sirupsen/logrus/terminal_solaris.go
 delete mode 100644 vendor/github.com/Sirupsen/logrus/terminal_windows.go
 create mode 100644 vendor/github.com/containers/virtcontainers/device.go
 create mode 100644 vendor/github.com/containers/virtcontainers/device_test.go
 create mode 100644 vendor/github.com/go-ini/ini/.gitignore
 create mode 100644 vendor/github.com/go-ini/ini/.travis.yml
 create mode 100644 vendor/github.com/go-ini/ini/LICENSE
 create mode 100644 vendor/github.com/go-ini/ini/Makefile
 create mode 100644 vendor/github.com/go-ini/ini/README.md
 create mode 100644 vendor/github.com/go-ini/ini/README_ZH.md
 create mode 100644 vendor/github.com/go-ini/ini/error.go
 create mode 100644 vendor/github.com/go-ini/ini/ini.go
 create mode 100644 vendor/github.com/go-ini/ini/ini_test.go
 create mode 100644 vendor/github.com/go-ini/ini/key.go
 create mode 100644 vendor/github.com/go-ini/ini/key_test.go
 create mode 100644 vendor/github.com/go-ini/ini/parser.go
 create mode 100644 vendor/github.com/go-ini/ini/parser_test.go
 create mode 100644 vendor/github.com/go-ini/ini/section.go
 create mode 100644 vendor/github.com/go-ini/ini/section_test.go
 create mode 100644 vendor/github.com/go-ini/ini/struct.go
 create mode 100644 vendor/github.com/go-ini/ini/struct_test.go
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/.gitignore (100%)
 create mode 100644 vendor/github.com/sirupsen/logrus/.travis.yml
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/CHANGELOG.md (86%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/LICENSE (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/README.md (89%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/alt_exit.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/alt_exit_test.go (63%)
 create mode 100644 vendor/github.com/sirupsen/logrus/appveyor.yml
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/doc.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/entry.go (96%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/entry_test.go (100%)
 create mode 100644 vendor/github.com/sirupsen/logrus/example_basic_test.go
 create mode 100644 vendor/github.com/sirupsen/logrus/example_hook_test.go
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/exported.go (99%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/formatter.go (96%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/formatter_bench_test.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/hook_test.go (83%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/hooks.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/json_formatter.go (82%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/json_formatter_test.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/logger.go (97%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/logger_bench_test.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/logrus.go (100%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/logrus_test.go (100%)
 create mode 100644 vendor/github.com/sirupsen/logrus/terminal_bsd.go
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/terminal_linux.go (70%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/text_formatter.go (82%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/text_formatter_test.go (52%)
 rename vendor/github.com/{Sirupsen => sirupsen}/logrus/writer.go (100%)
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/terminal.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/terminal_test.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util_bsd.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util_linux.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
 create mode 100644 vendor/golang.org/x/crypto/ssh/terminal/util_windows.go

diff --git a/Gopkg.lock b/Gopkg.lock
index d64f2bbe..465285a8 100644
--- a/Gopkg.lock
+++ b/Gopkg.lock
@@ -5,7 +5,7 @@
   branch = "master"
   name = "github.com/01org/ciao"
   packages = ["qemu","ssntp/uuid"]
-  revision = "9d6632430ecf42a35c23b7c6cdc560d5116d9483"
+  revision = "49b0fd97c72517dfb2450aa6a08ff4b9bb7bff42"
 
 [[projects]]
   branch = "master"
@@ -15,12 +15,6 @@
 
 [[projects]]
   branch = "master"
-  name = "github.com/Sirupsen/logrus"
-  packages = ["."]
-  revision = "acfabf31db8f45a9174f54a0d48ea4d15627af4d"
-
-[[projects]]
-  branch = "master"
   name = "github.com/clearcontainers/proxy"
   packages = ["api","client"]
   revision = "cf19e7935daaff8db546111c7a48cfdc2c1f09f6"
@@ -41,7 +35,7 @@
   branch = "master"
   name = "github.com/containers/virtcontainers"
   packages = [".","pkg/cni","pkg/hyperstart","pkg/oci","pkg/vcMock"]
-  revision = "c280b452bf075d3bac786f8a92ab70c6a1742600"
+  revision = "8cbd7a24a221f4462dab8e2f5308265a35bd68c1"
 
 [[projects]]
   branch = "master"
@@ -57,6 +51,12 @@
 
 [[projects]]
   branch = "master"
+  name = "github.com/go-ini/ini"
+  packages = ["."]
+  revision = "c787282c39ac1fc618827141a1f762240def08a3"
+
+[[projects]]
+  branch = "master"
   name = "github.com/kubernetes-incubator/cri-o"
   packages = ["pkg/annotations"]
   revision = "f3f8b67b76d53887b874633c6de13140dae99b76"
@@ -87,6 +87,12 @@
 
 [[projects]]
   branch = "master"
+  name = "github.com/sirupsen/logrus"
+  packages = ["."]
+  revision = "89742aefa4b206dcf400792f3bd35b542998eb3b"
+
+[[projects]]
+  branch = "master"
   name = "github.com/stretchr/testify"
   packages = ["assert"]
   revision = "4d4bfba8f1d1027c4fdbe371823030df51419987"
@@ -112,7 +118,7 @@
 [[projects]]
   branch = "master"
   name = "golang.org/x/crypto"
-  packages = ["curve25519","ed25519","ed25519/internal/edwards25519","ssh"]
+  packages = ["curve25519","ed25519","ed25519/internal/edwards25519","ssh","ssh/terminal"]
   revision = "adbae1b6b6fb4b02448a0fc0dbbc9ba2b95b294d"
 
 [[projects]]
@@ -124,6 +130,6 @@
 [solve-meta]
   analyzer-name = "dep"
   analyzer-version = 1
-  inputs-digest = "4355d9708eb5de24940da29aaf8d1aafee09ff57119999c762830fac0d3d2b1c"
+  inputs-digest = "8a01cb529efa5e6114d1049d6d785d1830e81fd37a91694fafc8e8c35575eece"
   solver-name = "gps-cdcl"
   solver-version = 1
diff --git a/Gopkg.toml b/Gopkg.toml
index aa391bca..7c898e41 100644
--- a/Gopkg.toml
+++ b/Gopkg.toml
@@ -80,10 +80,6 @@
 
 [[constraint]]
   branch = "master"
-  name = "github.com/Sirupsen/logrus"
-
-[[constraint]]
-  branch = "master"
   name = "github.com/clearcontainers/proxy"
 
 [[constraint]]
@@ -132,6 +128,10 @@
 
 [[constraint]]
   branch = "master"
+  name = "github.com/sirupsen/logrus"
+
+[[constraint]]
+  branch = "master"
   name = "github.com/stretchr/testify"
 
 [[constraint]]
diff --git a/cc-check.go b/cc-check.go
index e4c99e61..4e3e108c 100644
--- a/cc-check.go
+++ b/cc-check.go
@@ -21,8 +21,8 @@ import (
 	"regexp"
 	"strings"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
+	"github.com/sirupsen/logrus"
 	"github.com/urfave/cli"
 )
 
diff --git a/config.go b/config.go
index d34ba000..143ac60b 100644
--- a/config.go
+++ b/config.go
@@ -23,9 +23,9 @@ import (
 	"strings"
 
 	"github.com/BurntSushi/toml"
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	"github.com/containers/virtcontainers/pkg/oci"
+	"github.com/sirupsen/logrus"
 )
 
 const (
diff --git a/create.go b/create.go
index 19530618..e1596443 100644
--- a/create.go
+++ b/create.go
@@ -23,9 +23,9 @@ import (
 	"path/filepath"
 	"strings"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	"github.com/containers/virtcontainers/pkg/oci"
+	"github.com/sirupsen/logrus"
 	"github.com/urfave/cli"
 )
 
diff --git a/logger.go b/logger.go
index 675dafed..08753030 100644
--- a/logger.go
+++ b/logger.go
@@ -23,7 +23,7 @@ import (
 	"strings"
 	"time"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 const (
diff --git a/logger_test.go b/logger_test.go
index 74f6d2e8..c9996d9b 100644
--- a/logger_test.go
+++ b/logger_test.go
@@ -24,7 +24,7 @@ import (
 	"testing"
 	"time"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 	"github.com/stretchr/testify/assert"
 )
 
diff --git a/main.go b/main.go
index fa9c6577..afc5c727 100644
--- a/main.go
+++ b/main.go
@@ -21,9 +21,9 @@ import (
 	"os"
 	"strings"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/sirupsen/logrus"
 	"github.com/urfave/cli"
 )
 
diff --git a/main_test.go b/main_test.go
index 92f5f676..ca70636b 100644
--- a/main_test.go
+++ b/main_test.go
@@ -32,12 +32,12 @@ import (
 	"strings"
 	"testing"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	"github.com/containers/virtcontainers/pkg/oci"
 	"github.com/containers/virtcontainers/pkg/vcMock"
 	"github.com/dlespiau/covertool/pkg/cover"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/sirupsen/logrus"
 	"github.com/stretchr/testify/assert"
 	"github.com/urfave/cli"
 )
diff --git a/oci.go b/oci.go
index 7ba6a6a2..988d41de 100644
--- a/oci.go
+++ b/oci.go
@@ -23,11 +23,11 @@ import (
 	"strings"
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	"github.com/containers/virtcontainers/pkg/oci"
 	"github.com/opencontainers/runc/libcontainer/utils"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/sirupsen/logrus"
 )
 
 // Contants related to cgroup memory directory
diff --git a/vendor/github.com/01org/ciao/.travis.yml b/vendor/github.com/01org/ciao/.travis.yml
index ac29eb38..6e2e047d 100644
--- a/vendor/github.com/01org/ciao/.travis.yml
+++ b/vendor/github.com/01org/ciao/.travis.yml
@@ -14,12 +14,14 @@ matrix:
   include:
     - go: 1.9
       env: TEST_CASES_FLAGS=-race
+    - go: 1.9
+      env: LINT_ONLY=1
   allow_failures:
   - go: tip
   - go: 1.9
     env: TEST_CASES_FLAGS=-race
 
-go_import_path: github.com/01org/ciao
+go_import_path: github.com/ciao-project/ciao
 
 before_install:
   - sudo apt-get update -qq
@@ -58,17 +60,17 @@ script:
    - sudo docker pull debian
    - sudo ip link add testdummy type dummy
    - sudo ip addr add 198.51.100.1/24 dev testdummy
-   - gometalinter.v1 --deadline=5m --tests --vendor --disable-all --enable=misspell --enable=vet --enable=ineffassign --enable=gofmt --enable=gocyclo --cyclo-over=15 --enable=golint --enable=deadcode --enable=varcheck --enable=structcheck ./...
+   - if [ $LINT_ONLY ]; then gometalinter.v1 --deadline=10m --tests --vendor --disable-all --enable=misspell --enable=vet --enable=ineffassign --enable=gofmt --enable=gocyclo --cyclo-over=15 --enable=golint --enable=deadcode --enable=varcheck --enable=structcheck --enable=unused ./...; fi
    - cd _release/bat
-   - gometalinter.v1 --deadline=5m --tests --vendor --disable-all --enable=misspell --enable=vet --enable=ineffassign --enable=gofmt --enable=gocyclo --cyclo-over=15 --enable=golint --enable=deadcode --enable=varcheck --enable=structcheck ./...
+   - if [ $LINT_ONLY ]; then gometalinter.v1 --deadline=10m --tests --vendor --disable-all --enable=misspell --enable=vet --enable=ineffassign --enable=gofmt --enable=gocyclo --cyclo-over=15 --enable=golint --enable=deadcode --enable=varcheck --enable=structcheck --enable=unused ./...; fi
    - cd ../..
    - sudo mkdir -p /var/lib/ciao/instances
    - sudo mkdir -p /var/lib/ciao/data/controller/workloads
    - sudo chmod 0777 -R /var/lib/ciao
-   - test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -short github.com/01org/ciao/ciao-controller/...
-   - test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -append-profile -short github.com/01org/ciao/ciao-launcher github.com/01org/ciao/ciao-scheduler github.com/01org/ciao/payloads github.com/01org/ciao/configuration github.com/01org/ciao/testutil github.com/01org/ciao/ssntp/uuid github.com/01org/ciao/qemu github.com/01org/ciao/openstack/... github.com/01org/ciao/bat  github.com/01org/ciao/ciao-image/... github.com/01org/ciao/database/... github.com/01org/ciao/ciao-storage/... github.com/01org/ciao/deviceinfo github.com/01org/ciao/osprepare
-   - export GOROOT=`go env GOROOT` && sudo -E PATH=$PATH:$GOROOT/bin $GOPATH/bin/test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -append-profile github.com/01org/ciao/ssntp
-   - export GOROOT=`go env GOROOT` && export SNNET_ENV=198.51.100.0/24 && sudo -E PATH=$PATH:$GOROOT/bin $GOPATH/bin/test-cases -race -v -timeout 9 -short -tags travis -coverprofile /tmp/cover.out -append-profile github.com/01org/ciao/networking/libsnnet
+   - if [ -z $LINT_ONLY ]; then test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -short github.com/ciao-project/ciao/ciao-controller/...; fi
+   - if [ -z $LINT_ONLY ]; then test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -append-profile -short github.com/ciao-project/ciao/ciao-launcher github.com/ciao-project/ciao/ciao-scheduler github.com/ciao-project/ciao/payloads github.com/ciao-project/ciao/configuration github.com/ciao-project/ciao/testutil github.com/ciao-project/ciao/ssntp/uuid github.com/ciao-project/ciao/qemu github.com/ciao-project/ciao/openstack/... github.com/ciao-project/ciao/bat  github.com/ciao-project/ciao/ciao-image/... github.com/ciao-project/ciao/database/... github.com/ciao-project/ciao/ciao-storage/... github.com/ciao-project/ciao/deviceinfo github.com/ciao-project/ciao/osprepare; fi
+   - if [ -z $LINT_ONLY ]; then export GOROOT=`go env GOROOT` && sudo -E PATH=$PATH:$GOROOT/bin $GOPATH/bin/test-cases $TEST_CASES_FLAGS -v -timeout 9 -coverprofile /tmp/cover.out -append-profile github.com/ciao-project/ciao/ssntp; fi
+   - if [ -z $LINT_ONLY ]; then export GOROOT=`go env GOROOT` && export SNNET_ENV=198.51.100.0/24 && sudo -E PATH=$PATH:$GOROOT/bin $GOPATH/bin/test-cases -race -v -timeout 9 -short -tags travis -coverprofile /tmp/cover.out -append-profile github.com/ciao-project/ciao/networking/libsnnet; fi
 
 after_success:
    - $GOPATH/bin/goveralls -service=travis-ci -coverprofile=/tmp/cover.out
diff --git a/vendor/github.com/01org/ciao/CONTRIBUTING.md b/vendor/github.com/01org/ciao/CONTRIBUTING.md
index aff2ccbb..66897a05 100644
--- a/vendor/github.com/01org/ciao/CONTRIBUTING.md
+++ b/vendor/github.com/01org/ciao/CONTRIBUTING.md
@@ -47,44 +47,41 @@ Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
 
 We accept github pull requests.
 
-If you want to work on github.com/01org/ciao and your fork on the same workstation you will need to use multiple GOPATHs.  Assuming this is the case
+If you want to work on github.com/ciao-project/ciao and your fork on the same workstation you will need to use multiple GOPATHs.  Assuming this is the case
 
 1. Open a terminal
-2. mkdir -p ~/go-fork/src/github.com/01org (replacing go-fork with your preferred location)
+2. mkdir -p ~/go-fork/src/github.com/ciao-project (replacing go-fork with your preferred location)
 3. export GOPATH=~/go-fork
-4. cd $GOPATH/src/github.com/01org
+4. cd $GOPATH/src/github.com/ciao-project
 5. git clone https://github.com/GITHUB-USERNAME/ciao.git (replace GITHUB-USERNAME with your username)
 6. cd ciao
 7. go install ./...
 
-Once you've finished making your changes push them to your fork and send the PR via the github UI.  If you don't need to maintain the github.com/01org/ciao repo and your fork on the same workstation you can skip steps 2 and 3.
+Once you've finished making your changes push them to your fork and send the PR via the github UI.  If you don't need to maintain the github.com/ciao-project/ciao repo and your fork on the same workstation you can skip steps 2 and 3.
 
 ## Quality Controls
 
 We request you give quality assurance some consideration by:
 * Adding go unit tests for changes where it makes sense.
-* Using our [test-cases](https://github.com/01org/ciao/tree/master/test-cases) package to run unit tests because a simple ```gotest ./...``` can result in multiple packages' unit tests running in parallel which may be unsafe.  Simply replace ```go test``` with ```test-cases``` in your workflow.
-* Running basic cluster acceptance tests which are available in [_release/bat](https://github.com/01org/ciao/tree/master/_release/bat) and are most easily run inside a [singlevm](https://github.com/01org/ciao/tree/master/testutil/singlevm) test environment, but may also be run on a hardware cluster which has your code installed/configured/running.  In some cases it will be necessary to test on real hardware, but in many a virtual cluster is an easy and fully sufficient path to test.
-* Adding BAT tests for changes where it makes sense.  The BAT tests themselves are implemented in go in the [bat package](https://github.com/01org/ciao/tree/master/bat), which is essentially a wrapper/driver around ciao-cli.  Both the [bat package](https://github.com/01org/ciao/tree/master/bat) and [BAT tests](https://github.com/01org/ciao/tree/master/_release/bat) are easy to extend.
-* Enabling [Travis CI](https://travis-ci.org/01org/ciao) on your github fork of Ciao to get continuous integration feedback on your dev/test branches. We have thresholds on code coverage tracked by [coveralls](https://coveralls.io/github/01org/ciao) which you will see reported once you submit your pull request.
+* Using our [test-cases](https://github.com/ciao-project/ciao/tree/master/test-cases) package to run unit tests because a simple ```gotest ./...``` can result in multiple packages' unit tests running in parallel which may be unsafe.  Simply replace ```go test``` with ```test-cases``` in your workflow.
+* Running basic cluster acceptance tests which are available in [_release/bat](https://github.com/ciao-project/ciao/tree/master/_release/bat) and are most easily run inside a [singlevm](https://ciao-project.github.io/developer.html) test environment, but may also be run on a hardware cluster which has your code installed/configured/running.  In some cases it will be necessary to test on real hardware, but in many a virtual cluster is an easy and fully sufficient path to test.
+* Adding BAT tests for changes where it makes sense.  The BAT tests themselves are implemented in go in the [bat package](https://github.com/ciao-project/ciao/tree/master/bat), which is essentially a wrapper/driver around ciao-cli.  Both the [bat package](https://github.com/ciao-project/ciao/tree/master/bat) and [BAT tests](https://github.com/ciao-project/ciao/tree/master/_release/bat) are easy to extend.
+* Enabling [Travis CI](https://travis-ci.org/ciao-project/ciao) on your github fork of Ciao to get continuous integration feedback on your dev/test branches. We have thresholds on code coverage tracked by [coveralls](https://coveralls.io/github/ciao-project/ciao) which you will see reported once you submit your pull request.
 
 ## Issue tracking
 
 If you have a problem, please let us know.  IRC is a perfectly fine place
-to quickly informally bring something up, if you get a response.  The
+to quickly and informally bring something up.  The
 [mailing list](https://lists.clearlinux.org/mailman/listinfo/ciao-devel)
-is a more durable communication channel.
+is a more reliable communication channel.
 
 If it's a bug not already documented, by all means please [open an
-issue in github](https://github.com/01org/ciao/issues/new) so we all get visibility
-the problem and work toward resolution.
+issue in github](https://github.com/ciao-project/ciao/issues/new) so we all get visibility
+of the problem and work toward resolution.
 
 For feature requests we're also using github issues, with the label
 "enhancement".
 
-Our github bug/enhancement backlog and work queue are tracked in a
-[Ciao waffle.io kanban](https://waffle.io/01org/ciao).
-
 ## Closing issues
 
 You can either close issues manually by adding the fixing commit SHA1 to the issue
diff --git a/vendor/github.com/01org/ciao/DeveloperQuickStart.md b/vendor/github.com/01org/ciao/DeveloperQuickStart.md
deleted file mode 100644
index d830f333..00000000
--- a/vendor/github.com/01org/ciao/DeveloperQuickStart.md
+++ /dev/null
@@ -1,339 +0,0 @@
-# Ciao Single Machine Development and Test Environment
-
-Developing cluster software is complicated if you must actually run a whole 
-cluster on a set of physical machines.  This begs for a development environment
-that is self contained and can be run without any setup.  
-
-The goals for the Ciao development environment are that it:
-
-- Requires very minimal setup by the user
-- Does not affect the user's development system in any manner (i.e. the user
-  can keep the firewall rules, selinux setup,... intact)
-- Supports modes that allow it to run on a range of devices from powerful
-  workstations to less powerful laptops
-- Provides the ability to validate all code changes the user makes against
-  the Ciao release criterion
-
-This page documents a way to set up an entire Ciao cluster inside a single 
-machine.  This cluster-in-a-machine mode is ideal for developers that desire 
-the ability to build Ciao from sources, make changes and perform quick end to 
-end functional integration testing without requiring multiple machines/VM's, 
-creating a custom networking environment or maintaining a bevy of physical 
-machines and a physical network.
-
-We support two modes of operation:
-
-- ciao-down mode: Where a virtual machine is automatically created and 
-  launched, and the virtual cluster is setup and tested within the virtual 
-  machine
-- bare metal mode: Where the virtual cluster is setup on the host machine 
-  itself
-
-The ciao-down mode is the preferred mode of development on systems that have 
-the resources and CPU capabilities needed, as it fully isolates the Ciao 
-virtual cluster and sets up an environment in which Ciao is known to work 
-seamlessly. In addition, the ciao-down mode does not require any changes to 
-the user's network firewall setup. However, ciao-down mode does require 
-VT-x nesting to be supported by the host.
-
-The bare metal mode is the highest performance mode, but may require some 
-network firewall modification. It also uses less resources and can run on 
-machines whose CPUs do not support VT-x nesting.
-
-In both modes Ciao is configured in a special all in one development mode 
-where cluster nodes have dual roles (i.e launcher can be a Network Node and 
-a Compute Node at the same time)
-
-In the text below **machine** refers to the ciao-down VM in the case of the 
-ciao-down mode, it refers to the host system in the case of the bare metal mode.
-
-## Components running on the Machine
-      1. Controller 	
-      2. Scheduler 	
-      3. Compute+Network Node Agent (i.e. CN + NN Launcher)
-      4. Workloads (Containers and VMs)
-      5. Mock Openstack Services
-      6. Machine Local DHCP Server
-      ...
-
-The machine acts as the Ciao compute node, network node, ciao-controller, 
-ciao-scheduler and also hosts other openstack and dhcp services.
-
-## Graphical Overview
-
-When the system is functioning the overall setup manifests as follows:
-
-As you can see below the Cluster runs on a isolated virtual network resident 
-inside the machine. Hence the cluster is invisible outside the machine and
-completely self contained.
-
-```
-   
-   ____________________________________________________________________________
-  |                                                                            |
-  |                                                                            |
-  |                                                                            |
-  |                                                [Tenant VMs]  [CNCI VMs]    |
-  |                                                   |  |  |       ||         |
-  |                                   Tenant Bridges ----------     ||         |
-  |                                                       |         ||         |
-  |                                                       |         ||         |
-  |      [scheduler] [controller]  [CN+NN Launcher]       |         ||         |
-  |           ||       ||             ||                  |         ||         |
-  |           ||       ||             ||                  |         ||         |
-  |           ||       ||             ||                  |         ||         |
-  |           ||       ||             ||                  |         ||         |
-  |           ||       ||             ||                  |         ||         |
-  |           ||       ||             ||      [DHCP/DNS   |         ||         |
-  |           ||       ||             ||        Server]   |         ||         |
-  |           ||       ||             ||           ||     |         ||         |
-  |  ------------------------------------------------------------------------  |
-  |           Host Local Network Bridge + macvlan (ciao_br, ciaovlan)          |
-  |                                                                            |
-  |                                                                            |
-  |____________________________________________________________________________|
-                                                                                                       
-                              Development Machine
-
-```
-
-----
-
-# Install Go
-On the host install the latest release of go for your distribution
-[Installing Go](https://golang.org/doc/install).
-
-> NOTE: Go version 1.8 or later is required for Ciao. Ciao will not work with 
-older version of Go. Hence it is best you download and install the latest 
-version of Go if you distro is not on Go 1.8.
-
-You should also ensure that your GOPATH environment variable is set.
-
-
-# Getting Started with ciao-down
-ciao-down is a small utility for setting up a VM that contains
-everything you need to run ciao's Single VM. All you need to have
-installed on your machine is:
-
-- Go 1.8 or greater
-
-Once Go is installed you simply need to type
-
-```
-go get github.com/01org/ciao/testutil/ciao-down
-$GOPATH/bin/ciao-down create ciao
-```
-
-ciao-down will install some needed dependencies on your local PC such
-as qemu and xorriso. It will then download an Ubuntu Cloud Image and
-create a VM based on this image. It will boot the VM and install in that
-VM everything you need to run ciao Single VM, including docker, ceph,
-go, gcc, etc. When ciao-down create has finished you can connect to the
-newly created VM with
-
-```
-$GOPATH/bin/ciao-down connect
-```
-
-Your host's GOPATH is mounted inside the VM. Thus you can edit your
-the ciao code on your host machine and test in Single VM.
-
-
-## Proxies
-
-One of the nice things about using ciao-down is that it is proxy aware.
-When you run ciao-down create, ciao-down looks in its environment for
-proxy variables such as http_proxy, https_proxy and no_proxy.  If it
-finds them it ensures that these proxies are correctly configured for
-all the software that it installs and uses inside the VM, e.g., apt, docker,
-wget, ciao-cli.  So if your development machine is sitting
-behind a proxy, ensure you have your proxy environment variables set
-before running ciao-down.
-
-# Getting Started with Bare Metal
-
-## Install Docker
-Install latest docker for your distribution based on the instructions from 
-Docker
-[Installing Docker](https://docs.docker.com/engine/installation/).
-
-## Install ciao dependencies
-
-Install the following packages which are required:
-  1. qemu-system-x86_64 and qemu-img, to launch the VMs and create qcow images
-  2. gcc, required to build some of the ciao dependencies
-  3. dnsmasq, required to setup a test DHCP server
-
-On clearlinux all of these dependencies can be satisfied by installing the following bundles:
-```
-swupd bundle-add cloud-control go-basic os-core-dev kvm-host os-installer
-```
-## Setup password less sudo
-
-Setup passwordless sudo for the user who will be running the script below.
-
-## Cluster External Network Access
-
-If you desire to provide external network connectivity to the workloads then 
-the host needs to act as gateway to the Internet. The host needs to enable 
-ipv4 forwarding and ensure all traffic exiting the cluster via the host is 
-NATed.
-
-This assumes the host has a single network interface. For multi homed systems, 
-the setup is more complicated and needs appropriate routing setup which is 
-outside the scope of this document. If you have a custom firewall 
-configuration, you will need set things up appropriately.
-
-Very simplistically this can be done by
-```
-#$device is the network interface on the host
-iptables -t nat -A POSTROUTING -o $device -j MASQUERADE 
-
-
-echo 1 > /proc/sys/net/ipv4/ip_forward
-```
-
-
-## Download and build the sources
-
-Download and build the ciao sources: 
-```
-cd $GOPATH/src
-go get -v -u -tags debug github.com/01org/ciao/...
-```
-
-You should see no errors.
-
-# Verify that Ciao is fully functional  using the **machine**
-
-Now that you have the machine setup (either a bare metal setup or a 
-ciao-down VM setup).
-
-You can now quickly verify that all aspects of Ciao including VM launch, 
-container launch, and networking.  
-
-These steps are performed inside the machine.
-
-To do this simply run the following:
-```
-cd $GOPATH/src/github.com/01org/ciao/testutil/singlevm
-. ~/local/demo.sh
-#Cleanup any previous setup
-./cleanup.sh
-#Set up the test environment
-./setup.sh
-. ~/local/demo.sh
-#Perform a full cluster test
-./verify.sh
-```
-
-The ```verify.sh``` script will:
-- Create multiple Instances of Tenant VMs and Containers
-- Test network connectivity between containers
-- Test for ssh reach ability into VMs with private and external IPs
-- Delete all the VM's and Container that were created
-
-If the script reports success, it indicates to the developer that any changes 
-made have not broken any functionality across all the Ciao components.
-
-To quickly test any changes you make run verify.sh and observe no failures. 
-
-Prior to sumitting a change request to ciao, please run the BAT tests below
-in addition to verify.sh to ensure your changes meet the ciao acceptance
-criterion.
-
-Meeting the goal originally outlined at the top of the page, build/setup/running 
-your cluster all-in-one all transpires quickly and easily from the single 
-script.  The time needed for ./setup.sh and ./verify.sh to build ciao from 
-source, configure it components into a virtual cluster, then launch and 
-teardown containers and VMs is on the order of one minute total elapsed time.
-
-# Ongoing Usage
-
-Once it's finished, the ```setup.sh``` script leaves behind a virtual cluster 
-which can be used to perform manual tests.  These tests are performed using 
-the [ciao-cli](https://github.com/01org/ciao/blob/master/ciao-cli/README.md) tool.  
-
-The ciao-cli tool requires that some environment variables be set up before it 
-will work properly.  These variables contain the URLs of the various ciao 
-services and the credentials needed to access these services.  The setup.sh 
-script creates a shell source that contains valid values for the newly set up 
-cluster.  To initialise these variables you just need to source that file, e.g,
-
-```
-. ~/local/demo.sh
-```
-
-To check everything is working try the following command
-
-```
-ciao-cli workload list
-```
-
-# Running the BAT tests
-
-The ciao project includes a set of acceptance tests that must pass before each 
-release is made.  The tests perform various tasks such as listing workloads, 
-creating and deleting instances, etc.  These tests can be run inside the 
-machine
-
-```
-# Source the demo.sh file if you have not already done so
-. ~/local/demo.sh
-cd $GOPATH/src/github.com/01org/ciao/_release/bat
-test-cases -v ./...
-```
-
-For more information on the BAT tests please see the [README](https://github.com/01org/ciao/blob/master/_release/bat/README.md).
-
-# Cleanup / Teardown
-
-To cleanup and tear down the cluster:
-```
-cd $GOPATH/src/github.com/01org/ciao/testutil/singlevm
-#Cleanup any previous setup
-. ~/local/demo.sh
-./cleanup.sh
-```
-
-# Known Issues with Bare Metal
-
-- Does not work on Fedora due to default firewall rules. 
-https://github.com/01org/ciao/issues/526
-
-In order to allow the traffic required by the test cases you can add temporary 
-rules like the ones show below
-
-```
-#!/bin/bash
-iptables -I INPUT   1 -p tcp -m tcp --dport 8888 -j ACCEPT
-iptables -I INPUT   1 -p 47 -j ACCEPT
-iptables -I OUTPUT  1 -p 47 -j ACCEPT
-iptables -I INPUT   1 -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
-iptables -I OUTPUT  1 -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT
-iptables -I FORWARD 1 -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
-iptables -I FORWARD 1 -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT
-iptables -I FORWARD 1 -p udp -m udp --dport 67:68 -j ACCEPT
-iptables -I FORWARD 1 -p udp -m udp --dport 123 -j ACCEPT
-iptables -I FORWARD 1 -p udp -m udp --dport 53 -j ACCEPT
-iptables -I FORWARD 1 -p udp -m udp --dport 5355 -j ACCEPT
-iptables -I FORWARD 1 -p icmp -j ACCEPT
-```
-
-And delete them after the tests using
-```
-#!/bin/bash
-iptables -D INPUT   -p tcp -m tcp --dport 8888 -j ACCEPT
-iptables -D INPUT   -p 47 -j ACCEPT
-iptables -D OUTPUT  -p 47 -j ACCEPT
-iptables -D INPUT   -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
-iptables -D OUTPUT  -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT
-iptables -D FORWARD -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
-iptables -D FORWARD -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT
-iptables -D FORWARD -p udp -m udp --dport 67:68 -j ACCEPT
-iptables -D FORWARD -p udp -m udp --dport 123 -j ACCEPT
-iptables -D FORWARD -p udp -m udp --dport 53 -j ACCEPT
-iptables -D FORWARD -p udp -m udp --dport 5355 -j ACCEPT
-iptables -D FORWARD -p icmp -j ACCEPT
-```
-
diff --git a/vendor/github.com/01org/ciao/README.md b/vendor/github.com/01org/ciao/README.md
index eba6d823..81e76b18 100644
--- a/vendor/github.com/01org/ciao/README.md
+++ b/vendor/github.com/01org/ciao/README.md
@@ -1,58 +1,24 @@
-#Ciao Project
+# Ciao Project
 
-[![Go Report Card](https://goreportcard.com/badge/github.com/01org/ciao)](https://goreportcard.com/report/github.com/01org/ciao)
-[![Build Status](https://travis-ci.org/01org/ciao.svg?branch=master)](https://travis-ci.org/01org/ciao)
-[![Coverage Status](https://coveralls.io/repos/github/01org/ciao/badge.svg?branch=master)](https://coveralls.io/github/01org/ciao?branch=master)
-[![GoDoc](https://godoc.org/github.com/01org/ciao?status.svg)](https://godoc.org/github.com/01org/ciao)
-[![Stories in Ready](https://badge.waffle.io/01org/ciao.png?label=ready&title=Ready)](https://waffle.io/01org/ciao)
+[![Go Report Card](https://goreportcard.com/badge/github.com/ciao-project/ciao)](https://goreportcard.com/report/github.com/ciao-project/ciao)
+[![Build Status](https://travis-ci.org/ciao-project/ciao.svg?branch=master)](https://travis-ci.org/ciao-project/ciao)
+[![Coverage Status](https://coveralls.io/repos/github/ciao-project/ciao/badge.svg?branch=master)](https://coveralls.io/github/ciao-project/ciao?branch=master)
+[![GoDoc](https://godoc.org/github.com/ciao-project/ciao?status.svg)](https://godoc.org/github.com/ciao-project/ciao)
 
 Ciao is the "Cloud Integrated Advanced Orchestrator".  Its goal is
 to provide an easy to deploy, secure, scalable cloud orchestration
 system which handles virtual machines, containers, and bare metal apps
-agnostically as generic workloads.  Implemented in the Go language, it
-separates logic into "controller", "scheduler" and "launcher" components
-which communicate over the "Simple and Secure Node Transfer Protocol
-(SSNTP)".
+agnostically as generic workloads.
 
-[Controller](https://github.com/01org/ciao/blob/master/ciao-controller)
-is responsible for policy choices around tenant workloads.
-
-[Scheduler](https://github.com/01org/ciao/blob/master/ciao-scheduler)
-implements a "push/pull" scheduling algorithm.  In response to a
-controller approved workload instance arriving at the scheduler, it
-finds a first fit among cluster compute nodes currently requesting work.
-
-[Launcher](https://github.com/01org/ciao/blob/master/ciao-launcher)
-abstracts the specific launching details for the different workload
-types (eg: virtual machine, container, bare metal).  Launcher reports
-compute node statistics to the scheduler and controller.  It also reports
-per-instance statistics up to controller.
-
-An additional set of componentry provides [ciao
-network](https://github.com/01org/ciao/blob/master/networking)
-connectivity for workload instances and insures tenant isolation.
-Workloads (whether container or VM) are automatically placed in a unified
-L2 network, one such network per tenant.
-
-A [cli](https://github.com/01org/ciao/tree/master/ciao-cli) is available.
-
-All ciao components communicate with each other via
-[SSNTP](https://github.com/01org/ciao/blob/master/ssntp/README.md) using a
-set of [payloads](https://github.com/01org/ciao/blob/master/payloads).
-
-This GitHub repository contains documentation on the
-various sub-components of ciao in their respective
-subdirectories.
+Please visit [ciao's
+webpage](https://ciao-project.github.io/index.html) to find out more
+about ciao, how it's
+[developed](https://ciao-project.github.io/developer.html), how it
+works, and how to
+[install](https://ciao-project.github.io/ciao-deploy.html) it.
 
 If you would like to contribute to ciao, check our [Contributing
-guide](https://github.com/01org/ciao/blob/master/CONTRIBUTING.md).
-There's a [wiki page](https://github.com/01org/ciao/blob/master/DeveloperQuickStart.md)
-that illustrates how to easily setup a development environment without
-needing a cluster. We also recommend taking a look at the ['janitorial'
-bugs](https://github.com/01org/ciao/issues?q=is%3Aopen+is%3Aissue+label%3AJanitorial)
-in our list of open issues as these bugs can be solved without an
-extensive knowledge of ciao.
-We would love to help you start contributing!
+guide](https://github.com/ciao-project/ciao/blob/master/CONTRIBUTING.md).
 
 The ciao development team can be reached via our [mailing
 list](https://lists.clearlinux.org/mailman/listinfo/ciao-devel) and on IRC
diff --git a/vendor/github.com/01org/ciao/packages.json b/vendor/github.com/01org/ciao/packages.json
index b71917f2..da2e5662 100644
--- a/vendor/github.com/01org/ciao/packages.json
+++ b/vendor/github.com/01org/ciao/packages.json
@@ -49,11 +49,6 @@
 		"version": "23def4e",
 		"license": "Apache v2.0"
 	},
-	"github.com/gophercloud/gophercloud": {
-		"url": "https://github.com/gophercloud/gophercloud.git",
-		"version": "268e995",
-		"license": "Apache v2.0"
-	},
 	"github.com/gorilla/mux": {
 		"url": "https://github.com/gorilla/mux.git",
 		"version": "757bef9",
@@ -61,7 +56,7 @@
 	},
 	"github.com/intel/tfortools": {
 		"url": "https://github.com/intel/tfortools.git",
-		"version": "2aef60e",
+		"version": "v0.1.0",
 		"license": "Apache v2.0"
 	},
 	"github.com/mattn/go-sqlite3": {
@@ -114,4 +109,4 @@
 		"version": "a5b47d3",
 		"license": "Apache v2.0"
 	}
-}
+}
\ No newline at end of file
diff --git a/vendor/github.com/01org/ciao/qemu/examples_test.go b/vendor/github.com/01org/ciao/qemu/examples_test.go
index 45607a04..bc06f520 100644
--- a/vendor/github.com/01org/ciao/qemu/examples_test.go
+++ b/vendor/github.com/01org/ciao/qemu/examples_test.go
@@ -21,7 +21,7 @@ import (
 
 	"context"
 
-	"github.com/01org/ciao/qemu"
+	"github.com/ciao-project/ciao/qemu"
 )
 
 func Example() {
diff --git a/vendor/github.com/01org/ciao/qemu/qemu.go b/vendor/github.com/01org/ciao/qemu/qemu.go
index 3bd79284..364f291b 100644
--- a/vendor/github.com/01org/ciao/qemu/qemu.go
+++ b/vendor/github.com/01org/ciao/qemu/qemu.go
@@ -591,6 +591,32 @@ func (blkdev BlockDevice) QemuParams(config *Config) []string {
 	return qemuParams
 }
 
+// VFIODevice represents a qemu vfio device meant for direct access by guest OS.
+type VFIODevice struct {
+	// Bus-Device-Function of device
+	BDF string
+}
+
+// Valid returns true if the VFIODevice structure is valid and complete.
+func (vfioDev VFIODevice) Valid() bool {
+	if vfioDev.BDF == "" {
+		return false
+	}
+
+	return true
+}
+
+// QemuParams returns the qemu parameters built out of this vfio device.
+func (vfioDev VFIODevice) QemuParams(config *Config) []string {
+	var qemuParams []string
+
+	deviceParam := fmt.Sprintf("vfio-pci,host=%s", vfioDev.BDF)
+	qemuParams = append(qemuParams, "-device")
+	qemuParams = append(qemuParams, deviceParam)
+
+	return qemuParams
+}
+
 // RTCBaseType is the qemu RTC base time type.
 type RTCBaseType string
 
@@ -742,6 +768,16 @@ type Knobs struct {
 	// Daemonize will turn the qemu process into a daemon
 	Daemonize bool
 
+	// Both HugePages and MemPrealloc require the Memory.Size of the VM
+	// to be set, as they need to reserve the memory upfront in order
+	// for the VM to boot without errors.
+	//
+	// HugePages always results in memory pre-allocation.
+	// However the setup is different from normal pre-allocation.
+	// Hence HugePages has precedence over MemPrealloc
+	// HugePages will pre-allocate all the RAM from huge pages
+	HugePages bool
+
 	// MemPrealloc will allocate all the RAM upfront
 	MemPrealloc bool
 
@@ -999,7 +1035,19 @@ func (config *Config) appendKnobs() {
 		config.qemuParams = append(config.qemuParams, "-daemonize")
 	}
 
-	if config.Knobs.MemPrealloc == true {
+	if config.Knobs.HugePages == true {
+		if config.Memory.Size != "" {
+			dimmName := "dimm1"
+			objMemParam := "memory-backend-file,id=" + dimmName + ",size=" + config.Memory.Size + ",mem-path=/dev/hugepages,share=on,prealloc=on"
+			numaMemParam := "node,memdev=" + dimmName
+
+			config.qemuParams = append(config.qemuParams, "-object")
+			config.qemuParams = append(config.qemuParams, objMemParam)
+
+			config.qemuParams = append(config.qemuParams, "-numa")
+			config.qemuParams = append(config.qemuParams, numaMemParam)
+		}
+	} else if config.Knobs.MemPrealloc == true {
 		if config.Memory.Size != "" {
 			dimmName := "dimm1"
 			objMemParam := "memory-backend-ram,id=" + dimmName + ",size=" + config.Memory.Size + ",prealloc=on"
diff --git a/vendor/github.com/01org/ciao/qemu/qemu_test.go b/vendor/github.com/01org/ciao/qemu/qemu_test.go
index 09ed2a92..f3d28e3b 100644
--- a/vendor/github.com/01org/ciao/qemu/qemu_test.go
+++ b/vendor/github.com/01org/ciao/qemu/qemu_test.go
@@ -22,7 +22,7 @@ import (
 	"strings"
 	"testing"
 
-	"github.com/01org/ciao/testutil"
+	"github.com/ciao-project/ciao/testutil"
 )
 
 func testAppend(structure interface{}, expected string, t *testing.T) {
@@ -217,6 +217,16 @@ func TestAppendDeviceBlock(t *testing.T) {
 	testAppend(blkdev, deviceBlockString, t)
 }
 
+var deviceVFIOString = "-device vfio-pci,host=02:10.0"
+
+func TestAppendDeviceVFIO(t *testing.T) {
+	vfioDevice := VFIODevice{
+		BDF: "02:10.0",
+	}
+
+	testAppend(vfioDevice, deviceVFIOString, t)
+}
+
 func TestAppendEmptyDevice(t *testing.T) {
 	device := SerialDevice{}
 
diff --git a/vendor/github.com/01org/ciao/qemu/qmp_test.go b/vendor/github.com/01org/ciao/qemu/qmp_test.go
index 710c2009..5b63b170 100644
--- a/vendor/github.com/01org/ciao/qemu/qmp_test.go
+++ b/vendor/github.com/01org/ciao/qemu/qmp_test.go
@@ -28,7 +28,7 @@ import (
 
 	"context"
 
-	"github.com/01org/ciao/testutil"
+	"github.com/ciao-project/ciao/testutil"
 )
 
 const (
diff --git a/vendor/github.com/01org/ciao/ssntp/README.md b/vendor/github.com/01org/ciao/ssntp/README.md
index f7bdd2d7..6726a20a 100644
--- a/vendor/github.com/01org/ciao/ssntp/README.md
+++ b/vendor/github.com/01org/ciao/ssntp/README.md
@@ -91,7 +91,7 @@ UUIDs.
    ConnectionFailure (0x4), and then must close the TLS connection to
    the server.
    The client should also parse the cluster
-   [configuration data] (https://github.com/01org/ciao/blob/master/payloads/configure.go)
+   [configuration data] (https://github.com/ciao-project/ciao/blob/master/payloads/configure.go)
    that comes in the CONNECTED payload and configure itself accordingly.
 
 3. Connection is successfully established. Both ends of the connection
@@ -100,7 +100,7 @@ UUIDs.
 ## SSNTP certificates ##
 
 SSNTP uses ciao-cert to generate the certificates it needs to communicate. They
-can be generated with instructions found in [ciao-cert] (https://github.com/01org/ciao/tree/master/ciao-cert).
+can be generated with instructions found in [ciao-cert] (https://github.com/ciao-project/ciao/tree/master/ciao-cert).
 
 ## SSNTP frames ##
 
@@ -153,7 +153,7 @@ UUID:
 #### START ####
 The CIAO Controller client sends the START command to the Scheduler in
 order to schedule a new workload. The [START command YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/start.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/start.go)
 is mandatory and contains a full workload description.
 
 If the Scheduler finds a compute node (CN) with enough capacity to run
@@ -163,7 +163,7 @@ UUID managing this CN with the same payload.
 If the Scheduler cannot find a suitable CN for this workload, it will
 asynchronously send a SSNTP ERROR frame back to the Controller. The error
 code should be StartFailure (0x2) and the payload must comply with the
-[StartFailure YAML schema] (https://github.com/01org/ciao/blob/master/payloads/startfailure.go)
+[StartFailure YAML schema] (https://github.com/ciao-project/ciao/blob/master/payloads/startfailure.go)
 so that the Controller eventually knows that a given instance/workload UUID
 could not start.
 
@@ -183,37 +183,6 @@ The START command payload is mandatory:
 +--------------------------------------------------------------------------+
 ```
 
-#### STOP ####
-The CIAO Controller client sends the STOP command to the Scheduler in
-order to stop a running instance on a given CN. The [STOP command
-YAML payload] (https://github.com/01org/ciao/blob/master/payloads/stop.go)
-is mandatory and contains the instance UUID to be stopped and the
-agent UUID that manages this instance.
-
-STOPping an instance means shutting it down. Non persistent
-instances are deleted as well when being STOPped.
-Persistent instances metadata and disks images are stored and
-can be started again through the RESTART SSNTP command.
-
-There are several error cases related to the STOP command:
-
-1. If the Scheduler cannot find the Agent identified in the STOP
-   command payload, it should send a SSNTP error with the
-   StopFailure (0x3) error code back to the Controller.
-
-2. If the Agent cannot actually stop the instance (Because e.g.
-   it's already finished), it should also send a SSNTP error with
-   the StopFailure (0x3) error code back to the Scheduler. It is
-   then the Scheduler responsibility to notify the Controller about it
-   by forwarding this error frame.
-
-```
-+--------------------------------------------------------------------+
-| Major | Minor | Type  | Operand |  Payload Length | YAML formatted |
-|       |       | (0x0) |  (0x2)  |                 |     payload    |
-+--------------------------------------------------------------------+
-```
-
 #### STATS ####
 CIAO CN Agents periodically send the STATS command to the Scheduler
 in order to provide a complete view of the compute node status. It is
@@ -224,7 +193,7 @@ to the Controller so that it can provide a complete cloud status report back to
 the users.
 
 The STATS command comes with a mandatory [YAML formatted payload]
-(https://github.com/01org/ciao/blob/master/payloads/stats.go).
+(https://github.com/ciao-project/ciao/blob/master/payloads/stats.go).
 
 ```
 +----------------------------------------------------------------------------+
@@ -240,7 +209,7 @@ stop and migrate all of the current workloads it is monitoring on
 its node.
 
 The [EVACUATE YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/evacuate.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/evacuate.go)
 is mandatory and describes the next state to reach after evacuation
 is done. It could be 'shutdown' for shutting the node down, 'update'
 for having it run a software update, 'reboot' for rebooting the node
@@ -267,7 +236,7 @@ When asked to delete a non existing instance the CN Agent
 must reply with a DeleteFailure error frame.
 
 The [DELETE YAML payload schema]
-(https://github.com/01org/ciao/blob/master/payloads/stop.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/stop.go)
 is the same as the STOP one.
 
 ```
@@ -277,26 +246,6 @@ is the same as the STOP one.
 +--------------------------------------------------------------------+
 ```
 
-#### RESTART ####
-The CIAO Controller client may send RESTART commands in order to
-restart previously STOPped persistent instances.
-Non persistent instances cannot be RESTARTed as they are
-implicitly deleted when being STOPped.
-
-When asked to restart a non existing instance the CN Agent
-must reply with a RestartFailure error frame.
-
-The [RESTART YAML payload schema]
-(https://github.com/01org/ciao/blob/master/payloads/start.go)
-is the same as the STOP one.
-
-```
-+--------------------------------------------------------------------+
-| Major | Minor | Type  | Operand |  Payload Length | YAML formatted |
-|       |       | (0x0) |  (0x6)  |                 |     payload    |
-+--------------------------------------------------------------------+
-```
-
 #### AssignPublicIP ####
 AssingPublicIP is a command sent by the Controller to assign
 a publicly routable IP to a given instance. It is sent
@@ -306,7 +255,7 @@ The public IP is fetched from a pre-allocated pool
 managed by the Controller.
 
 The [AssignPublicIP YAML payload schema]
-(https://github.com/01org/ciao/blob/master/payloads/assignpublicIP.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/assignpublicIP.go)
 is made of the CNC, the tenant and the instance UUIDs,
 the allocated public IP and the instance private IP and MAC.
 
@@ -326,7 +275,7 @@ The released public IP is added back to the Controller managed
 IP pool.
 
 The [ReleasePublicIP YAML payload schema]
-(https://github.com/01org/ciao/blob/master/payloads/assignpublicIP.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/assignpublicIP.go)
 is made of the CNCI and a tenant UUIDs, the released
 public IP, the instance private IP and MAC.
 
@@ -353,7 +302,7 @@ CONFIGURE commands should be sent in the following cases:
 * Every time a new agent joins the SSNTP network.
 
 The [CONFIGURE YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/configure.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/configure.go)
 always includes the full cloud configuration and not only changes
 compared to the last CONFIGURE command sent.
 
@@ -377,17 +326,6 @@ The AttachVolume command payload includes a volume UUID and an instance UUID.
 +-----------------------------------------------------------------------------+
 ```
 
-#### DetachVolume ####
-DetachVolume is a command sent to ciao-launcher for detaching a storage volume
-from a specific running or paused instance.
-
-The DetachVolume command payload includes a volume UUID and an instance UUID.
-
-```
-+-----------------------------------------------------------------------------+
-| Major | Minor | Type  | Operand |  Payload Length | YAML formatted payload  |
-|       |       | (0x0) |  (0xb)  |                 |                         |
-+-----------------------------------------------------------------------------+
 ```
 
 #### Restore ####
@@ -423,7 +361,7 @@ information:
    the TLS connection to the server.
 
 The CONNECTED frame payload is the same as the
-[CONFIGURE one](https://github.com/01org/ciao/blob/master/payloads/configure.go)
+[CONFIGURE one](https://github.com/ciao-project/ciao/blob/master/payloads/configure.go)
 and contains cluster configuration data.
 
 ```
@@ -439,7 +377,7 @@ Scheduler know that:
 
 1. Their CN capacity has changed. The new capacity is described
    in the [READY YAML payload]
-   (https://github.com/01org/ciao/blob/master/payloads/ready.go).
+   (https://github.com/ciao-project/ciao/blob/master/payloads/ready.go).
    This is the main piece of information the Scheduler uses to
    make its instances scheduling decisions.
 2. They are ready to take further commands, and in particular to
@@ -558,7 +496,7 @@ forward the notification to the right CNCI (Compute Node Concentrator Instance),
 i.e. the CNCI running the tenant workload.
 
 A [TenantAdded event payload]
-(https://github.com/01org/ciao/blob/master/payloads/tenantadded.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/tenantadded.go)
 is a YAML formatted one containing the tenant, the agent
 and the concentrator instance (CNCI) UUID, the tenant subnet,
 the agent and the CNCI IPs, the subnet key and the CNCI MAC.
@@ -582,7 +520,7 @@ Node Concentrator Instance), i.e. the CNCI running the
 tenant workload.
 
 A [TenantRemoved event payload]
-(https://github.com/01org/ciao/blob/master/payloads/tenantadded.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/tenantadded.go)
 is a YAML formatted one containing the tenant, the agent
 and the concentrator instance (CNCI) UUID, the tenant subnet,
 the agent and the CNCI IPs, and the subnet key.
@@ -607,7 +545,7 @@ instance would no longer be there) it is safer, simpler
 and less error prone to explicitly send this event.
 
 A [InstanceDeleted event payload]
-(https://github.com/01org/ciao/blob/master/payloads/instancedeleted.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/instancedeleted.go)
 is a YAML formatted one containing the deleted instance UUID.
 
 The Scheduler receives InstanceDeleted events from the
@@ -639,7 +577,7 @@ a ConcentratorInstanceAdded event as instances will be
 isolated as long as the CNCI for this tenant is not running.
 
 A [ConcentratorInstanceAdded event payload]
-(https://github.com/01org/ciao/blob/master/payloads/concentratorinstanceadded.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/concentratorinstanceadded.go)
 is a YAML formatted one containing the CNCI IP and the tenant
 UUID on behalf of which the CNCI runs.
 
@@ -660,7 +598,7 @@ or from a control network DHCP server.
 The Scheduler must forward those events to the Controller.
 
 The [PublicIPAssigned event payload]
-(https://github.com/01org/ciao/blob/master/payloads/concentratorinstanceadded.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/concentratorinstanceadded.go)
 contains the newly assigned public IP, the instance private IP,
 the instance UUID and the concentrator UUID.
 
@@ -678,7 +616,7 @@ to let the CIAO controller know about any kind of frame traces.
 It is then up to the Controller to interpret and store those traces.
 
 The [TraveReport event payload]
-(https://github.com/01org/ciao/blob/master/payloads/tracereport.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/tracereport.go)
 contains a set of frame traces.
 
 ```
@@ -692,7 +630,7 @@ contains a set of frame traces.
 NodeConnected events are sent by the Scheduler to notify e.g. the Controllers about
 a new compute or networking node being connected.
 The [NodeConnected event payload]
-(https://github.com/01org/ciao/blob/master/payloads/nodeconnected.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/nodeconnected.go)
 contains the connected node UUID and the node type (compute or networking)
 
 ```
@@ -706,7 +644,7 @@ contains the connected node UUID and the node type (compute or networking)
 NodeDisconnected events are sent by the Scheduler to notify e.g. the Controllers about
 a compute or networking node disconnection.
 The [NodeDisconnected event payload]
-(https://github.com/01org/ciao/blob/master/payloads/nodeconnected.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/nodeconnected.go)
 contains the disconnected node UUID and the node type (compute or networking)
 
 ```
@@ -731,7 +669,7 @@ support, it should send an InvalidFrameType error back
 to the sender.
 
 The [InvalidFrameType error payload]
-(https://github.com/01org/ciao/blob/master/payloads/invalidframetype.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/invalidframetype.go)
 only contains the SSNTP frame type that the receiver could
 not process:
 
@@ -761,7 +699,7 @@ instance could not be started. For example:
   it to the Controller.
 
 The [StartFailure YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/startfailure.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/startfailure.go)
 contains the instance UUID that failed to be started together
 with an additional error string.
 
@@ -786,7 +724,7 @@ instance is running.
   to the Scheduler and the Scheduler must forward it to the Controller.
 
 The [StopFailure YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/startfailure.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/startfailure.go)
 contains the instance UUID that failed to be stopped together
 with an additional error string.
 
@@ -824,7 +762,7 @@ it sends a DELETE SSNTP command to the Scheduler.
   to the Scheduler and the Scheduler must forward it to the Controller.
 
 The [DeleteFailure YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/deletefailure.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/deletefailure.go)
 contains the instance UUID that failed to be stopped together
 with an additional error string.
 ```
@@ -846,7 +784,7 @@ it sends a RESTART SSNTP command to the Scheduler.
   to the Scheduler and the Scheduler must forward it to the Controller.
 
 The [RestartFailure YAML payload]
-(https://github.com/01org/ciao/blob/master/payloads/startfailure.go)
+(https://github.com/ciao-project/ciao/blob/master/payloads/startfailure.go)
 contains the instance UUID that failed to be stopped together
 with an additional error string.
 ```
@@ -882,7 +820,7 @@ When the scheduler receives such error back from any client it should revert
 back to the previous valid configuration.
 
 The InvalidConfiguration error frame contain the invalid
-[configuration data](https://github.com/01org/ciao/blob/master/payloads/configure.go) payload.
+[configuration data](https://github.com/ciao-project/ciao/blob/master/payloads/configure.go) payload.
 ```
 +------------------------------------------------------------------------+
 | Major | Minor | Type  | Operand |  Payload Length | YAML formatted     |
diff --git a/vendor/github.com/01org/ciao/ssntp/client.go b/vendor/github.com/01org/ciao/ssntp/client.go
index e04931a4..1e1b89bb 100644
--- a/vendor/github.com/01org/ciao/ssntp/client.go
+++ b/vendor/github.com/01org/ciao/ssntp/client.go
@@ -23,8 +23,8 @@ import (
 	"sync"
 	"time"
 
-	"github.com/01org/ciao/payloads"
-	"github.com/01org/ciao/ssntp/uuid"
+	"github.com/ciao-project/ciao/payloads"
+	"github.com/ciao-project/ciao/ssntp/uuid"
 	"gopkg.in/yaml.v2"
 )
 
diff --git a/vendor/github.com/01org/ciao/ssntp/example_client_test.go b/vendor/github.com/01org/ciao/ssntp/example_client_test.go
index dc032ad0..b8bc0a07 100644
--- a/vendor/github.com/01org/ciao/ssntp/example_client_test.go
+++ b/vendor/github.com/01org/ciao/ssntp/example_client_test.go
@@ -18,7 +18,7 @@ package ssntp_test
 
 import (
 	"fmt"
-	. "github.com/01org/ciao/ssntp"
+	. "github.com/ciao-project/ciao/ssntp"
 	"time"
 )
 
diff --git a/vendor/github.com/01org/ciao/ssntp/example_server_test.go b/vendor/github.com/01org/ciao/ssntp/example_server_test.go
index 5e7c94be..0175f239 100644
--- a/vendor/github.com/01org/ciao/ssntp/example_server_test.go
+++ b/vendor/github.com/01org/ciao/ssntp/example_server_test.go
@@ -18,7 +18,7 @@ package ssntp_test
 
 import (
 	"fmt"
-	. "github.com/01org/ciao/ssntp"
+	. "github.com/ciao-project/ciao/ssntp"
 )
 
 type logger struct{}
diff --git a/vendor/github.com/01org/ciao/ssntp/frame.go b/vendor/github.com/01org/ciao/ssntp/frame.go
index 5bfd67e0..43a70035 100644
--- a/vendor/github.com/01org/ciao/ssntp/frame.go
+++ b/vendor/github.com/01org/ciao/ssntp/frame.go
@@ -20,8 +20,8 @@ import (
 	"fmt"
 	"time"
 
-	"github.com/01org/ciao/payloads"
-	"github.com/01org/ciao/ssntp/uuid"
+	"github.com/ciao-project/ciao/payloads"
+	"github.com/ciao-project/ciao/ssntp/uuid"
 )
 
 // TraceConfig is the SSNTP tracing configuration to be used
diff --git a/vendor/github.com/01org/ciao/ssntp/server.go b/vendor/github.com/01org/ciao/ssntp/server.go
index 2b10aae7..f6a395fa 100644
--- a/vendor/github.com/01org/ciao/ssntp/server.go
+++ b/vendor/github.com/01org/ciao/ssntp/server.go
@@ -24,8 +24,8 @@ import (
 	"sync"
 	"time"
 
-	"github.com/01org/ciao/configuration"
-	"github.com/01org/ciao/ssntp/uuid"
+	"github.com/ciao-project/ciao/configuration"
+	"github.com/ciao-project/ciao/ssntp/uuid"
 )
 
 // ServerNotifier is the SSNTP server notification interface.
diff --git a/vendor/github.com/01org/ciao/ssntp/session.go b/vendor/github.com/01org/ciao/ssntp/session.go
index 1605ddfb..27e6d207 100644
--- a/vendor/github.com/01org/ciao/ssntp/session.go
+++ b/vendor/github.com/01org/ciao/ssntp/session.go
@@ -21,7 +21,7 @@ import (
 	"net"
 	"time"
 
-	"github.com/01org/ciao/ssntp/uuid"
+	"github.com/ciao-project/ciao/ssntp/uuid"
 )
 
 func setReadTimeout(conn net.Conn) {
diff --git a/vendor/github.com/01org/ciao/ssntp/ssntp.go b/vendor/github.com/01org/ciao/ssntp/ssntp.go
index a60aaa3f..4bc2166a 100644
--- a/vendor/github.com/01org/ciao/ssntp/ssntp.go
+++ b/vendor/github.com/01org/ciao/ssntp/ssntp.go
@@ -32,7 +32,7 @@ import (
 	"sync"
 	"syscall"
 
-	"github.com/01org/ciao/ssntp/uuid"
+	"github.com/ciao-project/ciao/ssntp/uuid"
 	"github.com/golang/glog"
 )
 
@@ -42,7 +42,7 @@ type Type uint8
 
 // Command is the SSNTP Command operand.
 // It can be CONNECT, START, STOP, STATS, EVACUATE, DELETE, RESTART,
-// AssignPublicIP, ReleasePublicIP, CONFIGURE, AttachVolume or DetachVolume.
+// AssignPublicIP, ReleasePublicIP, CONFIGURE or AttachVolume.
 type Command uint8
 
 // Status is the SSNTP Status operand.
@@ -113,16 +113,6 @@ const (
 	//	+-----------------------------------------------------------------------------------------+
 	START
 
-	// STOP is used to ask a CIAO agent to stop a running workload. The workload
-	// is identified by its UUID, as part of the YAML formatted payload:
-	//					   SSNTP STOP Command frame
-	//
-	//	+----------------------------------------------------------------------------------+
-	//	| Major | Minor | Type  | Operand |  Payload Length | YAML formatted workload UUID |
-	//	|       |       | (0x0) |  (0x2)  |                 |                              |
-	//	+----------------------------------------------------------------------------------+
-	STOP
-
 	// STATS is a command sent by CIAO agents to update the SSNTP network
 	// about their compute node statistics. Agents can send that command to either
 	// the main server or to the Controllers directly. In the former case the server will
@@ -162,19 +152,6 @@ const (
 	//	+------------------------------------------------------------------------------+
 	DELETE
 
-	// RESTART is a command sent to CIAO CN Agents for restarting an instance that was
-	// previously STOPped. This command is only relevant for persistent workloads since
-	// non persistent ones are implicitly deleted when STOPped and thus can not be
-	// RESTARTed.
-	// The RESTART command payload uses the same YAML schema as the STOP command one, i.e.
-	// an instance UUID and an agent UUID.
-	//                                         SSNTP DELETE Command frame
-	//	+------------------------------------------------------------------------------+
-	//	| Major | Minor | Type  | Operand |  Payload Length | YAML formatted payload   |
-	//	|       |       | (0x0) |  (0x6)  |                 | instance and agent UUIDs |
-	//	+------------------------------------------------------------------------------+
-	RESTART
-
 	// AssignPublicIP is a command sent by the Controller to assign
 	// a publicly routable IP to a given instance. It is sent
 	// to the Scheduler and must be forwarded to the right CNCI.
@@ -242,18 +219,6 @@ const (
 	//	+-----------------------------------------------------------------------------+
 	AttachVolume
 
-	// DetachVolume is a command sent to ciao-launcher for detaching a storage volume
-	// from a specific running or paused instance.
-	//
-	// The DetachVolume command payload includes a volume UUID and an instance UUID.
-	//
-	//                                       SSNTP DetachVolume Command frame
-	//	+-----------------------------------------------------------------------------+
-	//	| Major | Minor | Type  | Operand |  Payload Length | YAML formatted payload  |
-	//	|       |       | (0x0) |  (0xb)  |                 |                         |
-	//	+-----------------------------------------------------------------------------+
-	DetachVolume
-
 	// Restore is used to ask a specific CIAO agent that had previously been placed into
 	// maintenance mode by an EVACUATE command to start accepting new instances once more.
 	// The payload for this command contains the UIID of the node to restore.
@@ -562,10 +527,6 @@ const (
 	// a volume to an instance.
 	AttachVolumeFailure
 
-	// DetachVolumeFailure is sent by launcher agents to report a failure to detach
-	// a volume from an instance.
-	DetachVolumeFailure
-
 	// AssignPublicIPFailure is sent by the CNCI when a an external IP
 	// cannot be assigned.
 	AssignPublicIPFailure
@@ -608,16 +569,12 @@ func (command Command) String() string {
 		return "CONNECT"
 	case START:
 		return "START"
-	case STOP:
-		return "STOP"
 	case STATS:
 		return "STATISTICS"
 	case EVACUATE:
 		return "EVACUATE"
 	case DELETE:
 		return "DELETE"
-	case RESTART:
-		return "RESTART"
 	case AssignPublicIP:
 		return "Assign public IP"
 	case ReleasePublicIP:
@@ -626,8 +583,6 @@ func (command Command) String() string {
 		return "CONFIGURE"
 	case AttachVolume:
 		return "Attach storage volume"
-	case DetachVolume:
-		return "Detach storage volume"
 	case Restore:
 		return "Restore"
 	}
diff --git a/vendor/github.com/01org/ciao/ssntp/ssntp_test.go b/vendor/github.com/01org/ciao/ssntp/ssntp_test.go
index 6668f18b..5ce72f25 100644
--- a/vendor/github.com/01org/ciao/ssntp/ssntp_test.go
+++ b/vendor/github.com/01org/ciao/ssntp/ssntp_test.go
@@ -28,8 +28,8 @@ import (
 	"testing"
 	"time"
 
-	. "github.com/01org/ciao/ssntp"
-	"github.com/01org/ciao/testutil"
+	. "github.com/ciao-project/ciao/ssntp"
+	"github.com/ciao-project/ciao/testutil"
 )
 
 const tempCertPath = "/tmp/ssntp-test-certs"
@@ -1578,7 +1578,7 @@ func TestCommandNoDuration(t *testing.T) {
 	}
 
 	client.payload = []byte{'Y', 'A', 'M', 'L'}
-	client.ssntp.SendCommand(RESTART, client.payload)
+	client.ssntp.SendCommand(START, client.payload)
 
 	defer func() {
 		client.ssntp.Close()
@@ -1587,7 +1587,7 @@ func TestCommandNoDuration(t *testing.T) {
 
 	select {
 	case check := <-client.cmdChannel:
-		if check != RESTART.String() {
+		if check != START.String() {
 			t.Fatalf("Did not receive the right payload")
 		}
 	case <-time.After(time.Second):
@@ -1832,7 +1832,7 @@ func TestError(t *testing.T) {
 func TestCmdFwd(t *testing.T) {
 	var server ssntpServer
 	var controller, agent ssntpClient
-	command := STOP
+	command := START
 
 	server.t = t
 	serverConfig, err := buildTestConfig(SCHEDULER)
@@ -2470,16 +2470,13 @@ func TestCommandStringer(t *testing.T) {
 	}{
 		{CONNECT, "CONNECT"},
 		{START, "START"},
-		{STOP, "STOP"},
 		{STATS, "STATISTICS"},
 		{EVACUATE, "EVACUATE"},
 		{DELETE, "DELETE"},
-		{RESTART, "RESTART"},
 		{AssignPublicIP, "Assign public IP"},
 		{ReleasePublicIP, "Release public IP"},
 		{CONFIGURE, "CONFIGURE"},
 		{AttachVolume, "Attach storage volume"},
-		{DetachVolume, "Detach storage volume"},
 	}
 
 	for _, test := range stringTests {
diff --git a/vendor/github.com/Sirupsen/logrus/.travis.yml b/vendor/github.com/Sirupsen/logrus/.travis.yml
deleted file mode 100644
index ef00c00e..00000000
--- a/vendor/github.com/Sirupsen/logrus/.travis.yml
+++ /dev/null
@@ -1,9 +0,0 @@
-language: go
-go:
-  - 1.6.x
-  - 1.7.x
-  - 1.8.x
-  - tip
-install:
-  - go get -t ./...
-script: GOMAXPROCS=4 GORACE="halt_on_error=1" go test -race -v ./...
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_appengine.go b/vendor/github.com/Sirupsen/logrus/terminal_appengine.go
deleted file mode 100644
index e011a869..00000000
--- a/vendor/github.com/Sirupsen/logrus/terminal_appengine.go
+++ /dev/null
@@ -1,10 +0,0 @@
-// +build appengine
-
-package logrus
-
-import "io"
-
-// IsTerminal returns true if stderr's file descriptor is a terminal.
-func IsTerminal(f io.Writer) bool {
-	return true
-}
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_bsd.go b/vendor/github.com/Sirupsen/logrus/terminal_bsd.go
deleted file mode 100644
index 5f6be4d3..00000000
--- a/vendor/github.com/Sirupsen/logrus/terminal_bsd.go
+++ /dev/null
@@ -1,10 +0,0 @@
-// +build darwin freebsd openbsd netbsd dragonfly
-// +build !appengine
-
-package logrus
-
-import "syscall"
-
-const ioctlReadTermios = syscall.TIOCGETA
-
-type Termios syscall.Termios
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_notwindows.go b/vendor/github.com/Sirupsen/logrus/terminal_notwindows.go
deleted file mode 100644
index 190297ab..00000000
--- a/vendor/github.com/Sirupsen/logrus/terminal_notwindows.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Based on ssh/terminal:
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux darwin freebsd openbsd netbsd dragonfly
-// +build !appengine
-
-package logrus
-
-import (
-	"io"
-	"os"
-	"syscall"
-	"unsafe"
-)
-
-// IsTerminal returns true if stderr's file descriptor is a terminal.
-func IsTerminal(f io.Writer) bool {
-	var termios Termios
-	switch v := f.(type) {
-	case *os.File:
-		_, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(v.Fd()), ioctlReadTermios, uintptr(unsafe.Pointer(&termios)), 0, 0, 0)
-		return err == 0
-	default:
-		return false
-	}
-}
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_solaris.go b/vendor/github.com/Sirupsen/logrus/terminal_solaris.go
deleted file mode 100644
index 3c86b1ab..00000000
--- a/vendor/github.com/Sirupsen/logrus/terminal_solaris.go
+++ /dev/null
@@ -1,21 +0,0 @@
-// +build solaris,!appengine
-
-package logrus
-
-import (
-	"io"
-	"os"
-
-	"golang.org/x/sys/unix"
-)
-
-// IsTerminal returns true if the given file descriptor is a terminal.
-func IsTerminal(f io.Writer) bool {
-	switch v := f.(type) {
-	case *os.File:
-		_, err := unix.IoctlGetTermios(int(v.Fd()), unix.TCGETA)
-		return err == nil
-	default:
-		return false
-	}
-}
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_windows.go b/vendor/github.com/Sirupsen/logrus/terminal_windows.go
deleted file mode 100644
index 05d2f91f..00000000
--- a/vendor/github.com/Sirupsen/logrus/terminal_windows.go
+++ /dev/null
@@ -1,33 +0,0 @@
-// Based on ssh/terminal:
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build windows,!appengine
-
-package logrus
-
-import (
-	"io"
-	"os"
-	"syscall"
-	"unsafe"
-)
-
-var kernel32 = syscall.NewLazyDLL("kernel32.dll")
-
-var (
-	procGetConsoleMode = kernel32.NewProc("GetConsoleMode")
-)
-
-// IsTerminal returns true if stderr's file descriptor is a terminal.
-func IsTerminal(f io.Writer) bool {
-	switch v := f.(type) {
-	case *os.File:
-		var st uint32
-		r, _, e := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(v.Fd()), uintptr(unsafe.Pointer(&st)), 0)
-		return r != 0 && e == 0
-	default:
-		return false
-	}
-}
diff --git a/vendor/github.com/containers/virtcontainers/.pullapprove.yml b/vendor/github.com/containers/virtcontainers/.pullapprove.yml
index c24457b5..c339ce3f 100644
--- a/vendor/github.com/containers/virtcontainers/.pullapprove.yml
+++ b/vendor/github.com/containers/virtcontainers/.pullapprove.yml
@@ -39,10 +39,10 @@ groups:
   approvers:
     required: 1
     users:
-      - dlespiau
       - sameo
       - sboeuf
       - amshinde
+      - jodh-intel
 
   reviewers:
     required: 1
diff --git a/vendor/github.com/containers/virtcontainers/Gopkg.lock b/vendor/github.com/containers/virtcontainers/Gopkg.lock
index ea021ee7..48edb7b5 100644
--- a/vendor/github.com/containers/virtcontainers/Gopkg.lock
+++ b/vendor/github.com/containers/virtcontainers/Gopkg.lock
@@ -5,25 +5,19 @@
   branch = "master"
   name = "github.com/01org/ciao"
   packages = ["qemu","ssntp/uuid"]
-  revision = "9d6632430ecf42a35c23b7c6cdc560d5116d9483"
+  revision = "221e8b626c089e06ba37e095fac372b779077e5d"
 
 [[projects]]
-  branch = "master"
-  name = "github.com/Sirupsen/logrus"
-  packages = ["."]
-  revision = "89742aefa4b206dcf400792f3bd35b542998eb3b"
-
-[[projects]]
-  branch = "master"
   name = "github.com/clearcontainers/proxy"
   packages = ["api","client"]
-  revision = "e9cee5aa68bf2b5dd28b062f2fd67b98df3d0a6c"
+  revision = "1d2a6a3ea132a86abd0731408b7dc34f2fc17d55"
+  version = "3.0.1"
 
 [[projects]]
   branch = "master"
   name = "github.com/containernetworking/cni"
   packages = ["libcni","pkg/invoke","pkg/types","pkg/types/020","pkg/types/current","pkg/version"]
-  revision = "6614adf4a42990cf3b400c119835fb3e5650a364"
+  revision = "ff7c3e02e3c212f63a642ad64a5ed22ee54450bd"
 
 [[projects]]
   branch = "master"
@@ -38,10 +32,16 @@
   version = "v1.1.0"
 
 [[projects]]
+  name = "github.com/go-ini/ini"
+  packages = ["."]
+  revision = "20b96f641a5ea98f2f8619ff4f3e061cff4833bd"
+  version = "v1.28.2"
+
+[[projects]]
   branch = "master"
   name = "github.com/kubernetes-incubator/cri-o"
   packages = ["pkg/annotations"]
-  revision = "5e3c53c1721e9fdd6a3c52fcd953dfa35af846d5"
+  revision = "3394b3b2d6af0e41d185bb695c6378be5dd4d61d"
 
 [[projects]]
   branch = "master"
@@ -53,13 +53,13 @@
   branch = "master"
   name = "github.com/opencontainers/runc"
   packages = ["libcontainer/configs"]
-  revision = "593914b8bd5448a93f7c3e4902a03408b6d5c0ce"
+  revision = "0351df1c5a66838d0c392b4ac4cf9450de844e2d"
 
 [[projects]]
   branch = "master"
   name = "github.com/opencontainers/runtime-spec"
   packages = ["specs-go"]
-  revision = "325e66a6635c2bc78fafbfd994010c9ea4ead824"
+  revision = "a8125598b32a65ff55c83214d3c262383178e7fa"
 
 [[projects]]
   name = "github.com/pmezard/go-difflib"
@@ -68,10 +68,10 @@
   version = "v1.0.0"
 
 [[projects]]
+  branch = "master"
   name = "github.com/sirupsen/logrus"
   packages = ["."]
-  revision = "f006c2ac4710855cf0f916dd6b77acf6b048dc6e"
-  version = "v1.0.3"
+  revision = "89742aefa4b206dcf400792f3bd35b542998eb3b"
 
 [[projects]]
   branch = "master"
@@ -83,13 +83,13 @@
   branch = "master"
   name = "github.com/urfave/cli"
   packages = ["."]
-  revision = "7fb9c86b14e6a702a4157ccb5a863f07d844a207"
+  revision = "ac249472b7de27a9e8990819566d9be95ab5b816"
 
 [[projects]]
   branch = "master"
   name = "github.com/vishvananda/netlink"
   packages = [".","nl"]
-  revision = "933b978eae8c18daa1077a0eb7186b689cd9f82d"
+  revision = "177f1ceba557262b3f1c3aba4df93a29199fb4eb"
 
 [[projects]]
   branch = "master"
@@ -101,17 +101,17 @@
   branch = "master"
   name = "golang.org/x/crypto"
   packages = ["curve25519","ed25519","ed25519/internal/edwards25519","ssh","ssh/terminal"]
-  revision = "7d9177d70076375b9a59c8fde23d52d9c4a7ecd5"
+  revision = "76eec36fa14229c4b25bb894c2d0e591527af429"
 
 [[projects]]
   branch = "master"
   name = "golang.org/x/sys"
   packages = ["unix","windows"]
-  revision = "b6e1ae21643682ce023deb8d152024597b0e9bb4"
+  revision = "314a259e304ff91bd6985da2a7149bbf91237993"
 
 [solve-meta]
   analyzer-name = "dep"
   analyzer-version = 1
-  inputs-digest = "ac3b56a35ca726d7131b35a3e7ad509f2b2168c8fe25ecd37a8f83328bbdec2f"
+  inputs-digest = "816c27aebbceeb9114fedaaa611e86d5595c9bf1170f163adb8556f564576e81"
   solver-name = "gps-cdcl"
   solver-version = 1
diff --git a/vendor/github.com/containers/virtcontainers/Gopkg.toml b/vendor/github.com/containers/virtcontainers/Gopkg.toml
index ca45700d..4d6e8297 100644
--- a/vendor/github.com/containers/virtcontainers/Gopkg.toml
+++ b/vendor/github.com/containers/virtcontainers/Gopkg.toml
@@ -72,10 +72,6 @@
 
 [[constraint]]
   branch = "master"
-  name = "github.com/Sirupsen/logrus"
-
-[[constraint]]
-  branch = "master"
   name = "github.com/clearcontainers/proxy"
 
 [[constraint]]
@@ -129,3 +125,11 @@
 [[constraint]]
   branch = "master"
   name = "golang.org/x/sys"
+
+[[constraint]]
+  branch = "master"
+  name = "github.com/sirupsen/logrus"
+
+[[constraint]]
+  branch = "master"
+  name = "github.com/go-ini/ini"
diff --git a/vendor/github.com/containers/virtcontainers/NEWS b/vendor/github.com/containers/virtcontainers/NEWS
index d2f560d5..7ed0008d 100644
--- a/vendor/github.com/containers/virtcontainers/NEWS
+++ b/vendor/github.com/containers/virtcontainers/NEWS
@@ -1,3 +1,21 @@
+1.0.2:
+	Added James Hunt as maintainer
+	Added huge pages support
+	Added option for disabling nesting optimizations
+	Fixed the rootfs readonly support
+
+1.0.1:
+	Added QEMU memory locking support
+
+1.0.0:
+	Added support for memory and cpu reservation
+	Added stroage hotplug support
+	Added code of conduct
+	Added memory pre-allocation, realtime and memory locking support
+	Fixed nested virtualization support
+	Fixed log verbosity
+	Fixed pod cleanup
+
 1.0.0-rc.4:
 	Added new project approvers
 	Fixed gometalinter
diff --git a/vendor/github.com/containers/virtcontainers/OWNERS b/vendor/github.com/containers/virtcontainers/OWNERS
index 393a50c7..1f281f55 100644
--- a/vendor/github.com/containers/virtcontainers/OWNERS
+++ b/vendor/github.com/containers/virtcontainers/OWNERS
@@ -2,6 +2,6 @@ reviewers:
 - virtcontainers-maintainers
 
 approvers:
-- dlespiau
 - sameo
 - sboeuf
+- jodh-intel
diff --git a/vendor/github.com/containers/virtcontainers/api.go b/vendor/github.com/containers/virtcontainers/api.go
index 923f32ae..2a38fa30 100644
--- a/vendor/github.com/containers/virtcontainers/api.go
+++ b/vendor/github.com/containers/virtcontainers/api.go
@@ -21,7 +21,7 @@ import (
 	"runtime"
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 func init() {
@@ -32,7 +32,7 @@ var virtLog = logrus.FieldLogger(logrus.New())
 
 // SetLogger sets the logger for virtcontainers package.
 func SetLogger(logger logrus.FieldLogger) {
-	virtLog = logger
+	virtLog = logger.WithField("source", "virtcontainers")
 }
 
 // CreatePod is the virtcontainers pod creation entry point.
@@ -325,6 +325,12 @@ func StatusPod(podID string) (PodStatus, error) {
 		return PodStatus{}, errNeedPodID
 	}
 
+	lockFile, err := lockPod(podID)
+	if err != nil {
+		return PodStatus{}, err
+	}
+	defer unlockPod(lockFile)
+
 	pod, err := fetchPod(podID)
 	if err != nil {
 		return PodStatus{}, err
@@ -567,6 +573,12 @@ func StatusContainer(podID, containerID string) (ContainerStatus, error) {
 		return ContainerStatus{}, errNeedContainerID
 	}
 
+	lockFile, err := lockPod(podID)
+	if err != nil {
+		return ContainerStatus{}, err
+	}
+	defer unlockPod(lockFile)
+
 	pod, err := fetchPod(podID)
 	if err != nil {
 		return ContainerStatus{}, err
diff --git a/vendor/github.com/containers/virtcontainers/container.go b/vendor/github.com/containers/virtcontainers/container.go
index 88b36620..1e032e92 100644
--- a/vendor/github.com/containers/virtcontainers/container.go
+++ b/vendor/github.com/containers/virtcontainers/container.go
@@ -17,6 +17,7 @@
 package virtcontainers
 
 import (
+	"encoding/json"
 	"fmt"
 	"os"
 	"path/filepath"
@@ -79,15 +80,120 @@ type ContainerConfig struct {
 	Annotations map[string]string
 
 	Mounts []Mount
+
+	// Devices are devices that must be available within the container.
+	// We need the json:"-" tag so that the json package does not marshal
+	// or unmarshal that field. We need to handle it ourselves.
+	Devices []Device `json:"-"`
+}
+
+// MarshalJSON is the cutom ContainerConfig JSON marshalling routine.
+// We need such routine in order to properly marshall our Devices array.
+func (c *ContainerConfig) MarshalJSON() ([]byte, error) {
+	// We need a shadow structure in order to prevent json from
+	// entering a recursive loop when only calling json.Marshal().
+	type shadow struct {
+		ID             string
+		RootFs         string
+		ReadonlyRootfs bool
+		Cmd            Cmd
+		Annotations    map[string]string
+		Mounts         []Mount
+		Devices        []Device
+	}
+
+	s := &shadow{
+		ID:             c.ID,
+		RootFs:         c.RootFs,
+		ReadonlyRootfs: c.ReadonlyRootfs,
+		Cmd:            c.Cmd,
+		Annotations:    c.Annotations,
+		Mounts:         c.Mounts,
+		Devices:        c.Devices,
+	}
+
+	return json.Marshal(s)
+}
+
+// UnmarshalJSON is the custom ContainerConfig unmarshalling routine.
+// Unmarshalling the Devices array needs to be done through this
+// routine otherwise the json package has some hard time mapping
+// our serialized data back to the right Device.
+func (c *ContainerConfig) UnmarshalJSON(b []byte) error {
+	type tmp ContainerConfig
+	var s struct {
+		tmp
+		DevicesNoType []interface{} `json:"devices"`
+	}
+
+	if err := json.Unmarshal(b, &s); err != nil {
+		virtLog.Errorf("Unmarshalling container config error: %s", err)
+		return err
+	}
+
+	*c = ContainerConfig(s.tmp)
+
+	for _, m := range s.DevicesNoType {
+		switch deviceMap := m.(type) {
+		case map[string]interface{}:
+			deviceType, ok := deviceMap["DeviceType"]
+			if !ok {
+				continue
+			}
+
+			deviceInfo, ok := deviceMap["DeviceInfo"]
+			if !ok {
+				continue
+			}
+
+			switch deviceInfoMap := deviceInfo.(type) {
+			case map[string]interface{}:
+				info, err := newDeviceInfo(deviceInfoMap)
+				if err != nil {
+					virtLog.Errorf("Could not create new device info %v", err)
+					continue
+				}
+
+				switch deviceType {
+				case DeviceGeneric:
+					device := newGenericDevice(info)
+					if err != nil {
+						virtLog.Errorf("Could not create new device %v", err)
+						continue
+					}
+
+					c.Devices = append(c.Devices, device)
+				case DeviceVFIO:
+					device := newVFIODevice(info)
+					if err != nil {
+						virtLog.Errorf("Could not create new device %v", err)
+						continue
+					}
+
+					c.Devices = append(c.Devices, device)
+				case DeviceBlock:
+					device := newBlockDevice(info)
+					if err != nil {
+						virtLog.Errorf("Could not create new device %v", err)
+						continue
+					}
+
+					c.Devices = append(c.Devices, device)
+				}
+			}
+		}
+	}
+
+	return nil
 }
 
 // valid checks that the container configuration is valid.
-func (containerConfig *ContainerConfig) valid() bool {
-	if containerConfig == nil {
+func (c *ContainerConfig) valid() bool {
+	if c == nil {
 		return false
 	}
 
-	if containerConfig.ID == "" {
+	if c.ID == "" {
 		return false
 	}
 
@@ -115,6 +221,8 @@ type Container struct {
 	process Process
 
 	mounts []Mount
+
+	devices []Device
 }
 
 // ID returns the container identifier string.
@@ -326,6 +434,7 @@ func newContainer(pod *Pod, contConfig ContainerConfig) (*Container, error) {
 		state:         State{},
 		process:       Process{},
 		mounts:        contConfig.Mounts,
+		devices:       contConfig.Devices,
 	}
 
 	state, err := c.pod.storage.fetchContainerState(c.podID, c.id)
@@ -488,6 +597,11 @@ func (c *Container) start() error {
 		}
 	}
 
+	// Attach devices
+	if err := c.attachDevices(); err != nil {
+		return err
+	}
+
 	if err = c.pod.agent.startContainer(*(c.pod), *c); err != nil {
 		virtLog.Error("Failed to start container: ", err)
 
@@ -563,6 +677,10 @@ func (c *Container) stop() error {
 		return err
 	}
 
+	if err = c.detachDevices(); err != nil {
+		return err
+	}
+
 	if err := c.removeDrive(); err != nil {
 		return err
 	}
@@ -784,3 +902,23 @@ func (c *Container) removeDrive() (err error) {
 
 	return nil
 }
+
+func (c *Container) attachDevices() error {
+	for _, device := range c.devices {
+		if err := device.attach(c.pod.hypervisor); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (c *Container) detachDevices() error {
+	for _, device := range c.devices {
+		if err := device.detach(c.pod.hypervisor); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
diff --git a/vendor/github.com/containers/virtcontainers/device.go b/vendor/github.com/containers/virtcontainers/device.go
new file mode 100644
index 00000000..dd825abf
--- /dev/null
+++ b/vendor/github.com/containers/virtcontainers/device.go
@@ -0,0 +1,338 @@
+//
+// Copyright (c) 2017 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package virtcontainers
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+
+	"github.com/go-ini/ini"
+)
+
+const (
+	// DeviceVFIO is the VFIO device type
+	DeviceVFIO = "vfio"
+
+	// DeviceBlock is the block device type
+	DeviceBlock = "block"
+
+	// DeviceGeneric is a generic device type
+	DeviceGeneric = "generic"
+)
+
+// Defining this as a variable instead of a const, to allow
+// overriding this in the tests.
+var sysIOMMUPath = "/sys/kernel/iommu_groups"
+
+var sysDevPrefix = "/sys/dev"
+
+var blockPaths = []string{
+	"/dev/sd",   //SCSI block device
+	"/dev/hd",   //IDE block device
+	"/dev/vd",   //Virtual Block device
+	"/dev/ida/", //Compaq Intelligent Drive Array devices
+}
+
+const (
+	vfioPath = "/dev/vfio/"
+)
+
+// Device is the virtcontainers device interface.
+type Device interface {
+	attach(hypervisor) error
+	detach(hypervisor) error
+}
+
+// DeviceInfo is an embedded type that contains device data common to all types of devices.
+type DeviceInfo struct {
+	// Device path on host
+	HostPath string
+
+	// Device path inside the container
+	ContainerPath string
+
+	// Type of device: c, b, u or p
+	// c , u - character(unbuffered)
+	// p - FIFO
+	// b - block(buffered) special file
+	// More info in mknod(1).
+	DevType string
+
+	// Major, minor numbers for device.
+	Major int64
+	Minor int64
+
+	// FileMode permission bits for the device.
+	FileMode os.FileMode
+
+	// id of the device owner.
+	UID uint32
+
+	// id of the device group.
+	GID uint32
+}
+
+func newDeviceInfo(m map[string]interface{}) (DeviceInfo, error) {
+	var d DeviceInfo
+
+	s, ok := m["HostPath"]
+	if ok {
+		d.HostPath = s.(string)
+	}
+
+	s, ok = m["ContainerPath"]
+	if ok {
+		d.ContainerPath = s.(string)
+	}
+
+	s, ok = m["DevType"]
+	if ok {
+		d.DevType = s.(string)
+	}
+
+	s, ok = m["Major"]
+	if ok {
+		d.Major = int64(s.(float64))
+	}
+
+	s, ok = m["Minor"]
+	if ok {
+		d.Minor = int64(s.(float64))
+	}
+
+	s, ok = m["UID"]
+	if ok {
+		d.UID = uint32(s.(float64))
+	}
+
+	s, ok = m["GID"]
+	if ok {
+		d.GID = uint32(s.(float64))
+	}
+
+	s, ok = m["FileMode"]
+	if ok {
+		d.FileMode = os.FileMode(s.(float64))
+	}
+
+	return d, nil
+}
+
+// VFIODevice is a vfio device meant to be passed to the hypervisor
+// to be used by the Virtual Machine.
+type VFIODevice struct {
+	DeviceType string
+	DeviceInfo DeviceInfo
+	BDF        string
+}
+
+func newVFIODevice(devInfo DeviceInfo) *VFIODevice {
+	return &VFIODevice{
+		DeviceType: DeviceVFIO,
+		DeviceInfo: devInfo,
+	}
+}
+
+func (device *VFIODevice) attach(h hypervisor) error {
+	vfioGroup := filepath.Base(device.DeviceInfo.HostPath)
+	iommuDevicesPath := filepath.Join(sysIOMMUPath, vfioGroup, "devices")
+
+	deviceFiles, err := ioutil.ReadDir(iommuDevicesPath)
+	if err != nil {
+		return err
+	}
+
+	// Pass all devices in iommu group
+	for _, deviceFile := range deviceFiles {
+
+		//Get bdf of device eg 0000:00:1c.0
+		deviceBDF, err := getBDF(deviceFile.Name())
+		if err != nil {
+			return err
+		}
+
+		device.BDF = deviceBDF
+
+		if err := h.addDevice(device, vfioDev); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (device *VFIODevice) detach(h hypervisor) error {
+	return nil
+}
+
+// BlockDevice refers to a block storage device implementation.
+type BlockDevice struct {
+	DeviceType string
+	DeviceInfo DeviceInfo
+}
+
+func newBlockDevice(devInfo DeviceInfo) *BlockDevice {
+	return &BlockDevice{
+		DeviceType: DeviceBlock,
+		DeviceInfo: devInfo,
+	}
+}
+
+func (device *BlockDevice) attach(h hypervisor) error {
+	return nil
+}
+
+func (device BlockDevice) detach(h hypervisor) error {
+	return nil
+}
+
+// GenericDevice refers to a device that is neither a VFIO device or block device.
+type GenericDevice struct {
+	DeviceType string
+	DeviceInfo DeviceInfo
+}
+
+func newGenericDevice(devInfo DeviceInfo) *GenericDevice {
+	return &GenericDevice{
+		DeviceType: DeviceGeneric,
+		DeviceInfo: devInfo,
+	}
+}
+
+func (device *GenericDevice) attach(h hypervisor) error {
+	return nil
+}
+
+func (device *GenericDevice) detach(h hypervisor) error {
+	return nil
+}
+
+// isVFIO checks if the device provided is a vfio group.
+func isVFIO(hostPath string) bool {
+	if strings.HasPrefix(hostPath, vfioPath) && len(hostPath) > len(vfioPath) {
+		return true
+	}
+
+	return false
+}
+
+// isBlock checks if the device is a block device.
+func isBlock(hostPath string) bool {
+	for _, blockPath := range blockPaths {
+		if strings.HasPrefix(hostPath, blockPath) && len(hostPath) > len(blockPath) {
+			return true
+		}
+	}
+
+	return false
+}
+
+func createDevice(devInfo DeviceInfo) Device {
+	path := devInfo.HostPath
+
+	if isVFIO(path) {
+		return newVFIODevice(devInfo)
+	} else if isBlock(path) {
+		return newBlockDevice(devInfo)
+	} else {
+		return newGenericDevice(devInfo)
+	}
+}
+
+// GetHostPath is used to fetcg the host path for the device.
+// The path passed in the spec refers to the path that should appear inside the container.
+// We need to find the actual device path on the host based on the major-minor numbers of the device.
+func GetHostPath(devInfo DeviceInfo) (string, error) {
+	if devInfo.ContainerPath == "" {
+		return "", fmt.Errorf("Empty path provided for device")
+	}
+
+	var pathComp string
+
+	switch devInfo.DevType {
+	case "c", "u":
+		pathComp = "char"
+	case "b":
+		pathComp = "block"
+	default:
+		// Unsupported device types. Return nil error to ignore devices
+		// that cannot be handled currently.
+		return "", nil
+	}
+
+	format := strconv.FormatInt(devInfo.Major, 10) + ":" + strconv.FormatInt(devInfo.Minor, 10)
+	sysDevPath := filepath.Join(sysDevPrefix, pathComp, format, "uevent")
+
+	content, err := ini.Load(sysDevPath)
+	if err != nil {
+		return "", err
+	}
+
+	devName, err := content.Section("").GetKey("DEVNAME")
+	if err != nil {
+		return "", err
+	}
+
+	return filepath.Join("/dev", devName.String()), nil
+}
+
+// GetHostPathFunc is function pointer used to mock GetHostPath in tests.
+var GetHostPathFunc = GetHostPath
+
+// NewDevice returns a device interface implementation based on the host path of the device.
+// The hostpath itself is inferred based on the major-minor number of the device.
+func NewDevice(path, devType string, major, minor int64, fileMode *os.FileMode, uid, gid uint32) (Device, error) {
+	devInfo := DeviceInfo{
+		Major:         major,
+		Minor:         minor,
+		UID:           uid,
+		GID:           gid,
+		DevType:       devType,
+		ContainerPath: path,
+	}
+
+	if fileMode != nil {
+		devInfo.FileMode = *fileMode
+	}
+
+	hostPath, err := GetHostPathFunc(devInfo)
+	if err != nil {
+		return nil, err
+	}
+
+	devInfo.HostPath = hostPath
+
+	device := createDevice(devInfo)
+	return device, nil
+}
+
+// bdf returns the BDF of pci device
+// Expected input strng format is [<domain>]:[<bus>][<slot>].[<func>] eg. 0000:02:10.0
+func getBDF(deviceSysStr string) (string, error) {
+	tokens := strings.Split(deviceSysStr, ":")
+
+	if len(tokens) != 3 {
+		return "", fmt.Errorf("Incorrect number of tokens found while parsing bdf for device : %s", deviceSysStr)
+	}
+
+	tokens = strings.SplitN(deviceSysStr, ":", 2)
+	return tokens[1], nil
+}
diff --git a/vendor/github.com/containers/virtcontainers/device_test.go b/vendor/github.com/containers/virtcontainers/device_test.go
new file mode 100644
index 00000000..18931ba8
--- /dev/null
+++ b/vendor/github.com/containers/virtcontainers/device_test.go
@@ -0,0 +1,237 @@
+//
+// Copyright (c) 2017 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package virtcontainers
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strconv"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestIsVFIO(t *testing.T) {
+	type testData struct {
+		path     string
+		expected bool
+	}
+
+	data := []testData{
+		{"/dev/vfio/16", true},
+		{"/dev/vfio/1", true},
+		{"/dev/vfio/", false},
+		{"/dev/vfio", false},
+		{"/dev/vf", false},
+		{"/dev", false},
+	}
+
+	for _, d := range data {
+		isVFIO := isVFIO(d.path)
+		assert.Equal(t, d.expected, isVFIO)
+	}
+}
+
+func TestIsBlock(t *testing.T) {
+	type testData struct {
+		path     string
+		expected bool
+	}
+
+	data := []testData{
+		{"/dev/sda", true},
+		{"/dev/sdbb", true},
+		{"/dev/hda", true},
+		{"/dev/hdb", true},
+		{"/dev/vf", false},
+		{"/dev/vdj", true},
+		{"/dev/vdzzz", true},
+		{"/dev/ida", false},
+		{"/dev/ida/", false},
+		{"/dev/ida/c0d0p10", true},
+	}
+
+	for _, d := range data {
+		isBlock := isBlock(d.path)
+		assert.Equal(t, d.expected, isBlock)
+	}
+}
+
+func testCreateDevice(t *testing.T) {
+	devInfo := DeviceInfo{
+		HostPath: "/dev/vfio/8",
+	}
+
+	device := createDevice(devInfo)
+	_, ok := device.(*VFIODevice)
+	assert.True(t, ok)
+
+	devInfo.HostPath = "/dev/sda"
+	device = createDevice(devInfo)
+	_, ok = device.(*BlockDevice)
+	assert.True(t, ok)
+
+	devInfo.HostPath = "/dev/tty"
+	device = createDevice(devInfo)
+	_, ok = device.(*GenericDevice)
+	assert.True(t, ok)
+}
+
+func testNewDevice(t *testing.T) {
+	savedSysDevPrefix := sysDevPrefix
+
+	major := int64(252)
+	minor := int64(3)
+
+	tmpDir, err := ioutil.TempDir("", "")
+	assert.Nil(t, err)
+	os.RemoveAll(tmpDir)
+
+	sysDevPrefix = tmpDir
+	defer func() {
+		sysDevPrefix = savedSysDevPrefix
+	}()
+
+	format := strconv.FormatInt(major, 10) + ":" + strconv.FormatInt(minor, 10)
+	ueventPath := filepath.Join(sysDevPrefix, "char", format, "uevent")
+
+	path := "/dev/vfio/2"
+	content := []byte("MAJOR=252\nMINOR=3\nDEVNAME=vfio/2")
+
+	err = ioutil.WriteFile(ueventPath, content, 0644)
+	assert.Nil(t, err)
+
+	device, err := NewDevice(path, "c", major, minor, nil, 2, 2)
+	assert.Nil(t, err)
+
+	vfioDev, ok := device.(*VFIODevice)
+	assert.True(t, ok)
+	assert.Equal(t, vfioDev.DeviceInfo.HostPath, path)
+	assert.Equal(t, vfioDev.DeviceInfo.ContainerPath, path)
+	assert.Equal(t, vfioDev.DeviceInfo.DevType, "c")
+	assert.Equal(t, vfioDev.DeviceInfo.Major, major)
+	assert.Equal(t, vfioDev.DeviceInfo.Minor, minor)
+	assert.Equal(t, vfioDev.DeviceInfo.UID, 2)
+	assert.Equal(t, vfioDev.DeviceInfo.GID, 2)
+}
+
+func TestGetBDF(t *testing.T) {
+	type testData struct {
+		deviceStr   string
+		expectedBDF string
+	}
+
+	data := []testData{
+		{"0000:02:10.0", "02:10.0"},
+		{"0000:0210.0", ""},
+		{"test", ""},
+		{"", ""},
+	}
+
+	for _, d := range data {
+		deviceBDF, err := getBDF(d.deviceStr)
+		assert.Equal(t, d.expectedBDF, deviceBDF)
+		if d.expectedBDF == "" {
+			assert.NotNil(t, err)
+		} else {
+			assert.Nil(t, err)
+		}
+	}
+}
+
+func TestAttachVFIODevice(t *testing.T) {
+	tmpDir, err := ioutil.TempDir("", "")
+	assert.Nil(t, err)
+	os.RemoveAll(tmpDir)
+
+	testFDIOGroup := "2"
+	testDeviceBDFPath := "0000:00:1c.0"
+
+	devicesDir := filepath.Join(tmpDir, testFDIOGroup, "devices")
+	err = os.MkdirAll(devicesDir, dirMode)
+	assert.Nil(t, err)
+
+	deviceFile := filepath.Join(devicesDir, testDeviceBDFPath)
+	_, err = os.Create(deviceFile)
+	assert.Nil(t, err)
+
+	savedIOMMUPath := sysIOMMUPath
+	sysIOMMUPath = tmpDir
+
+	defer func() {
+		sysIOMMUPath = savedIOMMUPath
+	}()
+
+	path := filepath.Join(vfioPath, testFDIOGroup)
+	deviceInfo := DeviceInfo{
+		HostPath:      path,
+		ContainerPath: path,
+		DevType:       "c",
+	}
+
+	device := createDevice(deviceInfo)
+	_, ok := device.(*VFIODevice)
+	assert.True(t, ok)
+
+	hypervisor := &mockHypervisor{}
+	err = device.attach(hypervisor)
+	assert.Nil(t, err)
+
+	err = device.detach(hypervisor)
+	assert.Nil(t, err)
+}
+
+func TestAttachGenericDevice(t *testing.T) {
+	path := "/dev/tty2"
+	deviceInfo := DeviceInfo{
+		HostPath:      path,
+		ContainerPath: path,
+		DevType:       "c",
+	}
+
+	device := createDevice(deviceInfo)
+	_, ok := device.(*GenericDevice)
+	assert.True(t, ok)
+
+	hypervisor := &mockHypervisor{}
+	err := device.attach(hypervisor)
+	assert.Nil(t, err)
+
+	err = device.detach(hypervisor)
+	assert.Nil(t, err)
+}
+
+func TestAttachBlockDevice(t *testing.T) {
+	path := "/dev/hda"
+	deviceInfo := DeviceInfo{
+		HostPath:      path,
+		ContainerPath: path,
+		DevType:       "c",
+	}
+
+	device := createDevice(deviceInfo)
+	_, ok := device.(*BlockDevice)
+	assert.True(t, ok)
+
+	hypervisor := &mockHypervisor{}
+	err := device.attach(hypervisor)
+	assert.Nil(t, err)
+
+	err = device.detach(hypervisor)
+	assert.Nil(t, err)
+}
diff --git a/vendor/github.com/containers/virtcontainers/hypervisor.go b/vendor/github.com/containers/virtcontainers/hypervisor.go
index ac0ef799..b15e1393 100644
--- a/vendor/github.com/containers/virtcontainers/hypervisor.go
+++ b/vendor/github.com/containers/virtcontainers/hypervisor.go
@@ -70,6 +70,9 @@ const (
 
 	// SerialPortDev is the serial port device type.
 	serialPortDev
+
+	// VFIODevice is VFIO device type
+	vfioDev
 )
 
 // Set sets an hypervisor type based on the input string.
@@ -155,6 +158,9 @@ type HypervisorConfig struct {
 	// MemPrealloc specifies if the memory should be pre-allocated
 	MemPrealloc bool
 
+	// HugePages specifies if the memory should be pre-allocated from huge pages
+	HugePages bool
+
 	// Realtime Used to enable/disable realtime
 	Realtime bool
 
@@ -162,6 +168,10 @@ type HypervisorConfig struct {
 	// Realtime=true and Mlock=false, allows for swapping out of VM memory
 	// enabling higher density
 	Mlock bool
+
+	// DisableNestingChecks is used to override customizations performed
+	// when running on top of another VMM.
+	DisableNestingChecks bool
 }
 
 func (conf *HypervisorConfig) valid() (bool, error) {
diff --git a/vendor/github.com/containers/virtcontainers/implementation.go b/vendor/github.com/containers/virtcontainers/implementation.go
index cd7687a8..71727836 100644
--- a/vendor/github.com/containers/virtcontainers/implementation.go
+++ b/vendor/github.com/containers/virtcontainers/implementation.go
@@ -21,7 +21,7 @@ package virtcontainers
 import (
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 // VCImpl is the official virtcontainers function of the same name.
diff --git a/vendor/github.com/containers/virtcontainers/interfaces.go b/vendor/github.com/containers/virtcontainers/interfaces.go
index 07f4c32d..1a543099 100644
--- a/vendor/github.com/containers/virtcontainers/interfaces.go
+++ b/vendor/github.com/containers/virtcontainers/interfaces.go
@@ -17,7 +17,7 @@ package virtcontainers
 import (
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 // VC is the Virtcontainers interface
diff --git a/vendor/github.com/containers/virtcontainers/network.go b/vendor/github.com/containers/virtcontainers/network.go
index 3c4e7d47..f9cc85af 100644
--- a/vendor/github.com/containers/virtcontainers/network.go
+++ b/vendor/github.com/containers/virtcontainers/network.go
@@ -499,6 +499,15 @@ func getIfacesFromNetNs(networkNSPath string) ([]netIfaceAddrs, error) {
 				return err
 			}
 
+			// Ignore unconfigured network interfaces
+			// These are either base tunnel devices
+			// that are not namespaced like
+			// gre0, gretap0, sit0, ipip0, tunl0
+			// or incorrectly setup interfaces
+			if (addrs == nil) || (len(addrs) == 0) {
+				continue
+			}
+
 			netIface := netIfaceAddrs{
 				iface: iface,
 				addrs: addrs,
diff --git a/vendor/github.com/containers/virtcontainers/network_test.go b/vendor/github.com/containers/virtcontainers/network_test.go
index 7c31b338..351f4087 100644
--- a/vendor/github.com/containers/virtcontainers/network_test.go
+++ b/vendor/github.com/containers/virtcontainers/network_test.go
@@ -307,25 +307,7 @@ func TestGetIfacesFromNetNsSuccessfulBridge(t *testing.T) {
 		},
 	}
 
-	expected := []netIfaceAddrs{
-		{
-			iface: net.Interface{
-				Index: 1,
-				MTU:   65536,
-				Name:  "lo",
-				Flags: net.FlagLoopback,
-			},
-		},
-		{
-			iface: net.Interface{
-				Index:        2,
-				MTU:          testMTU,
-				Name:         testNetIface,
-				HardwareAddr: hwAddr,
-				Flags:        net.FlagBroadcast | net.FlagMulticast,
-			},
-		},
-	}
+	expected := []netIfaceAddrs(nil)
 
 	testGetIfacesFromNetNsSuccessful(t, link, expected)
 }
diff --git a/vendor/github.com/containers/virtcontainers/pkg/hyperstart/hyperstart.go b/vendor/github.com/containers/virtcontainers/pkg/hyperstart/hyperstart.go
index 2f94070d..f764c72d 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/hyperstart/hyperstart.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/hyperstart/hyperstart.go
@@ -25,7 +25,7 @@ import (
 	"sync"
 	"time"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 // Control command IDs
diff --git a/vendor/github.com/containers/virtcontainers/pkg/oci/utils.go b/vendor/github.com/containers/virtcontainers/pkg/oci/utils.go
index 5e94f489..c60f5aa3 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/oci/utils.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/oci/utils.go
@@ -23,10 +23,10 @@ import (
 	"strconv"
 	"strings"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
 	"github.com/kubernetes-incubator/cri-o/pkg/annotations"
 	spec "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/sirupsen/logrus"
 )
 
 var (
@@ -193,6 +193,49 @@ func containerMounts(spec CompatOCISpec) []vc.Mount {
 	return mnts
 }
 
+func contains(s []string, e string) bool {
+	for _, a := range s {
+		if a == e {
+			return true
+		}
+	}
+	return false
+}
+
+func newLinuxDevice(d spec.LinuxDevice) (vc.Device, error) {
+	allowedDeviceTypes := []string{"c", "b", "u", "p"}
+
+	if !contains(allowedDeviceTypes, d.Type) {
+		return nil, fmt.Errorf("Unexpected Device Type %s for device %s", d.Type, d.Path)
+	}
+
+	if d.Path == "" {
+		return nil, fmt.Errorf("Path cannot be empty for device")
+	}
+
+	return vc.NewDevice(d.Path, d.Type, d.Major, d.Minor, d.FileMode, *d.UID, *d.GID)
+}
+
+func containerDevices(spec CompatOCISpec) ([]vc.Device, error) {
+	ociLinuxDevices := spec.Spec.Linux.Devices
+
+	if ociLinuxDevices == nil {
+		return []vc.Device{}, nil
+	}
+
+	var devices []vc.Device
+	for _, d := range ociLinuxDevices {
+		linuxDevice, err := newLinuxDevice(d)
+		if err != nil {
+			return []vc.Device{}, err
+		}
+
+		devices = append(devices, linuxDevice)
+	}
+
+	return devices, nil
+}
+
 func networkConfig(ocispec CompatOCISpec) (vc.NetworkConfig, error) {
 	linux := ocispec.Linux
 	if linux == nil {
@@ -417,6 +460,11 @@ func ContainerConfig(ocispec CompatOCISpec, bundlePath, cid, console string, det
 		cmd.SupplementaryGroups = append(cmd.SupplementaryGroups, strconv.FormatUint(uint64(gid), 10))
 	}
 
+	devices, err := containerDevices(ocispec)
+	if err != nil {
+		return vc.ContainerConfig{}, err
+	}
+
 	containerConfig := vc.ContainerConfig{
 		ID:             cid,
 		RootFs:         rootfs,
@@ -426,7 +474,8 @@ func ContainerConfig(ocispec CompatOCISpec, bundlePath, cid, console string, det
 			ConfigJSONKey: string(ociSpecJSON),
 			BundlePathKey: bundlePath,
 		},
-		Mounts: containerMounts(ocispec),
+		Mounts:  containerMounts(ocispec),
+		Devices: devices,
 	}
 
 	cType, err := ocispec.ContainerType()
diff --git a/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test.go b/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test.go
index a5a6e8b1..076f1dd9 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test.go
@@ -29,6 +29,7 @@ import (
 	vc "github.com/containers/virtcontainers"
 	"github.com/kubernetes-incubator/cri-o/pkg/annotations"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/stretchr/testify/assert"
 )
 
 const tempBundlePath = "/tmp/virtc/ocibundle/"
@@ -55,6 +56,17 @@ func TestMinimalPodConfig(t *testing.T) {
 		t.Fatal(err)
 	}
 
+	savedFunc := vc.GetHostPathFunc
+
+	// Simply assign container path to host path for device.
+	vc.GetHostPathFunc = func(devInfo vc.DeviceInfo) (string, error) {
+		return devInfo.ContainerPath, nil
+	}
+
+	defer func() {
+		vc.GetHostPathFunc = savedFunc
+	}()
+
 	runtimeConfig := RuntimeConfig{
 		HypervisorType: vc.QemuHypervisor,
 		AgentType:      vc.HyperstartAgent,
@@ -118,6 +130,24 @@ func TestMinimalPodConfig(t *testing.T) {
 		t.Fatal(err)
 	}
 
+	devInfo := vc.DeviceInfo{
+		ContainerPath: "/dev/vfio/17",
+		HostPath:      "/dev/vfio/17",
+		Major:         242,
+		Minor:         0,
+		DevType:       "c",
+		UID:           0,
+		GID:           0,
+	}
+
+	vfioDevice := vc.VFIODevice{}
+	vfioDevice.DeviceInfo = devInfo
+	vfioDevice.DeviceType = vc.DeviceVFIO
+
+	expectedDevices := []vc.Device{
+		&vfioDevice,
+	}
+
 	expectedContainerConfig := vc.ContainerConfig{
 		ID:             containerID,
 		RootFs:         path.Join(tempBundlePath, "rootfs"),
@@ -128,7 +158,8 @@ func TestMinimalPodConfig(t *testing.T) {
 			BundlePathKey:    tempBundlePath,
 			ContainerTypeKey: string(vc.PodSandbox),
 		},
-		Mounts: expectedMounts,
+		Mounts:  expectedMounts,
+		Devices: expectedDevices,
 	}
 
 	expectedNetworkConfig := vc.NetworkConfig{
@@ -632,6 +663,47 @@ func TestAddKernelParamInvalid(t *testing.T) {
 	}
 }
 
+func TestDeviceTypeFailure(t *testing.T) {
+	var ociSpec CompatOCISpec
+
+	invalidDeviceType := "f"
+	ociSpec.Linux = &specs.Linux{}
+	ociSpec.Linux.Devices = []specs.LinuxDevice{
+		{
+			Path: "/dev/vfio",
+			Type: invalidDeviceType,
+		},
+	}
+
+	_, err := containerDevices(ociSpec)
+	assert.NotNil(t, err, "This test should fail as device type [%s] is invalid ", invalidDeviceType)
+}
+
+func TestContains(t *testing.T) {
+	s := []string{"char", "block", "pipe"}
+
+	assert.True(t, contains(s, "char"))
+	assert.True(t, contains(s, "pipe"))
+	assert.False(t, contains(s, "chara"))
+	assert.False(t, contains(s, "socket"))
+}
+
+func TestDevicePathEmpty(t *testing.T) {
+	var ociSpec CompatOCISpec
+
+	ociSpec.Linux = &specs.Linux{}
+	ociSpec.Linux.Devices = []specs.LinuxDevice{
+		{
+			Type:  "c",
+			Major: 252,
+			Minor: 1,
+		},
+	}
+
+	_, err := containerDevices(ociSpec)
+	assert.NotNil(t, err, "This test should fail as path cannot be empty for device")
+}
+
 func TestMain(m *testing.M) {
 	/* Create temp bundle directory if necessary */
 	err := os.MkdirAll(tempBundlePath, dirMode)
diff --git a/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test_config.go b/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test_config.go
index e00ed3e1..a7acb18c 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test_config.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/oci/utils_test_config.go
@@ -90,6 +90,16 @@ const minimalConfig = `
 	],
 	"hooks": {},
 	"linux": {
+		"devices": [
+				{
+					"gid": 0,
+					"major": 242,
+					"minor": 0,
+					"path": "/dev/vfio/17",
+					"type": "c",
+					"uid": 0
+				 }
+			],
 		"resources": {
 			"devices": [
 				{
diff --git a/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock.go b/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock.go
index e1613d9e..c5ce9965 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock.go
@@ -28,8 +28,8 @@ import (
 	"fmt"
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
+	"github.com/sirupsen/logrus"
 )
 
 // mockErrorPrefix is a string that all errors returned by the mock
diff --git a/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock_test.go b/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock_test.go
index 2bcecc61..2c30b035 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock_test.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/vcMock/mock_test.go
@@ -19,8 +19,8 @@ import (
 	"syscall"
 	"testing"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
+	"github.com/sirupsen/logrus"
 	"github.com/stretchr/testify/assert"
 )
 
diff --git a/vendor/github.com/containers/virtcontainers/pkg/vcMock/types.go b/vendor/github.com/containers/virtcontainers/pkg/vcMock/types.go
index 25c22376..1a19799c 100644
--- a/vendor/github.com/containers/virtcontainers/pkg/vcMock/types.go
+++ b/vendor/github.com/containers/virtcontainers/pkg/vcMock/types.go
@@ -17,8 +17,8 @@ package vcMock
 import (
 	"syscall"
 
-	"github.com/Sirupsen/logrus"
 	vc "github.com/containers/virtcontainers"
+	"github.com/sirupsen/logrus"
 )
 
 // Pod is a fake Pod type used for testing
diff --git a/vendor/github.com/containers/virtcontainers/pod.go b/vendor/github.com/containers/virtcontainers/pod.go
index 31791688..c1df8578 100644
--- a/vendor/github.com/containers/virtcontainers/pod.go
+++ b/vendor/github.com/containers/virtcontainers/pod.go
@@ -522,6 +522,11 @@ func createPod(podConfig PodConfig) (*Pod, error) {
 		return nil, err
 	}
 
+	// Passthrough devices
+	if err := p.attachDevices(); err != nil {
+		return nil, err
+	}
+
 	// fetch agent capabilities and call addDrives if the agent has support
 	// for block devices.
 	caps := p.agent.capabilities()
@@ -707,6 +712,9 @@ func (p *Pod) startSetState() error {
 func (p *Pod) startVM(netNsPath string) error {
 	vmStartedCh := make(chan struct{})
 	vmStoppedCh := make(chan struct{})
+	const timeout = time.Duration(10) * time.Second
+
+	virtLog.Info("Starting VM")
 
 	go func() {
 		p.network.run(netNsPath, func() error {
@@ -719,8 +727,8 @@ func (p *Pod) startVM(netNsPath string) error {
 	select {
 	case <-vmStartedCh:
 		break
-	case <-time.After(time.Second):
-		return fmt.Errorf("Did not receive the pod started notification")
+	case <-time.After(timeout):
+		return fmt.Errorf("Did not receive the pod started notification (timeout %ds)", timeout)
 	}
 
 	virtLog.Infof("VM started")
@@ -885,6 +893,8 @@ func (p *Pod) resumeSetStates() error {
 
 // stopVM stops the agent inside the VM and shut down the VM itself.
 func (p *Pod) stopVM() error {
+	virtLog.Info("Stopping VM")
+
 	if _, _, err := p.proxy.connect(*p, false); err != nil {
 		return err
 	}
@@ -1152,6 +1162,26 @@ func togglePausePod(podID string, pause bool) (*Pod, error) {
 	return p, nil
 }
 
+func (p *Pod) attachDevices() error {
+	for _, container := range p.containers {
+		if err := container.attachDevices(); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (p *Pod) detachDevices() error {
+	for _, container := range p.containers {
+		if err := container.detachDevices(); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
 // addDrives can be used to pass block storage devices to the hypervisor in case of devicemapper storage.
 // The container then uses the block device as its rootfs instead of overlay.
 // The container fstype is assigned the file system type of the block device to indicate this.
diff --git a/vendor/github.com/containers/virtcontainers/pod_test.go b/vendor/github.com/containers/virtcontainers/pod_test.go
index 60866ad5..33d64290 100644
--- a/vendor/github.com/containers/virtcontainers/pod_test.go
+++ b/vendor/github.com/containers/virtcontainers/pod_test.go
@@ -1235,3 +1235,61 @@ func TestContainerStateSetFstype(t *testing.T) {
 		t.Fatal()
 	}
 }
+
+func TestPodAttachDevicesVFIO(t *testing.T) {
+	tmpDir, err := ioutil.TempDir("", "")
+	assert.Nil(t, err)
+	os.RemoveAll(tmpDir)
+
+	testFDIOGroup := "2"
+	testDeviceBDFPath := "0000:00:1c.0"
+
+	devicesDir := filepath.Join(tmpDir, testFDIOGroup, "devices")
+	err = os.MkdirAll(devicesDir, dirMode)
+	assert.Nil(t, err)
+
+	deviceFile := filepath.Join(devicesDir, testDeviceBDFPath)
+	_, err = os.Create(deviceFile)
+	assert.Nil(t, err)
+
+	savedIOMMUPath := sysIOMMUPath
+	sysIOMMUPath = tmpDir
+
+	defer func() {
+		sysIOMMUPath = savedIOMMUPath
+	}()
+
+	path := filepath.Join(vfioPath, testFDIOGroup)
+	deviceInfo := DeviceInfo{
+		HostPath:      path,
+		ContainerPath: path,
+		DevType:       "c",
+	}
+	vfioDevice := newVFIODevice(deviceInfo)
+
+	containers := []ContainerConfig{
+		{
+			ID: "100",
+			Devices: []Device{
+				vfioDevice,
+			},
+		},
+	}
+
+	hConfig := newHypervisorConfig(nil, nil)
+	pod, err := testCreatePod(t, testPodID, MockHypervisor, hConfig, NoopAgentType, NoopNetworkModel, NetworkConfig{}, containers, nil)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	c := pod.GetContainer("100")
+	if c == nil {
+		t.Fatal()
+	}
+
+	err = pod.attachDevices()
+	assert.Nil(t, err, "Error while attaching devices %s", err)
+
+	err = pod.detachDevices()
+	assert.Nil(t, err, "Error while detaching devices %s", err)
+}
diff --git a/vendor/github.com/containers/virtcontainers/qemu.go b/vendor/github.com/containers/virtcontainers/qemu.go
index 52ab6663..5ea603dd 100644
--- a/vendor/github.com/containers/virtcontainers/qemu.go
+++ b/vendor/github.com/containers/virtcontainers/qemu.go
@@ -258,6 +258,20 @@ func (q *qemu) appendBlockDevice(devices []ciaoQemu.Device, drive Drive) []ciaoQ
 	return devices
 }
 
+func (q *qemu) appendVFIODevice(devices []ciaoQemu.Device, vfDevice VFIODevice) []ciaoQemu.Device {
+	if vfDevice.BDF == "" {
+		return devices
+	}
+
+	devices = append(devices,
+		ciaoQemu.VFIODevice{
+			BDF: vfDevice.BDF,
+		},
+	)
+
+	return devices
+}
+
 func (q *qemu) appendSocket(devices []ciaoQemu.Device, socket Socket) []ciaoQemu.Device {
 	devID := socket.ID
 	if len(devID) > maxDevIDSize {
@@ -457,7 +471,13 @@ func (q *qemu) init(config HypervisorConfig) error {
 	}
 
 	virtLog.Debugf("Running inside a VM = %v", nested)
-	q.nestedRun = nested
+
+	if config.DisableNestingChecks {
+		//Intentionally ignore the nesting check
+		q.nestedRun = false
+	} else {
+		q.nestedRun = nested
+	}
 
 	return nil
 }
@@ -560,6 +580,7 @@ func (q *qemu) createPod(podConfig PodConfig) error {
 		NoGraphic:    true,
 		Daemonize:    true,
 		MemPrealloc:  q.config.MemPrealloc,
+		HugePages:    q.config.HugePages,
 		Realtime:     q.config.Realtime,
 		Mlock:        q.config.Mlock,
 	}
@@ -653,7 +674,9 @@ func (q *qemu) startPod(startCh, stopCh chan struct{}) error {
 func (q *qemu) stopPod() error {
 	cfg := ciaoQemu.QMPConfig{Logger: qmpLogger{}}
 	q.qmpControlCh.disconnectCh = make(chan struct{})
+	const timeout = time.Duration(10) * time.Second
 
+	virtLog.Info("Stopping Pod")
 	qmp, _, err := ciaoQemu.QMPStart(q.qmpControlCh.ctx, q.qmpControlCh.path, cfg, q.qmpControlCh.disconnectCh)
 	if err != nil {
 		virtLog.Errorf("Failed to connect to QEMU instance %v", err)
@@ -674,8 +697,8 @@ func (q *qemu) stopPod() error {
 	select {
 	case <-q.qmpControlCh.disconnectCh:
 		break
-	case <-time.After(time.Second):
-		return fmt.Errorf("Did not receive the VM disconnection notification")
+	case <-time.After(timeout):
+		return fmt.Errorf("Did not receive the VM disconnection notification (timeout %ds)", timeout)
 	}
 
 	return nil
@@ -820,6 +843,9 @@ func (q *qemu) addDevice(devInfo interface{}, devType deviceType) error {
 	case blockDev:
 		drive := devInfo.(Drive)
 		q.qemuConfig.Devices = q.appendBlockDevice(q.qemuConfig.Devices, drive)
+	case vfioDev:
+		vfDevice := devInfo.(VFIODevice)
+		q.qemuConfig.Devices = q.appendVFIODevice(q.qemuConfig.Devices, vfDevice)
 	default:
 		break
 	}
diff --git a/vendor/github.com/containers/virtcontainers/qemu_test.go b/vendor/github.com/containers/virtcontainers/qemu_test.go
index bd4687ce..f18b55a2 100644
--- a/vendor/github.com/containers/virtcontainers/qemu_test.go
+++ b/vendor/github.com/containers/virtcontainers/qemu_test.go
@@ -118,6 +118,8 @@ func testQemuAppend(t *testing.T, structure interface{}, expected []ciaoQemu.Dev
 		}
 	case Drive:
 		devices = q.appendBlockDevice(devices, s)
+	case VFIODevice:
+		devices = q.appendVFIODevice(devices, s)
 	}
 
 	if reflect.DeepEqual(devices, expected) == false {
@@ -205,6 +207,23 @@ func TestQemuAppendBlockDevice(t *testing.T) {
 	testQemuAppend(t, drive, expectedOut, -1, nestedVM)
 }
 
+func TestQemuAppendVFIODevice(t *testing.T) {
+	nestedVM := true
+	bdf := "02:10.1"
+
+	expectedOut := []ciaoQemu.Device{
+		ciaoQemu.VFIODevice{
+			BDF: bdf,
+		},
+	}
+
+	vfDevice := VFIODevice{
+		BDF: bdf,
+	}
+
+	testQemuAppend(t, vfDevice, expectedOut, -1, nestedVM)
+}
+
 func TestQemuAppendFSDevices(t *testing.T) {
 	podID := "testPodID"
 	contID := "testContID"
diff --git a/vendor/github.com/containers/virtcontainers/virtcontainers_test.go b/vendor/github.com/containers/virtcontainers/virtcontainers_test.go
index 83e52246..e4871739 100644
--- a/vendor/github.com/containers/virtcontainers/virtcontainers_test.go
+++ b/vendor/github.com/containers/virtcontainers/virtcontainers_test.go
@@ -24,7 +24,7 @@ import (
 	"path/filepath"
 	"testing"
 
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 )
 
 const testPodID = "7f49d00d-1995-4156-8c79-5f5ab24ce138"
diff --git a/vendor/github.com/go-ini/ini/.gitignore b/vendor/github.com/go-ini/ini/.gitignore
new file mode 100644
index 00000000..c5203bf6
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/.gitignore
@@ -0,0 +1,5 @@
+testdata/conf_out.ini
+ini.sublime-project
+ini.sublime-workspace
+testdata/conf_reflect.ini
+.idea
diff --git a/vendor/github.com/go-ini/ini/.travis.yml b/vendor/github.com/go-ini/ini/.travis.yml
new file mode 100644
index 00000000..d9d1b8ff
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/.travis.yml
@@ -0,0 +1,13 @@
+sudo: false
+language: go
+go:
+  - 1.5.x
+  - 1.6.x
+  - 1.7.x
+  - 1.8.x
+  - master
+
+script: 
+  - go get golang.org/x/tools/cmd/cover
+  - go get github.com/smartystreets/goconvey
+  - go test -v -cover -race
diff --git a/vendor/github.com/go-ini/ini/LICENSE b/vendor/github.com/go-ini/ini/LICENSE
new file mode 100644
index 00000000..37ec93a1
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/LICENSE
@@ -0,0 +1,191 @@
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and
+distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright
+owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities
+that control, are controlled by, or are under common control with that entity.
+For the purposes of this definition, "control" means (i) the power, direct or
+indirect, to cause the direction or management of such entity, whether by
+contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
+outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising
+permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including
+but not limited to software source code, documentation source, and configuration
+files.
+
+"Object" form shall mean any form resulting from mechanical transformation or
+translation of a Source form, including but not limited to compiled object code,
+generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made
+available under the License, as indicated by a copyright notice that is included
+in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that
+is based on (or derived from) the Work and for which the editorial revisions,
+annotations, elaborations, or other modifications represent, as a whole, an
+original work of authorship. For the purposes of this License, Derivative Works
+shall not include works that remain separable from, or merely link (or bind by
+name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version
+of the Work and any modifications or additions to that Work or Derivative Works
+thereof, that is intentionally submitted to Licensor for inclusion in the Work
+by the copyright owner or by an individual or Legal Entity authorized to submit
+on behalf of the copyright owner. For the purposes of this definition,
+"submitted" means any form of electronic, verbal, or written communication sent
+to the Licensor or its representatives, including but not limited to
+communication on electronic mailing lists, source code control systems, and
+issue tracking systems that are managed by, or on behalf of, the Licensor for
+the purpose of discussing and improving the Work, but excluding communication
+that is conspicuously marked or otherwise designated in writing by the copyright
+owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf
+of whom a Contribution has been received by Licensor and subsequently
+incorporated within the Work.
+
+2. Grant of Copyright License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable copyright license to reproduce, prepare Derivative Works of,
+publicly display, publicly perform, sublicense, and distribute the Work and such
+Derivative Works in Source or Object form.
+
+3. Grant of Patent License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable (except as stated in this section) patent license to make, have
+made, use, offer to sell, sell, import, and otherwise transfer the Work, where
+such license applies only to those patent claims licensable by such Contributor
+that are necessarily infringed by their Contribution(s) alone or by combination
+of their Contribution(s) with the Work to which such Contribution(s) was
+submitted. If You institute patent litigation against any entity (including a
+cross-claim or counterclaim in a lawsuit) alleging that the Work or a
+Contribution incorporated within the Work constitutes direct or contributory
+patent infringement, then any patent licenses granted to You under this License
+for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution.
+
+You may reproduce and distribute copies of the Work or Derivative Works thereof
+in any medium, with or without modifications, and in Source or Object form,
+provided that You meet the following conditions:
+
+You must give any other recipients of the Work or Derivative Works a copy of
+this License; and
+You must cause any modified files to carry prominent notices stating that You
+changed the files; and
+You must retain, in the Source form of any Derivative Works that You distribute,
+all copyright, patent, trademark, and attribution notices from the Source form
+of the Work, excluding those notices that do not pertain to any part of the
+Derivative Works; and
+If the Work includes a "NOTICE" text file as part of its distribution, then any
+Derivative Works that You distribute must include a readable copy of the
+attribution notices contained within such NOTICE file, excluding those notices
+that do not pertain to any part of the Derivative Works, in at least one of the
+following places: within a NOTICE text file distributed as part of the
+Derivative Works; within the Source form or documentation, if provided along
+with the Derivative Works; or, within a display generated by the Derivative
+Works, if and wherever such third-party notices normally appear. The contents of
+the NOTICE file are for informational purposes only and do not modify the
+License. You may add Your own attribution notices within Derivative Works that
+You distribute, alongside or as an addendum to the NOTICE text from the Work,
+provided that such additional attribution notices cannot be construed as
+modifying the License.
+You may add Your own copyright statement to Your modifications and may provide
+additional or different license terms and conditions for use, reproduction, or
+distribution of Your modifications, or for any such Derivative Works as a whole,
+provided Your use, reproduction, and distribution of the Work otherwise complies
+with the conditions stated in this License.
+
+5. Submission of Contributions.
+
+Unless You explicitly state otherwise, any Contribution intentionally submitted
+for inclusion in the Work by You to the Licensor shall be under the terms and
+conditions of this License, without any additional terms or conditions.
+Notwithstanding the above, nothing herein shall supersede or modify the terms of
+any separate license agreement you may have executed with Licensor regarding
+such Contributions.
+
+6. Trademarks.
+
+This License does not grant permission to use the trade names, trademarks,
+service marks, or product names of the Licensor, except as required for
+reasonable and customary use in describing the origin of the Work and
+reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty.
+
+Unless required by applicable law or agreed to in writing, Licensor provides the
+Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
+including, without limitation, any warranties or conditions of TITLE,
+NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
+solely responsible for determining the appropriateness of using or
+redistributing the Work and assume any risks associated with Your exercise of
+permissions under this License.
+
+8. Limitation of Liability.
+
+In no event and under no legal theory, whether in tort (including negligence),
+contract, or otherwise, unless required by applicable law (such as deliberate
+and grossly negligent acts) or agreed to in writing, shall any Contributor be
+liable to You for damages, including any direct, indirect, special, incidental,
+or consequential damages of any character arising as a result of this License or
+out of the use or inability to use the Work (including but not limited to
+damages for loss of goodwill, work stoppage, computer failure or malfunction, or
+any and all other commercial damages or losses), even if such Contributor has
+been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability.
+
+While redistributing the Work or Derivative Works thereof, You may choose to
+offer, and charge a fee for, acceptance of support, warranty, indemnity, or
+other liability obligations and/or rights consistent with this License. However,
+in accepting such obligations, You may act only on Your own behalf and on Your
+sole responsibility, not on behalf of any other Contributor, and only if You
+agree to indemnify, defend, and hold each Contributor harmless for any liability
+incurred by, or claims asserted against, such Contributor by reason of your
+accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work
+
+To apply the Apache License to your work, attach the following boilerplate
+notice, with the fields enclosed by brackets "[]" replaced with your own
+identifying information. (Don't include the brackets!) The text should be
+enclosed in the appropriate comment syntax for the file format. We also
+recommend that a file or class name and description of purpose be included on
+the same "printed page" as the copyright notice for easier identification within
+third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/vendor/github.com/go-ini/ini/Makefile b/vendor/github.com/go-ini/ini/Makefile
new file mode 100644
index 00000000..ac034e52
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/Makefile
@@ -0,0 +1,12 @@
+.PHONY: build test bench vet
+
+build: vet bench
+
+test:
+	go test -v -cover -race
+
+bench:
+	go test -v -cover -race -test.bench=. -test.benchmem
+
+vet:
+	go vet
diff --git a/vendor/github.com/go-ini/ini/README.md b/vendor/github.com/go-ini/ini/README.md
new file mode 100644
index 00000000..e67d51f3
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/README.md
@@ -0,0 +1,746 @@
+INI [![Build Status](https://travis-ci.org/go-ini/ini.svg?branch=master)](https://travis-ci.org/go-ini/ini) [![Sourcegraph](https://sourcegraph.com/github.com/go-ini/ini/-/badge.svg)](https://sourcegraph.com/github.com/go-ini/ini?badge)
+===
+
+![](https://avatars0.githubusercontent.com/u/10216035?v=3&s=200)
+
+Package ini provides INI file read and write functionality in Go.
+
+[简体中文](README_ZH.md)
+
+## Feature
+
+- Load multiple data sources(`[]byte`, file and `io.ReadCloser`) with overwrites.
+- Read with recursion values.
+- Read with parent-child sections.
+- Read with auto-increment key names.
+- Read with multiple-line values.
+- Read with tons of helper methods.
+- Read and convert values to Go types.
+- Read and **WRITE** comments of sections and keys.
+- Manipulate sections, keys and comments with ease.
+- Keep sections and keys in order as you parse and save.
+
+## Installation
+
+To use a tagged revision:
+
+	go get gopkg.in/ini.v1
+
+To use with latest changes:
+
+	go get github.com/go-ini/ini
+
+Please add `-u` flag to update in the future.
+
+### Testing
+
+If you want to test on your machine, please apply `-t` flag:
+
+	go get -t gopkg.in/ini.v1
+
+Please add `-u` flag to update in the future.
+
+## Getting Started
+
+### Loading from data sources
+
+A **Data Source** is either raw data in type `[]byte`, a file name with type `string` or `io.ReadCloser`. You can load **as many data sources as you want**. Passing other types will simply return an error.
+
+```go
+cfg, err := ini.Load([]byte("raw data"), "filename", ioutil.NopCloser(bytes.NewReader([]byte("some other data"))))
+```
+
+Or start with an empty object:
+
+```go
+cfg := ini.Empty()
+```
+
+When you cannot decide how many data sources to load at the beginning, you will still be able to **Append()** them later.
+
+```go
+err := cfg.Append("other file", []byte("other raw data"))
+```
+
+If you have a list of files with possibilities that some of them may not available at the time, and you don't know exactly which ones, you can use `LooseLoad` to ignore nonexistent files without returning error.
+
+```go
+cfg, err := ini.LooseLoad("filename", "filename_404")
+```
+
+The cool thing is, whenever the file is available to load while you're calling `Reload` method, it will be counted as usual.
+
+#### Ignore cases of key name
+
+When you do not care about cases of section and key names, you can use `InsensitiveLoad` to force all names to be lowercased while parsing.
+
+```go
+cfg, err := ini.InsensitiveLoad("filename")
+//...
+
+// sec1 and sec2 are the exactly same section object
+sec1, err := cfg.GetSection("Section")
+sec2, err := cfg.GetSection("SecTIOn")
+
+// key1 and key2 are the exactly same key object
+key1, err := sec1.GetKey("Key")
+key2, err := sec2.GetKey("KeY")
+```
+
+#### MySQL-like boolean key 
+
+MySQL's configuration allows a key without value as follows:
+
+```ini
+[mysqld]
+...
+skip-host-cache
+skip-name-resolve
+```
+
+By default, this is considered as missing value. But if you know you're going to deal with those cases, you can assign advanced load options:
+
+```go
+cfg, err := LoadSources(LoadOptions{AllowBooleanKeys: true}, "my.cnf"))
+```
+
+The value of those keys are always `true`, and when you save to a file, it will keep in the same foramt as you read.
+
+To generate such keys in your program, you could use `NewBooleanKey`:
+
+```go
+key, err := sec.NewBooleanKey("skip-host-cache")
+```
+
+#### Comment
+
+Take care that following format will be treated as comment:
+
+1. Line begins with `#` or `;`
+2. Words after `#` or `;`
+3. Words after section name (i.e words after `[some section name]`)
+
+If you want to save a value with `#` or `;`, please quote them with ``` ` ``` or ``` """ ```.
+
+Alternatively, you can use following `LoadOptions` to completely ignore inline comments:
+
+```go
+cfg, err := LoadSources(LoadOptions{IgnoreInlineComment: true}, "app.ini"))
+```
+
+### Working with sections
+
+To get a section, you would need to:
+
+```go
+section, err := cfg.GetSection("section name")
+```
+
+For a shortcut for default section, just give an empty string as name:
+
+```go
+section, err := cfg.GetSection("")
+```
+
+When you're pretty sure the section exists, following code could make your life easier:
+
+```go
+section := cfg.Section("section name")
+```
+
+What happens when the section somehow does not exist? Don't panic, it automatically creates and returns a new section to you.
+
+To create a new section:
+
+```go
+err := cfg.NewSection("new section")
+```
+
+To get a list of sections or section names:
+
+```go
+sections := cfg.Sections()
+names := cfg.SectionStrings()
+```
+
+### Working with keys
+
+To get a key under a section:
+
+```go
+key, err := cfg.Section("").GetKey("key name")
+```
+
+Same rule applies to key operations:
+
+```go
+key := cfg.Section("").Key("key name")
+```
+
+To check if a key exists:
+
+```go
+yes := cfg.Section("").HasKey("key name")
+```
+
+To create a new key:
+
+```go
+err := cfg.Section("").NewKey("name", "value")
+```
+
+To get a list of keys or key names:
+
+```go
+keys := cfg.Section("").Keys()
+names := cfg.Section("").KeyStrings()
+```
+
+To get a clone hash of keys and corresponding values:
+
+```go
+hash := cfg.Section("").KeysHash()
+```
+
+### Working with values
+
+To get a string value:
+
+```go
+val := cfg.Section("").Key("key name").String()
+```
+
+To validate key value on the fly:
+
+```go
+val := cfg.Section("").Key("key name").Validate(func(in string) string {
+	if len(in) == 0 {
+		return "default"
+	}
+	return in
+})
+```
+
+If you do not want any auto-transformation (such as recursive read) for the values, you can get raw value directly (this way you get much better performance):
+
+```go
+val := cfg.Section("").Key("key name").Value()
+```
+
+To check if raw value exists:
+
+```go
+yes := cfg.Section("").HasValue("test value")
+```
+
+To get value with types:
+
+```go
+// For boolean values:
+// true when value is: 1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On
+// false when value is: 0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off
+v, err = cfg.Section("").Key("BOOL").Bool()
+v, err = cfg.Section("").Key("FLOAT64").Float64()
+v, err = cfg.Section("").Key("INT").Int()
+v, err = cfg.Section("").Key("INT64").Int64()
+v, err = cfg.Section("").Key("UINT").Uint()
+v, err = cfg.Section("").Key("UINT64").Uint64()
+v, err = cfg.Section("").Key("TIME").TimeFormat(time.RFC3339)
+v, err = cfg.Section("").Key("TIME").Time() // RFC3339
+
+v = cfg.Section("").Key("BOOL").MustBool()
+v = cfg.Section("").Key("FLOAT64").MustFloat64()
+v = cfg.Section("").Key("INT").MustInt()
+v = cfg.Section("").Key("INT64").MustInt64()
+v = cfg.Section("").Key("UINT").MustUint()
+v = cfg.Section("").Key("UINT64").MustUint64()
+v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339)
+v = cfg.Section("").Key("TIME").MustTime() // RFC3339
+
+// Methods start with Must also accept one argument for default value
+// when key not found or fail to parse value to given type.
+// Except method MustString, which you have to pass a default value.
+
+v = cfg.Section("").Key("String").MustString("default")
+v = cfg.Section("").Key("BOOL").MustBool(true)
+v = cfg.Section("").Key("FLOAT64").MustFloat64(1.25)
+v = cfg.Section("").Key("INT").MustInt(10)
+v = cfg.Section("").Key("INT64").MustInt64(99)
+v = cfg.Section("").Key("UINT").MustUint(3)
+v = cfg.Section("").Key("UINT64").MustUint64(6)
+v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339, time.Now())
+v = cfg.Section("").Key("TIME").MustTime(time.Now()) // RFC3339
+```
+
+What if my value is three-line long?
+
+```ini
+[advance]
+ADDRESS = """404 road,
+NotFound, State, 5000
+Earth"""
+```
+
+Not a problem!
+
+```go
+cfg.Section("advance").Key("ADDRESS").String()
+
+/* --- start ---
+404 road,
+NotFound, State, 5000
+Earth
+------  end  --- */
+```
+
+That's cool, how about continuation lines?
+
+```ini
+[advance]
+two_lines = how about \
+	continuation lines?
+lots_of_lines = 1 \
+	2 \
+	3 \
+	4
+```
+
+Piece of cake!
+
+```go
+cfg.Section("advance").Key("two_lines").String() // how about continuation lines?
+cfg.Section("advance").Key("lots_of_lines").String() // 1 2 3 4
+```
+
+Well, I hate continuation lines, how do I disable that?
+
+```go
+cfg, err := ini.LoadSources(ini.LoadOptions{
+	IgnoreContinuation: true,
+}, "filename")
+```
+
+Holy crap! 
+
+Note that single quotes around values will be stripped:
+
+```ini
+foo = "some value" // foo: some value
+bar = 'some value' // bar: some value
+```
+
+That's all? Hmm, no.
+
+#### Helper methods of working with values
+
+To get value with given candidates:
+
+```go
+v = cfg.Section("").Key("STRING").In("default", []string{"str", "arr", "types"})
+v = cfg.Section("").Key("FLOAT64").InFloat64(1.1, []float64{1.25, 2.5, 3.75})
+v = cfg.Section("").Key("INT").InInt(5, []int{10, 20, 30})
+v = cfg.Section("").Key("INT64").InInt64(10, []int64{10, 20, 30})
+v = cfg.Section("").Key("UINT").InUint(4, []int{3, 6, 9})
+v = cfg.Section("").Key("UINT64").InUint64(8, []int64{3, 6, 9})
+v = cfg.Section("").Key("TIME").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})
+v = cfg.Section("").Key("TIME").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339
+```
+
+Default value will be presented if value of key is not in candidates you given, and default value does not need be one of candidates.
+
+To validate value in a given range:
+
+```go
+vals = cfg.Section("").Key("FLOAT64").RangeFloat64(0.0, 1.1, 2.2)
+vals = cfg.Section("").Key("INT").RangeInt(0, 10, 20)
+vals = cfg.Section("").Key("INT64").RangeInt64(0, 10, 20)
+vals = cfg.Section("").Key("UINT").RangeUint(0, 3, 9)
+vals = cfg.Section("").Key("UINT64").RangeUint64(0, 3, 9)
+vals = cfg.Section("").Key("TIME").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)
+vals = cfg.Section("").Key("TIME").RangeTime(time.Now(), minTime, maxTime) // RFC3339
+```
+
+##### Auto-split values into a slice
+
+To use zero value of type for invalid inputs:
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> [0.0 2.2 0.0 0.0]
+vals = cfg.Section("").Key("STRINGS").Strings(",")
+vals = cfg.Section("").Key("FLOAT64S").Float64s(",")
+vals = cfg.Section("").Key("INTS").Ints(",")
+vals = cfg.Section("").Key("INT64S").Int64s(",")
+vals = cfg.Section("").Key("UINTS").Uints(",")
+vals = cfg.Section("").Key("UINT64S").Uint64s(",")
+vals = cfg.Section("").Key("TIMES").Times(",")
+```
+
+To exclude invalid values out of result slice:
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> [2.2]
+vals = cfg.Section("").Key("FLOAT64S").ValidFloat64s(",")
+vals = cfg.Section("").Key("INTS").ValidInts(",")
+vals = cfg.Section("").Key("INT64S").ValidInt64s(",")
+vals = cfg.Section("").Key("UINTS").ValidUints(",")
+vals = cfg.Section("").Key("UINT64S").ValidUint64s(",")
+vals = cfg.Section("").Key("TIMES").ValidTimes(",")
+```
+
+Or to return nothing but error when have invalid inputs:
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> error
+vals = cfg.Section("").Key("FLOAT64S").StrictFloat64s(",")
+vals = cfg.Section("").Key("INTS").StrictInts(",")
+vals = cfg.Section("").Key("INT64S").StrictInt64s(",")
+vals = cfg.Section("").Key("UINTS").StrictUints(",")
+vals = cfg.Section("").Key("UINT64S").StrictUint64s(",")
+vals = cfg.Section("").Key("TIMES").StrictTimes(",")
+```
+
+### Save your configuration
+
+Finally, it's time to save your configuration to somewhere.
+
+A typical way to save configuration is writing it to a file:
+
+```go
+// ...
+err = cfg.SaveTo("my.ini")
+err = cfg.SaveToIndent("my.ini", "\t")
+```
+
+Another way to save is writing to a `io.Writer` interface:
+
+```go
+// ...
+cfg.WriteTo(writer)
+cfg.WriteToIndent(writer, "\t")
+```
+
+By default, spaces are used to align "=" sign between key and values, to disable that:
+
+```go
+ini.PrettyFormat = false
+``` 
+
+## Advanced Usage
+
+### Recursive Values
+
+For all value of keys, there is a special syntax `%(<name>)s`, where `<name>` is the key name in same section or default section, and `%(<name>)s` will be replaced by corresponding value(empty string if key not found). You can use this syntax at most 99 level of recursions.
+
+```ini
+NAME = ini
+
+[author]
+NAME = Unknwon
+GITHUB = https://github.com/%(NAME)s
+
+[package]
+FULL_NAME = github.com/go-ini/%(NAME)s
+```
+
+```go
+cfg.Section("author").Key("GITHUB").String()		// https://github.com/Unknwon
+cfg.Section("package").Key("FULL_NAME").String()	// github.com/go-ini/ini
+```
+
+### Parent-child Sections
+
+You can use `.` in section name to indicate parent-child relationship between two or more sections. If the key not found in the child section, library will try again on its parent section until there is no parent section.
+
+```ini
+NAME = ini
+VERSION = v1
+IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
+
+[package]
+CLONE_URL = https://%(IMPORT_PATH)s
+
+[package.sub]
+```
+
+```go
+cfg.Section("package.sub").Key("CLONE_URL").String()	// https://gopkg.in/ini.v1
+```
+
+#### Retrieve parent keys available to a child section
+
+```go
+cfg.Section("package.sub").ParentKeys() // ["CLONE_URL"]
+```
+
+### Unparseable Sections
+
+Sometimes, you have sections that do not contain key-value pairs but raw content, to handle such case, you can use `LoadOptions.UnparsableSections`:
+
+```go
+cfg, err := LoadSources(LoadOptions{UnparseableSections: []string{"COMMENTS"}}, `[COMMENTS]
+<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>`))
+
+body := cfg.Section("COMMENTS").Body()
+
+/* --- start ---
+<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>
+------  end  --- */
+```
+
+### Auto-increment Key Names
+
+If key name is `-` in data source, then it would be seen as special syntax for auto-increment key name start from 1, and every section is independent on counter.
+
+```ini
+[features]
+-: Support read/write comments of keys and sections
+-: Support auto-increment of key names
+-: Support load multiple files to overwrite key values
+```
+
+```go
+cfg.Section("features").KeyStrings()	// []{"#1", "#2", "#3"}
+```
+
+### Map To Struct
+
+Want more objective way to play with INI? Cool.
+
+```ini
+Name = Unknwon
+age = 21
+Male = true
+Born = 1993-01-01T20:17:05Z
+
+[Note]
+Content = Hi is a good man!
+Cities = HangZhou, Boston
+```
+
+```go
+type Note struct {
+	Content string
+	Cities  []string
+}
+
+type Person struct {
+	Name string
+	Age  int `ini:"age"`
+	Male bool
+	Born time.Time
+	Note
+	Created time.Time `ini:"-"`
+}
+
+func main() {
+	cfg, err := ini.Load("path/to/ini")
+	// ...
+	p := new(Person)
+	err = cfg.MapTo(p)
+	// ...
+
+	// Things can be simpler.
+	err = ini.MapTo(p, "path/to/ini")
+	// ...
+
+	// Just map a section? Fine.
+	n := new(Note)
+	err = cfg.Section("Note").MapTo(n)
+	// ...
+}
+```
+
+Can I have default value for field? Absolutely.
+
+Assign it before you map to struct. It will keep the value as it is if the key is not presented or got wrong type.
+
+```go
+// ...
+p := &Person{
+	Name: "Joe",
+}
+// ...
+```
+
+It's really cool, but what's the point if you can't give me my file back from struct?
+
+### Reflect From Struct
+
+Why not?
+
+```go
+type Embeded struct {
+	Dates  []time.Time `delim:"|"`
+	Places []string    `ini:"places,omitempty"`
+	None   []int       `ini:",omitempty"`
+}
+
+type Author struct {
+	Name      string `ini:"NAME"`
+	Male      bool
+	Age       int
+	GPA       float64
+	NeverMind string `ini:"-"`
+	*Embeded
+}
+
+func main() {
+	a := &Author{"Unknwon", true, 21, 2.8, "",
+		&Embeded{
+			[]time.Time{time.Now(), time.Now()},
+			[]string{"HangZhou", "Boston"},
+			[]int{},
+		}}
+	cfg := ini.Empty()
+	err = ini.ReflectFrom(cfg, a)
+	// ...
+}
+```
+
+So, what do I get?
+
+```ini
+NAME = Unknwon
+Male = true
+Age = 21
+GPA = 2.8
+
+[Embeded]
+Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00
+places = HangZhou,Boston
+```
+
+#### Name Mapper
+
+To save your time and make your code cleaner, this library supports [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) between struct field and actual section and key name.
+
+There are 2 built-in name mappers:
+
+- `AllCapsUnderscore`: it converts to format `ALL_CAPS_UNDERSCORE` then match section or key.
+- `TitleUnderscore`: it converts to format `title_underscore` then match section or key.
+
+To use them:
+
+```go
+type Info struct {
+	PackageName string
+}
+
+func main() {
+	err = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte("package_name=ini"))
+	// ...
+
+	cfg, err := ini.Load([]byte("PACKAGE_NAME=ini"))
+	// ...
+	info := new(Info)
+	cfg.NameMapper = ini.AllCapsUnderscore
+	err = cfg.MapTo(info)
+	// ...
+}
+```
+
+Same rules of name mapper apply to `ini.ReflectFromWithMapper` function.
+
+#### Value Mapper
+
+To expand values (e.g. from environment variables), you can use the `ValueMapper` to transform values:
+
+```go
+type Env struct {
+	Foo string `ini:"foo"`
+}
+
+func main() {
+	cfg, err := ini.Load([]byte("[env]\nfoo = ${MY_VAR}\n")
+	cfg.ValueMapper = os.ExpandEnv
+	// ...
+	env := &Env{}
+	err = cfg.Section("env").MapTo(env)
+}
+```
+
+This would set the value of `env.Foo` to the value of the environment variable `MY_VAR`.
+
+#### Other Notes On Map/Reflect
+
+Any embedded struct is treated as a section by default, and there is no automatic parent-child relations in map/reflect feature:
+
+```go
+type Child struct {
+	Age string
+}
+
+type Parent struct {
+	Name string
+	Child
+}
+
+type Config struct {
+	City string
+	Parent
+}
+```
+
+Example configuration:
+
+```ini
+City = Boston
+
+[Parent]
+Name = Unknwon
+
+[Child]
+Age = 21
+```
+
+What if, yes, I'm paranoid, I want embedded struct to be in the same section. Well, all roads lead to Rome.
+
+```go
+type Child struct {
+	Age string
+}
+
+type Parent struct {
+	Name string
+	Child `ini:"Parent"`
+}
+
+type Config struct {
+	City string
+	Parent
+}
+```
+
+Example configuration:
+
+```ini
+City = Boston
+
+[Parent]
+Name = Unknwon
+Age = 21
+```
+
+## Getting Help
+
+- [API Documentation](https://gowalker.org/gopkg.in/ini.v1)
+- [File An Issue](https://github.com/go-ini/ini/issues/new)
+
+## FAQs
+
+### What does `BlockMode` field do?
+
+By default, library lets you read and write values so we need a locker to make sure your data is safe. But in cases that you are very sure about only reading data through the library, you can set `cfg.BlockMode = false` to speed up read operations about **50-70%** faster.
+
+### Why another INI library?
+
+Many people are using my another INI library [goconfig](https://github.com/Unknwon/goconfig), so the reason for this one is I would like to make more Go style code. Also when you set `cfg.BlockMode = false`, this one is about **10-30%** faster.
+
+To make those changes I have to confirm API broken, so it's safer to keep it in another place and start using `gopkg.in` to version my package at this time.(PS: shorter import path)
+
+## License
+
+This project is under Apache v2 License. See the [LICENSE](LICENSE) file for the full license text.
diff --git a/vendor/github.com/go-ini/ini/README_ZH.md b/vendor/github.com/go-ini/ini/README_ZH.md
new file mode 100644
index 00000000..0cf41944
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/README_ZH.md
@@ -0,0 +1,733 @@
+本包提供了 Go 语言中读写 INI 文件的功能。
+
+## 功能特性
+
+- 支持覆盖加载多个数据源（`[]byte`、文件和 `io.ReadCloser`）
+- 支持递归读取键值
+- 支持读取父子分区
+- 支持读取自增键名
+- 支持读取多行的键值
+- 支持大量辅助方法
+- 支持在读取时直接转换为 Go 语言类型
+- 支持读取和 **写入** 分区和键的注释
+- 轻松操作分区、键值和注释
+- 在保存文件时分区和键值会保持原有的顺序
+
+## 下载安装
+
+使用一个特定版本：
+
+    go get gopkg.in/ini.v1
+
+使用最新版：
+
+	go get github.com/go-ini/ini
+
+如需更新请添加 `-u` 选项。
+
+### 测试安装
+
+如果您想要在自己的机器上运行测试，请使用 `-t` 标记：
+
+	go get -t gopkg.in/ini.v1
+
+如需更新请添加 `-u` 选项。
+
+## 开始使用
+
+### 从数据源加载
+
+一个 **数据源** 可以是 `[]byte` 类型的原始数据，`string` 类型的文件路径或 `io.ReadCloser`。您可以加载 **任意多个** 数据源。如果您传递其它类型的数据源，则会直接返回错误。
+
+```go
+cfg, err := ini.Load([]byte("raw data"), "filename", ioutil.NopCloser(bytes.NewReader([]byte("some other data"))))
+```
+
+或者从一个空白的文件开始：
+
+```go
+cfg := ini.Empty()
+```
+
+当您在一开始无法决定需要加载哪些数据源时，仍可以使用 **Append()** 在需要的时候加载它们。
+
+```go
+err := cfg.Append("other file", []byte("other raw data"))
+```
+
+当您想要加载一系列文件，但是不能够确定其中哪些文件是不存在的，可以通过调用函数 `LooseLoad` 来忽略它们（`Load` 会因为文件不存在而返回错误）：
+
+```go
+cfg, err := ini.LooseLoad("filename", "filename_404")
+```
+
+更牛逼的是，当那些之前不存在的文件在重新调用 `Reload` 方法的时候突然出现了，那么它们会被正常加载。
+
+#### 忽略键名的大小写
+
+有时候分区和键的名称大小写混合非常烦人，这个时候就可以通过 `InsensitiveLoad` 将所有分区和键名在读取里强制转换为小写：
+
+```go
+cfg, err := ini.InsensitiveLoad("filename")
+//...
+
+// sec1 和 sec2 指向同一个分区对象
+sec1, err := cfg.GetSection("Section")
+sec2, err := cfg.GetSection("SecTIOn")
+
+// key1 和 key2 指向同一个键对象
+key1, err := sec1.GetKey("Key")
+key2, err := sec2.GetKey("KeY")
+```
+
+#### 类似 MySQL 配置中的布尔值键
+
+MySQL 的配置文件中会出现没有具体值的布尔类型的键：
+
+```ini
+[mysqld]
+...
+skip-host-cache
+skip-name-resolve
+```
+
+默认情况下这被认为是缺失值而无法完成解析，但可以通过高级的加载选项对它们进行处理：
+
+```go
+cfg, err := LoadSources(LoadOptions{AllowBooleanKeys: true}, "my.cnf"))
+```
+
+这些键的值永远为 `true`，且在保存到文件时也只会输出键名。
+
+如果您想要通过程序来生成此类键，则可以使用 `NewBooleanKey`：
+
+```go
+key, err := sec.NewBooleanKey("skip-host-cache")
+```
+
+#### 关于注释
+
+下述几种情况的内容将被视为注释：
+
+1. 所有以 `#` 或 `;` 开头的行
+2. 所有在 `#` 或 `;` 之后的内容
+3. 分区标签后的文字 (即 `[分区名]` 之后的内容)
+
+如果你希望使用包含 `#` 或 `;` 的值，请使用 ``` ` ``` 或 ``` """ ``` 进行包覆。
+
+除此之外，您还可以通过 `LoadOptions` 完全忽略行内注释：
+
+```go
+cfg, err := LoadSources(LoadOptions{IgnoreInlineComment: true}, "app.ini"))
+```
+
+### 操作分区（Section）
+
+获取指定分区：
+
+```go
+section, err := cfg.GetSection("section name")
+```
+
+如果您想要获取默认分区，则可以用空字符串代替分区名：
+
+```go
+section, err := cfg.GetSection("")
+```
+
+当您非常确定某个分区是存在的，可以使用以下简便方法：
+
+```go
+section := cfg.Section("section name")
+```
+
+如果不小心判断错了，要获取的分区其实是不存在的，那会发生什么呢？没事的，它会自动创建并返回一个对应的分区对象给您。
+
+创建一个分区：
+
+```go
+err := cfg.NewSection("new section")
+```
+
+获取所有分区对象或名称：
+
+```go
+sections := cfg.Sections()
+names := cfg.SectionStrings()
+```
+
+### 操作键（Key）
+
+获取某个分区下的键：
+
+```go
+key, err := cfg.Section("").GetKey("key name")
+```
+
+和分区一样，您也可以直接获取键而忽略错误处理：
+
+```go
+key := cfg.Section("").Key("key name")
+```
+
+判断某个键是否存在：
+
+```go
+yes := cfg.Section("").HasKey("key name")
+```
+
+创建一个新的键：
+
+```go
+err := cfg.Section("").NewKey("name", "value")
+```
+
+获取分区下的所有键或键名：
+
+```go
+keys := cfg.Section("").Keys()
+names := cfg.Section("").KeyStrings()
+```
+
+获取分区下的所有键值对的克隆：
+
+```go
+hash := cfg.Section("").KeysHash()
+```
+
+### 操作键值（Value）
+
+获取一个类型为字符串（string）的值：
+
+```go
+val := cfg.Section("").Key("key name").String()
+```
+
+获取值的同时通过自定义函数进行处理验证：
+
+```go
+val := cfg.Section("").Key("key name").Validate(func(in string) string {
+	if len(in) == 0 {
+		return "default"
+	}
+	return in
+})
+```
+
+如果您不需要任何对值的自动转变功能（例如递归读取），可以直接获取原值（这种方式性能最佳）：
+
+```go
+val := cfg.Section("").Key("key name").Value()
+```
+
+判断某个原值是否存在：
+
+```go
+yes := cfg.Section("").HasValue("test value")
+```
+
+获取其它类型的值：
+
+```go
+// 布尔值的规则：
+// true 当值为：1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On
+// false 当值为：0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off
+v, err = cfg.Section("").Key("BOOL").Bool()
+v, err = cfg.Section("").Key("FLOAT64").Float64()
+v, err = cfg.Section("").Key("INT").Int()
+v, err = cfg.Section("").Key("INT64").Int64()
+v, err = cfg.Section("").Key("UINT").Uint()
+v, err = cfg.Section("").Key("UINT64").Uint64()
+v, err = cfg.Section("").Key("TIME").TimeFormat(time.RFC3339)
+v, err = cfg.Section("").Key("TIME").Time() // RFC3339
+
+v = cfg.Section("").Key("BOOL").MustBool()
+v = cfg.Section("").Key("FLOAT64").MustFloat64()
+v = cfg.Section("").Key("INT").MustInt()
+v = cfg.Section("").Key("INT64").MustInt64()
+v = cfg.Section("").Key("UINT").MustUint()
+v = cfg.Section("").Key("UINT64").MustUint64()
+v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339)
+v = cfg.Section("").Key("TIME").MustTime() // RFC3339
+
+// 由 Must 开头的方法名允许接收一个相同类型的参数来作为默认值，
+// 当键不存在或者转换失败时，则会直接返回该默认值。
+// 但是，MustString 方法必须传递一个默认值。
+
+v = cfg.Seciont("").Key("String").MustString("default")
+v = cfg.Section("").Key("BOOL").MustBool(true)
+v = cfg.Section("").Key("FLOAT64").MustFloat64(1.25)
+v = cfg.Section("").Key("INT").MustInt(10)
+v = cfg.Section("").Key("INT64").MustInt64(99)
+v = cfg.Section("").Key("UINT").MustUint(3)
+v = cfg.Section("").Key("UINT64").MustUint64(6)
+v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339, time.Now())
+v = cfg.Section("").Key("TIME").MustTime(time.Now()) // RFC3339
+```
+
+如果我的值有好多行怎么办？
+
+```ini
+[advance]
+ADDRESS = """404 road,
+NotFound, State, 5000
+Earth"""
+```
+
+嗯哼？小 case！
+
+```go
+cfg.Section("advance").Key("ADDRESS").String()
+
+/* --- start ---
+404 road,
+NotFound, State, 5000
+Earth
+------  end  --- */
+```
+
+赞爆了！那要是我属于一行的内容写不下想要写到第二行怎么办？
+
+```ini
+[advance]
+two_lines = how about \
+	continuation lines?
+lots_of_lines = 1 \
+	2 \
+	3 \
+	4
+```
+
+简直是小菜一碟！
+
+```go
+cfg.Section("advance").Key("two_lines").String() // how about continuation lines?
+cfg.Section("advance").Key("lots_of_lines").String() // 1 2 3 4
+```
+
+可是我有时候觉得两行连在一起特别没劲，怎么才能不自动连接两行呢？
+
+```go
+cfg, err := ini.LoadSources(ini.LoadOptions{
+	IgnoreContinuation: true,
+}, "filename")
+```
+
+哇靠给力啊！
+
+需要注意的是，值两侧的单引号会被自动剔除：
+
+```ini
+foo = "some value" // foo: some value
+bar = 'some value' // bar: some value
+```
+
+这就是全部了？哈哈，当然不是。
+
+#### 操作键值的辅助方法
+
+获取键值时设定候选值：
+
+```go
+v = cfg.Section("").Key("STRING").In("default", []string{"str", "arr", "types"})
+v = cfg.Section("").Key("FLOAT64").InFloat64(1.1, []float64{1.25, 2.5, 3.75})
+v = cfg.Section("").Key("INT").InInt(5, []int{10, 20, 30})
+v = cfg.Section("").Key("INT64").InInt64(10, []int64{10, 20, 30})
+v = cfg.Section("").Key("UINT").InUint(4, []int{3, 6, 9})
+v = cfg.Section("").Key("UINT64").InUint64(8, []int64{3, 6, 9})
+v = cfg.Section("").Key("TIME").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})
+v = cfg.Section("").Key("TIME").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339
+```
+
+如果获取到的值不是候选值的任意一个，则会返回默认值，而默认值不需要是候选值中的一员。
+
+验证获取的值是否在指定范围内：
+
+```go
+vals = cfg.Section("").Key("FLOAT64").RangeFloat64(0.0, 1.1, 2.2)
+vals = cfg.Section("").Key("INT").RangeInt(0, 10, 20)
+vals = cfg.Section("").Key("INT64").RangeInt64(0, 10, 20)
+vals = cfg.Section("").Key("UINT").RangeUint(0, 3, 9)
+vals = cfg.Section("").Key("UINT64").RangeUint64(0, 3, 9)
+vals = cfg.Section("").Key("TIME").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)
+vals = cfg.Section("").Key("TIME").RangeTime(time.Now(), minTime, maxTime) // RFC3339
+```
+
+##### 自动分割键值到切片（slice）
+
+当存在无效输入时，使用零值代替：
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> [0.0 2.2 0.0 0.0]
+vals = cfg.Section("").Key("STRINGS").Strings(",")
+vals = cfg.Section("").Key("FLOAT64S").Float64s(",")
+vals = cfg.Section("").Key("INTS").Ints(",")
+vals = cfg.Section("").Key("INT64S").Int64s(",")
+vals = cfg.Section("").Key("UINTS").Uints(",")
+vals = cfg.Section("").Key("UINT64S").Uint64s(",")
+vals = cfg.Section("").Key("TIMES").Times(",")
+```
+
+从结果切片中剔除无效输入：
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> [2.2]
+vals = cfg.Section("").Key("FLOAT64S").ValidFloat64s(",")
+vals = cfg.Section("").Key("INTS").ValidInts(",")
+vals = cfg.Section("").Key("INT64S").ValidInt64s(",")
+vals = cfg.Section("").Key("UINTS").ValidUints(",")
+vals = cfg.Section("").Key("UINT64S").ValidUint64s(",")
+vals = cfg.Section("").Key("TIMES").ValidTimes(",")
+```
+
+当存在无效输入时，直接返回错误：
+
+```go
+// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
+// Input: how, 2.2, are, you -> error
+vals = cfg.Section("").Key("FLOAT64S").StrictFloat64s(",")
+vals = cfg.Section("").Key("INTS").StrictInts(",")
+vals = cfg.Section("").Key("INT64S").StrictInt64s(",")
+vals = cfg.Section("").Key("UINTS").StrictUints(",")
+vals = cfg.Section("").Key("UINT64S").StrictUint64s(",")
+vals = cfg.Section("").Key("TIMES").StrictTimes(",")
+```
+
+### 保存配置
+
+终于到了这个时刻，是时候保存一下配置了。
+
+比较原始的做法是输出配置到某个文件：
+
+```go
+// ...
+err = cfg.SaveTo("my.ini")
+err = cfg.SaveToIndent("my.ini", "\t")
+```
+
+另一个比较高级的做法是写入到任何实现 `io.Writer` 接口的对象中：
+
+```go
+// ...
+cfg.WriteTo(writer)
+cfg.WriteToIndent(writer, "\t")
+```
+
+默认情况下，空格将被用于对齐键值之间的等号以美化输出结果，以下代码可以禁用该功能：
+
+```go
+ini.PrettyFormat = false
+``` 
+
+## 高级用法
+
+### 递归读取键值
+
+在获取所有键值的过程中，特殊语法 `%(<name>)s` 会被应用，其中 `<name>` 可以是相同分区或者默认分区下的键名。字符串 `%(<name>)s` 会被相应的键值所替代，如果指定的键不存在，则会用空字符串替代。您可以最多使用 99 层的递归嵌套。
+
+```ini
+NAME = ini
+
+[author]
+NAME = Unknwon
+GITHUB = https://github.com/%(NAME)s
+
+[package]
+FULL_NAME = github.com/go-ini/%(NAME)s
+```
+
+```go
+cfg.Section("author").Key("GITHUB").String()		// https://github.com/Unknwon
+cfg.Section("package").Key("FULL_NAME").String()	// github.com/go-ini/ini
+```
+
+### 读取父子分区
+
+您可以在分区名称中使用 `.` 来表示两个或多个分区之间的父子关系。如果某个键在子分区中不存在，则会去它的父分区中再次寻找，直到没有父分区为止。
+
+```ini
+NAME = ini
+VERSION = v1
+IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
+
+[package]
+CLONE_URL = https://%(IMPORT_PATH)s
+
+[package.sub]
+```
+
+```go
+cfg.Section("package.sub").Key("CLONE_URL").String()	// https://gopkg.in/ini.v1
+```
+
+#### 获取上级父分区下的所有键名
+
+```go
+cfg.Section("package.sub").ParentKeys() // ["CLONE_URL"]
+```
+
+### 无法解析的分区
+
+如果遇到一些比较特殊的分区，它们不包含常见的键值对，而是没有固定格式的纯文本，则可以使用 `LoadOptions.UnparsableSections` 进行处理：
+
+```go
+cfg, err := LoadSources(LoadOptions{UnparseableSections: []string{"COMMENTS"}}, `[COMMENTS]
+<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>`))
+
+body := cfg.Section("COMMENTS").Body()
+
+/* --- start ---
+<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>
+------  end  --- */
+```
+
+### 读取自增键名
+
+如果数据源中的键名为 `-`，则认为该键使用了自增键名的特殊语法。计数器从 1 开始，并且分区之间是相互独立的。
+
+```ini
+[features]
+-: Support read/write comments of keys and sections
+-: Support auto-increment of key names
+-: Support load multiple files to overwrite key values
+```
+
+```go
+cfg.Section("features").KeyStrings()	// []{"#1", "#2", "#3"}
+```
+
+### 映射到结构
+
+想要使用更加面向对象的方式玩转 INI 吗？好主意。
+
+```ini
+Name = Unknwon
+age = 21
+Male = true
+Born = 1993-01-01T20:17:05Z
+
+[Note]
+Content = Hi is a good man!
+Cities = HangZhou, Boston
+```
+
+```go
+type Note struct {
+	Content string
+	Cities  []string
+}
+
+type Person struct {
+	Name string
+	Age  int `ini:"age"`
+	Male bool
+	Born time.Time
+	Note
+	Created time.Time `ini:"-"`
+}
+
+func main() {
+	cfg, err := ini.Load("path/to/ini")
+	// ...
+	p := new(Person)
+	err = cfg.MapTo(p)
+	// ...
+
+	// 一切竟可以如此的简单。
+	err = ini.MapTo(p, "path/to/ini")
+	// ...
+
+	// 嗯哼？只需要映射一个分区吗？
+	n := new(Note)
+	err = cfg.Section("Note").MapTo(n)
+	// ...
+}
+```
+
+结构的字段怎么设置默认值呢？很简单，只要在映射之前对指定字段进行赋值就可以了。如果键未找到或者类型错误，该值不会发生改变。
+
+```go
+// ...
+p := &Person{
+	Name: "Joe",
+}
+// ...
+```
+
+这样玩 INI 真的好酷啊！然而，如果不能还给我原来的配置文件，有什么卵用？
+
+### 从结构反射
+
+可是，我有说不能吗？
+
+```go
+type Embeded struct {
+	Dates  []time.Time `delim:"|"`
+	Places []string    `ini:"places,omitempty"`
+	None   []int       `ini:",omitempty"`
+}
+
+type Author struct {
+	Name      string `ini:"NAME"`
+	Male      bool
+	Age       int
+	GPA       float64
+	NeverMind string `ini:"-"`
+	*Embeded
+}
+
+func main() {
+	a := &Author{"Unknwon", true, 21, 2.8, "",
+		&Embeded{
+			[]time.Time{time.Now(), time.Now()},
+			[]string{"HangZhou", "Boston"},
+			[]int{},
+		}}
+	cfg := ini.Empty()
+	err = ini.ReflectFrom(cfg, a)
+	// ...
+}
+```
+
+瞧瞧，奇迹发生了。
+
+```ini
+NAME = Unknwon
+Male = true
+Age = 21
+GPA = 2.8
+
+[Embeded]
+Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00
+places = HangZhou,Boston
+```
+
+#### 名称映射器（Name Mapper）
+
+为了节省您的时间并简化代码，本库支持类型为 [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) 的名称映射器，该映射器负责结构字段名与分区名和键名之间的映射。
+
+目前有 2 款内置的映射器：
+
+- `AllCapsUnderscore`：该映射器将字段名转换至格式 `ALL_CAPS_UNDERSCORE` 后再去匹配分区名和键名。
+- `TitleUnderscore`：该映射器将字段名转换至格式 `title_underscore` 后再去匹配分区名和键名。
+
+使用方法：
+
+```go
+type Info struct{
+	PackageName string
+}
+
+func main() {
+	err = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte("package_name=ini"))
+	// ...
+
+	cfg, err := ini.Load([]byte("PACKAGE_NAME=ini"))
+	// ...
+	info := new(Info)
+	cfg.NameMapper = ini.AllCapsUnderscore
+	err = cfg.MapTo(info)
+	// ...
+}
+```
+
+使用函数 `ini.ReflectFromWithMapper` 时也可应用相同的规则。
+
+#### 值映射器（Value Mapper）
+
+值映射器允许使用一个自定义函数自动展开值的具体内容，例如：运行时获取环境变量：
+
+```go
+type Env struct {
+	Foo string `ini:"foo"`
+}
+
+func main() {
+	cfg, err := ini.Load([]byte("[env]\nfoo = ${MY_VAR}\n")
+	cfg.ValueMapper = os.ExpandEnv
+	// ...
+	env := &Env{}
+	err = cfg.Section("env").MapTo(env)
+}
+```
+
+本例中，`env.Foo` 将会是运行时所获取到环境变量 `MY_VAR` 的值。
+
+#### 映射/反射的其它说明
+
+任何嵌入的结构都会被默认认作一个不同的分区，并且不会自动产生所谓的父子分区关联：
+
+```go
+type Child struct {
+	Age string
+}
+
+type Parent struct {
+	Name string
+	Child
+}
+
+type Config struct {
+	City string
+	Parent
+}
+```
+
+示例配置文件：
+
+```ini
+City = Boston
+
+[Parent]
+Name = Unknwon
+
+[Child]
+Age = 21
+```
+
+很好，但是，我就是要嵌入结构也在同一个分区。好吧，你爹是李刚！
+
+```go
+type Child struct {
+	Age string
+}
+
+type Parent struct {
+	Name string
+	Child `ini:"Parent"`
+}
+
+type Config struct {
+	City string
+	Parent
+}
+```
+
+示例配置文件：
+
+```ini
+City = Boston
+
+[Parent]
+Name = Unknwon
+Age = 21
+```
+
+## 获取帮助
+
+- [API 文档](https://gowalker.org/gopkg.in/ini.v1)
+- [创建工单](https://github.com/go-ini/ini/issues/new)
+
+## 常见问题
+
+### 字段 `BlockMode` 是什么？
+
+默认情况下，本库会在您进行读写操作时采用锁机制来确保数据时间。但在某些情况下，您非常确定只进行读操作。此时，您可以通过设置 `cfg.BlockMode = false` 来将读操作提升大约 **50-70%** 的性能。
+
+### 为什么要写另一个 INI 解析库？
+
+许多人都在使用我的 [goconfig](https://github.com/Unknwon/goconfig) 来完成对 INI 文件的操作，但我希望使用更加 Go 风格的代码。并且当您设置 `cfg.BlockMode = false` 时，会有大约 **10-30%** 的性能提升。
+
+为了做出这些改变，我必须对 API 进行破坏，所以新开一个仓库是最安全的做法。除此之外，本库直接使用 `gopkg.in` 来进行版本化发布。（其实真相是导入路径更短了）
diff --git a/vendor/github.com/go-ini/ini/error.go b/vendor/github.com/go-ini/ini/error.go
new file mode 100644
index 00000000..80afe743
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/error.go
@@ -0,0 +1,32 @@
+// Copyright 2016 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"fmt"
+)
+
+type ErrDelimiterNotFound struct {
+	Line string
+}
+
+func IsErrDelimiterNotFound(err error) bool {
+	_, ok := err.(ErrDelimiterNotFound)
+	return ok
+}
+
+func (err ErrDelimiterNotFound) Error() string {
+	return fmt.Sprintf("key-value delimiter not found: %s", err.Line)
+}
diff --git a/vendor/github.com/go-ini/ini/ini.go b/vendor/github.com/go-ini/ini/ini.go
new file mode 100644
index 00000000..7f3c4d1e
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/ini.go
@@ -0,0 +1,556 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+// Package ini provides INI file read and write functionality in Go.
+package ini
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"os"
+	"regexp"
+	"runtime"
+	"strings"
+	"sync"
+)
+
+const (
+	// Name for default section. You can use this constant or the string literal.
+	// In most of cases, an empty string is all you need to access the section.
+	DEFAULT_SECTION = "DEFAULT"
+
+	// Maximum allowed depth when recursively substituing variable names.
+	_DEPTH_VALUES = 99
+	_VERSION      = "1.28.2"
+)
+
+// Version returns current package version literal.
+func Version() string {
+	return _VERSION
+}
+
+var (
+	// Delimiter to determine or compose a new line.
+	// This variable will be changed to "\r\n" automatically on Windows
+	// at package init time.
+	LineBreak = "\n"
+
+	// Variable regexp pattern: %(variable)s
+	varPattern = regexp.MustCompile(`%\(([^\)]+)\)s`)
+
+	// Indicate whether to align "=" sign with spaces to produce pretty output
+	// or reduce all possible spaces for compact format.
+	PrettyFormat = true
+
+	// Explicitly write DEFAULT section header
+	DefaultHeader = false
+
+	// Indicate whether to put a line between sections
+	PrettySection = true
+)
+
+func init() {
+	if runtime.GOOS == "windows" {
+		LineBreak = "\r\n"
+	}
+}
+
+func inSlice(str string, s []string) bool {
+	for _, v := range s {
+		if str == v {
+			return true
+		}
+	}
+	return false
+}
+
+// dataSource is an interface that returns object which can be read and closed.
+type dataSource interface {
+	ReadCloser() (io.ReadCloser, error)
+}
+
+// sourceFile represents an object that contains content on the local file system.
+type sourceFile struct {
+	name string
+}
+
+func (s sourceFile) ReadCloser() (_ io.ReadCloser, err error) {
+	return os.Open(s.name)
+}
+
+type bytesReadCloser struct {
+	reader io.Reader
+}
+
+func (rc *bytesReadCloser) Read(p []byte) (n int, err error) {
+	return rc.reader.Read(p)
+}
+
+func (rc *bytesReadCloser) Close() error {
+	return nil
+}
+
+// sourceData represents an object that contains content in memory.
+type sourceData struct {
+	data []byte
+}
+
+func (s *sourceData) ReadCloser() (io.ReadCloser, error) {
+	return ioutil.NopCloser(bytes.NewReader(s.data)), nil
+}
+
+// sourceReadCloser represents an input stream with Close method.
+type sourceReadCloser struct {
+	reader io.ReadCloser
+}
+
+func (s *sourceReadCloser) ReadCloser() (io.ReadCloser, error) {
+	return s.reader, nil
+}
+
+// File represents a combination of a or more INI file(s) in memory.
+type File struct {
+	// Should make things safe, but sometimes doesn't matter.
+	BlockMode bool
+	// Make sure data is safe in multiple goroutines.
+	lock sync.RWMutex
+
+	// Allow combination of multiple data sources.
+	dataSources []dataSource
+	// Actual data is stored here.
+	sections map[string]*Section
+
+	// To keep data in order.
+	sectionList []string
+
+	options LoadOptions
+
+	NameMapper
+	ValueMapper
+}
+
+// newFile initializes File object with given data sources.
+func newFile(dataSources []dataSource, opts LoadOptions) *File {
+	return &File{
+		BlockMode:   true,
+		dataSources: dataSources,
+		sections:    make(map[string]*Section),
+		sectionList: make([]string, 0, 10),
+		options:     opts,
+	}
+}
+
+func parseDataSource(source interface{}) (dataSource, error) {
+	switch s := source.(type) {
+	case string:
+		return sourceFile{s}, nil
+	case []byte:
+		return &sourceData{s}, nil
+	case io.ReadCloser:
+		return &sourceReadCloser{s}, nil
+	default:
+		return nil, fmt.Errorf("error parsing data source: unknown type '%s'", s)
+	}
+}
+
+type LoadOptions struct {
+	// Loose indicates whether the parser should ignore nonexistent files or return error.
+	Loose bool
+	// Insensitive indicates whether the parser forces all section and key names to lowercase.
+	Insensitive bool
+	// IgnoreContinuation indicates whether to ignore continuation lines while parsing.
+	IgnoreContinuation bool
+	// IgnoreInlineComment indicates whether to ignore comments at the end of value and treat it as part of value.
+	IgnoreInlineComment bool
+	// AllowBooleanKeys indicates whether to allow boolean type keys or treat as value is missing.
+	// This type of keys are mostly used in my.cnf.
+	AllowBooleanKeys bool
+	// AllowShadows indicates whether to keep track of keys with same name under same section.
+	AllowShadows bool
+	// Some INI formats allow group blocks that store a block of raw content that doesn't otherwise
+	// conform to key/value pairs. Specify the names of those blocks here.
+	UnparseableSections []string
+}
+
+func LoadSources(opts LoadOptions, source interface{}, others ...interface{}) (_ *File, err error) {
+	sources := make([]dataSource, len(others)+1)
+	sources[0], err = parseDataSource(source)
+	if err != nil {
+		return nil, err
+	}
+	for i := range others {
+		sources[i+1], err = parseDataSource(others[i])
+		if err != nil {
+			return nil, err
+		}
+	}
+	f := newFile(sources, opts)
+	if err = f.Reload(); err != nil {
+		return nil, err
+	}
+	return f, nil
+}
+
+// Load loads and parses from INI data sources.
+// Arguments can be mixed of file name with string type, or raw data in []byte.
+// It will return error if list contains nonexistent files.
+func Load(source interface{}, others ...interface{}) (*File, error) {
+	return LoadSources(LoadOptions{}, source, others...)
+}
+
+// LooseLoad has exactly same functionality as Load function
+// except it ignores nonexistent files instead of returning error.
+func LooseLoad(source interface{}, others ...interface{}) (*File, error) {
+	return LoadSources(LoadOptions{Loose: true}, source, others...)
+}
+
+// InsensitiveLoad has exactly same functionality as Load function
+// except it forces all section and key names to be lowercased.
+func InsensitiveLoad(source interface{}, others ...interface{}) (*File, error) {
+	return LoadSources(LoadOptions{Insensitive: true}, source, others...)
+}
+
+// InsensitiveLoad has exactly same functionality as Load function
+// except it allows have shadow keys.
+func ShadowLoad(source interface{}, others ...interface{}) (*File, error) {
+	return LoadSources(LoadOptions{AllowShadows: true}, source, others...)
+}
+
+// Empty returns an empty file object.
+func Empty() *File {
+	// Ignore error here, we sure our data is good.
+	f, _ := Load([]byte(""))
+	return f
+}
+
+// NewSection creates a new section.
+func (f *File) NewSection(name string) (*Section, error) {
+	if len(name) == 0 {
+		return nil, errors.New("error creating new section: empty section name")
+	} else if f.options.Insensitive && name != DEFAULT_SECTION {
+		name = strings.ToLower(name)
+	}
+
+	if f.BlockMode {
+		f.lock.Lock()
+		defer f.lock.Unlock()
+	}
+
+	if inSlice(name, f.sectionList) {
+		return f.sections[name], nil
+	}
+
+	f.sectionList = append(f.sectionList, name)
+	f.sections[name] = newSection(f, name)
+	return f.sections[name], nil
+}
+
+// NewRawSection creates a new section with an unparseable body.
+func (f *File) NewRawSection(name, body string) (*Section, error) {
+	section, err := f.NewSection(name)
+	if err != nil {
+		return nil, err
+	}
+
+	section.isRawSection = true
+	section.rawBody = body
+	return section, nil
+}
+
+// NewSections creates a list of sections.
+func (f *File) NewSections(names ...string) (err error) {
+	for _, name := range names {
+		if _, err = f.NewSection(name); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// GetSection returns section by given name.
+func (f *File) GetSection(name string) (*Section, error) {
+	if len(name) == 0 {
+		name = DEFAULT_SECTION
+	} else if f.options.Insensitive {
+		name = strings.ToLower(name)
+	}
+
+	if f.BlockMode {
+		f.lock.RLock()
+		defer f.lock.RUnlock()
+	}
+
+	sec := f.sections[name]
+	if sec == nil {
+		return nil, fmt.Errorf("section '%s' does not exist", name)
+	}
+	return sec, nil
+}
+
+// Section assumes named section exists and returns a zero-value when not.
+func (f *File) Section(name string) *Section {
+	sec, err := f.GetSection(name)
+	if err != nil {
+		// Note: It's OK here because the only possible error is empty section name,
+		// but if it's empty, this piece of code won't be executed.
+		sec, _ = f.NewSection(name)
+		return sec
+	}
+	return sec
+}
+
+// Section returns list of Section.
+func (f *File) Sections() []*Section {
+	sections := make([]*Section, len(f.sectionList))
+	for i := range f.sectionList {
+		sections[i] = f.Section(f.sectionList[i])
+	}
+	return sections
+}
+
+// ChildSections returns a list of child sections of given section name.
+func (f *File) ChildSections(name string) []*Section {
+	return f.Section(name).ChildSections()
+}
+
+// SectionStrings returns list of section names.
+func (f *File) SectionStrings() []string {
+	list := make([]string, len(f.sectionList))
+	copy(list, f.sectionList)
+	return list
+}
+
+// DeleteSection deletes a section.
+func (f *File) DeleteSection(name string) {
+	if f.BlockMode {
+		f.lock.Lock()
+		defer f.lock.Unlock()
+	}
+
+	if len(name) == 0 {
+		name = DEFAULT_SECTION
+	}
+
+	for i, s := range f.sectionList {
+		if s == name {
+			f.sectionList = append(f.sectionList[:i], f.sectionList[i+1:]...)
+			delete(f.sections, name)
+			return
+		}
+	}
+}
+
+func (f *File) reload(s dataSource) error {
+	r, err := s.ReadCloser()
+	if err != nil {
+		return err
+	}
+	defer r.Close()
+
+	return f.parse(r)
+}
+
+// Reload reloads and parses all data sources.
+func (f *File) Reload() (err error) {
+	for _, s := range f.dataSources {
+		if err = f.reload(s); err != nil {
+			// In loose mode, we create an empty default section for nonexistent files.
+			if os.IsNotExist(err) && f.options.Loose {
+				f.parse(bytes.NewBuffer(nil))
+				continue
+			}
+			return err
+		}
+	}
+	return nil
+}
+
+// Append appends one or more data sources and reloads automatically.
+func (f *File) Append(source interface{}, others ...interface{}) error {
+	ds, err := parseDataSource(source)
+	if err != nil {
+		return err
+	}
+	f.dataSources = append(f.dataSources, ds)
+	for _, s := range others {
+		ds, err = parseDataSource(s)
+		if err != nil {
+			return err
+		}
+		f.dataSources = append(f.dataSources, ds)
+	}
+	return f.Reload()
+}
+
+func (f *File) writeToBuffer(indent string) (*bytes.Buffer, error) {
+	equalSign := "="
+	if PrettyFormat {
+		equalSign = " = "
+	}
+
+	// Use buffer to make sure target is safe until finish encoding.
+	buf := bytes.NewBuffer(nil)
+	for i, sname := range f.sectionList {
+		sec := f.Section(sname)
+		if len(sec.Comment) > 0 {
+			if sec.Comment[0] != '#' && sec.Comment[0] != ';' {
+				sec.Comment = "; " + sec.Comment
+			}
+			if _, err := buf.WriteString(sec.Comment + LineBreak); err != nil {
+				return nil, err
+			}
+		}
+
+		if i > 0 || DefaultHeader {
+			if _, err := buf.WriteString("[" + sname + "]" + LineBreak); err != nil {
+				return nil, err
+			}
+		} else {
+			// Write nothing if default section is empty
+			if len(sec.keyList) == 0 {
+				continue
+			}
+		}
+
+		if sec.isRawSection {
+			if _, err := buf.WriteString(sec.rawBody); err != nil {
+				return nil, err
+			}
+			continue
+		}
+
+		// Count and generate alignment length and buffer spaces using the
+		// longest key. Keys may be modifed if they contain certain characters so
+		// we need to take that into account in our calculation.
+		alignLength := 0
+		if PrettyFormat {
+			for _, kname := range sec.keyList {
+				keyLength := len(kname)
+				// First case will surround key by ` and second by """
+				if strings.ContainsAny(kname, "\"=:") {
+					keyLength += 2
+				} else if strings.Contains(kname, "`") {
+					keyLength += 6
+				}
+
+				if keyLength > alignLength {
+					alignLength = keyLength
+				}
+			}
+		}
+		alignSpaces := bytes.Repeat([]byte(" "), alignLength)
+
+	KEY_LIST:
+		for _, kname := range sec.keyList {
+			key := sec.Key(kname)
+			if len(key.Comment) > 0 {
+				if len(indent) > 0 && sname != DEFAULT_SECTION {
+					buf.WriteString(indent)
+				}
+				if key.Comment[0] != '#' && key.Comment[0] != ';' {
+					key.Comment = "; " + key.Comment
+				}
+				if _, err := buf.WriteString(key.Comment + LineBreak); err != nil {
+					return nil, err
+				}
+			}
+
+			if len(indent) > 0 && sname != DEFAULT_SECTION {
+				buf.WriteString(indent)
+			}
+
+			switch {
+			case key.isAutoIncrement:
+				kname = "-"
+			case strings.ContainsAny(kname, "\"=:"):
+				kname = "`" + kname + "`"
+			case strings.Contains(kname, "`"):
+				kname = `"""` + kname + `"""`
+			}
+
+			for _, val := range key.ValueWithShadows() {
+				if _, err := buf.WriteString(kname); err != nil {
+					return nil, err
+				}
+
+				if key.isBooleanType {
+					if kname != sec.keyList[len(sec.keyList)-1] {
+						buf.WriteString(LineBreak)
+					}
+					continue KEY_LIST
+				}
+
+				// Write out alignment spaces before "=" sign
+				if PrettyFormat {
+					buf.Write(alignSpaces[:alignLength-len(kname)])
+				}
+
+				// In case key value contains "\n", "`", "\"", "#" or ";"
+				if strings.ContainsAny(val, "\n`") {
+					val = `"""` + val + `"""`
+				} else if !f.options.IgnoreInlineComment && strings.ContainsAny(val, "#;") {
+					val = "`" + val + "`"
+				}
+				if _, err := buf.WriteString(equalSign + val + LineBreak); err != nil {
+					return nil, err
+				}
+			}
+		}
+
+		if PrettySection {
+			// Put a line between sections
+			if _, err := buf.WriteString(LineBreak); err != nil {
+				return nil, err
+			}
+		}
+	}
+
+	return buf, nil
+}
+
+// WriteToIndent writes content into io.Writer with given indention.
+// If PrettyFormat has been set to be true,
+// it will align "=" sign with spaces under each section.
+func (f *File) WriteToIndent(w io.Writer, indent string) (int64, error) {
+	buf, err := f.writeToBuffer(indent)
+	if err != nil {
+		return 0, err
+	}
+	return buf.WriteTo(w)
+}
+
+// WriteTo writes file content into io.Writer.
+func (f *File) WriteTo(w io.Writer) (int64, error) {
+	return f.WriteToIndent(w, "")
+}
+
+// SaveToIndent writes content to file system with given value indention.
+func (f *File) SaveToIndent(filename, indent string) error {
+	// Note: Because we are truncating with os.Create,
+	// 	so it's safer to save to a temporary file location and rename afte done.
+	buf, err := f.writeToBuffer(indent)
+	if err != nil {
+		return err
+	}
+
+	return ioutil.WriteFile(filename, buf.Bytes(), 0666)
+}
+
+// SaveTo writes content to file system.
+func (f *File) SaveTo(filename string) error {
+	return f.SaveToIndent(filename, "")
+}
diff --git a/vendor/github.com/go-ini/ini/ini_test.go b/vendor/github.com/go-ini/ini/ini_test.go
new file mode 100644
index 00000000..b3dd217c
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/ini_test.go
@@ -0,0 +1,491 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"bytes"
+	"io/ioutil"
+	"strings"
+	"testing"
+	"time"
+
+	. "github.com/smartystreets/goconvey/convey"
+)
+
+func Test_Version(t *testing.T) {
+	Convey("Get version", t, func() {
+		So(Version(), ShouldEqual, _VERSION)
+	})
+}
+
+const _CONF_DATA = `
+; Package name
+NAME        = ini
+; Package version
+VERSION     = v1
+; Package import path
+IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
+
+# Information about package author
+# Bio can be written in multiple lines.
+[author]
+NAME   = Unknwon  ; Succeeding comment
+E-MAIL = fake@localhost
+GITHUB = https://github.com/%(NAME)s
+BIO    = """Gopher.
+Coding addict.
+Good man.
+"""  # Succeeding comment
+
+[package]
+CLONE_URL = https://%(IMPORT_PATH)s
+
+[package.sub]
+UNUSED_KEY = should be deleted
+
+[features]
+-: Support read/write comments of keys and sections
+-: Support auto-increment of key names
+-: Support load multiple files to overwrite key values
+
+[types]
+STRING     = str
+BOOL       = true
+BOOL_FALSE = false
+FLOAT64    = 1.25
+INT        = 10
+TIME       = 2015-01-01T20:17:05Z
+DURATION   = 2h45m
+UINT       = 3
+
+[array]
+STRINGS  = en, zh, de
+FLOAT64S = 1.1, 2.2, 3.3
+INTS     = 1, 2, 3
+UINTS    = 1, 2, 3
+TIMES    = 2015-01-01T20:17:05Z,2015-01-01T20:17:05Z,2015-01-01T20:17:05Z
+
+[note]
+empty_lines = next line is empty\
+
+; Comment before the section
+[comments] ; This is a comment for the section too
+; Comment before key
+key  = "value"
+key2 = "value2" ; This is a comment for key2
+key3 = "one", "two", "three"
+
+[advance]
+value with quotes = "some value"
+value quote2 again = 'some value'
+includes comment sign = ` + "`" + "my#password" + "`" + `
+includes comment sign2 = ` + "`" + "my;password" + "`" + `
+true = 2+3=5
+"1+1=2" = true
+"""6+1=7""" = true
+"""` + "`" + `5+5` + "`" + `""" = 10
+` + "`" + `"6+6"` + "`" + ` = 12
+` + "`" + `7-2=4` + "`" + ` = false
+ADDRESS = ` + "`" + `404 road,
+NotFound, State, 50000` + "`" + `
+
+two_lines = how about \
+	continuation lines?
+lots_of_lines = 1 \
+	2 \
+	3 \
+	4 \
+`
+
+func Test_Load(t *testing.T) {
+	Convey("Load from data sources", t, func() {
+
+		Convey("Load with empty data", func() {
+			So(Empty(), ShouldNotBeNil)
+		})
+
+		Convey("Load with multiple data sources", func() {
+			cfg, err := Load([]byte(_CONF_DATA), "testdata/conf.ini", ioutil.NopCloser(bytes.NewReader([]byte(_CONF_DATA))))
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+
+			f, err := Load([]byte(_CONF_DATA), "testdata/404.ini")
+			So(err, ShouldNotBeNil)
+			So(f, ShouldBeNil)
+		})
+
+		Convey("Load with io.ReadCloser", func() {
+			cfg, err := Load(ioutil.NopCloser(bytes.NewReader([]byte(_CONF_DATA))))
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+
+			So(cfg.Section("").Key("NAME").String(), ShouldEqual, "ini")
+		})
+	})
+
+	Convey("Bad load process", t, func() {
+
+		Convey("Load from invalid data sources", func() {
+			_, err := Load(_CONF_DATA)
+			So(err, ShouldNotBeNil)
+
+			f, err := Load("testdata/404.ini")
+			So(err, ShouldNotBeNil)
+			So(f, ShouldBeNil)
+
+			_, err = Load(1)
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte(""), 1)
+			So(err, ShouldNotBeNil)
+		})
+
+		Convey("Load with bad section name", func() {
+			_, err := Load([]byte("[]"))
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte("["))
+			So(err, ShouldNotBeNil)
+		})
+
+		Convey("Load with bad keys", func() {
+			_, err := Load([]byte(`"""name`))
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte(`"""name"""`))
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte(`""=1`))
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte(`=`))
+			So(err, ShouldNotBeNil)
+
+			_, err = Load([]byte(`name`))
+			So(err, ShouldNotBeNil)
+		})
+
+		Convey("Load with bad values", func() {
+			_, err := Load([]byte(`name="""Unknwon`))
+			So(err, ShouldNotBeNil)
+		})
+	})
+
+	Convey("Get section and key insensitively", t, func() {
+		cfg, err := InsensitiveLoad([]byte(_CONF_DATA), "testdata/conf.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		sec, err := cfg.GetSection("Author")
+		So(err, ShouldBeNil)
+		So(sec, ShouldNotBeNil)
+
+		key, err := sec.GetKey("E-mail")
+		So(err, ShouldBeNil)
+		So(key, ShouldNotBeNil)
+	})
+
+	Convey("Load with ignoring continuation lines", t, func() {
+		cfg, err := LoadSources(LoadOptions{IgnoreContinuation: true}, []byte(`key1=a\b\
+key2=c\d\`))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		So(cfg.Section("").Key("key1").String(), ShouldEqual, `a\b\`)
+		So(cfg.Section("").Key("key2").String(), ShouldEqual, `c\d\`)
+	})
+
+	Convey("Load with ignoring inline comments", t, func() {
+		cfg, err := LoadSources(LoadOptions{IgnoreInlineComment: true}, []byte(`key1=value ;comment
+key2=value #comment2`))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		So(cfg.Section("").Key("key1").String(), ShouldEqual, `value ;comment`)
+		So(cfg.Section("").Key("key2").String(), ShouldEqual, `value #comment2`)
+
+		var buf bytes.Buffer
+		cfg.WriteTo(&buf)
+		So(buf.String(), ShouldEqual, `key1 = value ;comment
+key2 = value #comment2
+
+`)
+	})
+
+	Convey("Load with boolean type keys", t, func() {
+		cfg, err := LoadSources(LoadOptions{AllowBooleanKeys: true}, []byte(`key1=hello
+key2
+#key3
+key4
+key5`))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		So(strings.Join(cfg.Section("").KeyStrings(), ","), ShouldEqual, "key1,key2,key4,key5")
+		So(cfg.Section("").Key("key2").MustBool(false), ShouldBeTrue)
+
+		var buf bytes.Buffer
+		cfg.WriteTo(&buf)
+		// there is always a trailing \n at the end of the section
+		So(buf.String(), ShouldEqual, `key1 = hello
+key2
+#key3
+key4
+key5
+`)
+	})
+}
+
+func Test_File_ChildSections(t *testing.T) {
+	Convey("Find child sections by parent name", t, func() {
+		cfg, err := Load([]byte(`
+[node]
+
+[node.biz1]
+
+[node.biz2]
+
+[node.biz3]
+
+[node.bizN]
+`))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		children := cfg.ChildSections("node")
+		names := make([]string, len(children))
+		for i := range children {
+			names[i] = children[i].name
+		}
+		So(strings.Join(names, ","), ShouldEqual, "node.biz1,node.biz2,node.biz3,node.bizN")
+	})
+}
+
+func Test_LooseLoad(t *testing.T) {
+	Convey("Loose load from data sources", t, func() {
+		Convey("Loose load mixed with nonexistent file", func() {
+			cfg, err := LooseLoad("testdata/404.ini")
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+			var fake struct {
+				Name string `ini:"name"`
+			}
+			So(cfg.MapTo(&fake), ShouldBeNil)
+
+			cfg, err = LooseLoad([]byte("name=Unknwon"), "testdata/404.ini")
+			So(err, ShouldBeNil)
+			So(cfg.Section("").Key("name").String(), ShouldEqual, "Unknwon")
+			So(cfg.MapTo(&fake), ShouldBeNil)
+			So(fake.Name, ShouldEqual, "Unknwon")
+		})
+	})
+
+}
+
+func Test_File_Append(t *testing.T) {
+	Convey("Append data sources", t, func() {
+		cfg, err := Load([]byte(""))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		So(cfg.Append([]byte(""), []byte("")), ShouldBeNil)
+
+		Convey("Append bad data sources", func() {
+			So(cfg.Append(1), ShouldNotBeNil)
+			So(cfg.Append([]byte(""), 1), ShouldNotBeNil)
+		})
+	})
+}
+
+func Test_File_WriteTo(t *testing.T) {
+	Convey("Write to somewhere", t, func() {
+		var buf bytes.Buffer
+		cfg := Empty()
+		cfg.WriteTo(&buf)
+	})
+}
+
+func Test_File_SaveTo_WriteTo(t *testing.T) {
+	Convey("Save file", t, func() {
+		cfg, err := Load([]byte(_CONF_DATA), "testdata/conf.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		cfg.Section("").Key("NAME").Comment = "Package name"
+		cfg.Section("author").Comment = `Information about package author
+# Bio can be written in multiple lines.`
+		cfg.Section("advanced").Key("val w/ pound").SetValue("my#password")
+		cfg.Section("advanced").Key("longest key has a colon : yes/no").SetValue("yes")
+		So(cfg.SaveTo("testdata/conf_out.ini"), ShouldBeNil)
+
+		cfg.Section("author").Key("NAME").Comment = "This is author name"
+
+		So(cfg.SaveToIndent("testdata/conf_out.ini", "\t"), ShouldBeNil)
+
+		var buf bytes.Buffer
+		_, err = cfg.WriteToIndent(&buf, "\t")
+		So(err, ShouldBeNil)
+		So(buf.String(), ShouldEqual, `; Package name
+NAME        = ini
+; Package version
+VERSION     = v1
+; Package import path
+IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
+
+; Information about package author
+# Bio can be written in multiple lines.
+[author]
+	; This is author name
+	NAME   = Unknwon
+	E-MAIL = u@gogs.io
+	GITHUB = https://github.com/%(NAME)s
+	# Succeeding comment
+	BIO    = """Gopher.
+Coding addict.
+Good man.
+"""
+
+[package]
+	CLONE_URL = https://%(IMPORT_PATH)s
+
+[package.sub]
+	UNUSED_KEY = should be deleted
+
+[features]
+	-  = Support read/write comments of keys and sections
+	-  = Support auto-increment of key names
+	-  = Support load multiple files to overwrite key values
+
+[types]
+	STRING     = str
+	BOOL       = true
+	BOOL_FALSE = false
+	FLOAT64    = 1.25
+	INT        = 10
+	TIME       = 2015-01-01T20:17:05Z
+	DURATION   = 2h45m
+	UINT       = 3
+
+[array]
+	STRINGS  = en, zh, de
+	FLOAT64S = 1.1, 2.2, 3.3
+	INTS     = 1, 2, 3
+	UINTS    = 1, 2, 3
+	TIMES    = 2015-01-01T20:17:05Z,2015-01-01T20:17:05Z,2015-01-01T20:17:05Z
+
+[note]
+	empty_lines = next line is empty
+
+; Comment before the section
+; This is a comment for the section too
+[comments]
+	; Comment before key
+	key  = value
+	; This is a comment for key2
+	key2 = value2
+	key3 = "one", "two", "three"
+
+[advance]
+	value with quotes      = some value
+	value quote2 again     = some value
+	includes comment sign  = `+"`"+"my#password"+"`"+`
+	includes comment sign2 = `+"`"+"my;password"+"`"+`
+	true                   = 2+3=5
+	`+"`"+`1+1=2`+"`"+`                = true
+	`+"`"+`6+1=7`+"`"+`                = true
+	"""`+"`"+`5+5`+"`"+`"""            = 10
+	`+"`"+`"6+6"`+"`"+`                = 12
+	`+"`"+`7-2=4`+"`"+`                = false
+	ADDRESS                = """404 road,
+NotFound, State, 50000"""
+	two_lines              = how about continuation lines?
+	lots_of_lines          = 1 2 3 4 
+
+[advanced]
+	val w/ pound                       = `+"`"+`my#password`+"`"+`
+	`+"`"+`longest key has a colon : yes/no`+"`"+` = yes
+
+`)
+	})
+}
+
+func Test_File_WriteTo_SectionRaw(t *testing.T) {
+	Convey("Write a INI with a raw section", t, func() {
+		var buf bytes.Buffer
+		cfg, err := LoadSources(
+			LoadOptions{
+				UnparseableSections: []string{"CORE_LESSON", "COMMENTS"},
+			},
+			"testdata/aicc.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+		cfg.WriteToIndent(&buf, "\t")
+		So(buf.String(), ShouldEqual, `[Core]
+	Lesson_Location = 87
+	Lesson_Status   = C
+	Score           = 3
+	Time            = 00:02:30
+
+[CORE_LESSON]
+my lesson state data – 1111111111111111111000000000000000001110000
+111111111111111111100000000000111000000000 – end my lesson state data
+[COMMENTS]
+<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>
+`)
+	})
+}
+
+// Helpers for slice tests.
+func float64sEqual(values []float64, expected ...float64) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i], ShouldEqual, v)
+	}
+}
+
+func intsEqual(values []int, expected ...int) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i], ShouldEqual, v)
+	}
+}
+
+func int64sEqual(values []int64, expected ...int64) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i], ShouldEqual, v)
+	}
+}
+
+func uintsEqual(values []uint, expected ...uint) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i], ShouldEqual, v)
+	}
+}
+
+func uint64sEqual(values []uint64, expected ...uint64) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i], ShouldEqual, v)
+	}
+}
+
+func timesEqual(values []time.Time, expected ...time.Time) {
+	So(values, ShouldHaveLength, len(expected))
+	for i, v := range expected {
+		So(values[i].String(), ShouldEqual, v.String())
+	}
+}
diff --git a/vendor/github.com/go-ini/ini/key.go b/vendor/github.com/go-ini/ini/key.go
new file mode 100644
index 00000000..838356af
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/key.go
@@ -0,0 +1,699 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+	"time"
+)
+
+// Key represents a key under a section.
+type Key struct {
+	s               *Section
+	name            string
+	value           string
+	isAutoIncrement bool
+	isBooleanType   bool
+
+	isShadow bool
+	shadows  []*Key
+
+	Comment string
+}
+
+// newKey simply return a key object with given values.
+func newKey(s *Section, name, val string) *Key {
+	return &Key{
+		s:     s,
+		name:  name,
+		value: val,
+	}
+}
+
+func (k *Key) addShadow(val string) error {
+	if k.isShadow {
+		return errors.New("cannot add shadow to another shadow key")
+	} else if k.isAutoIncrement || k.isBooleanType {
+		return errors.New("cannot add shadow to auto-increment or boolean key")
+	}
+
+	shadow := newKey(k.s, k.name, val)
+	shadow.isShadow = true
+	k.shadows = append(k.shadows, shadow)
+	return nil
+}
+
+// AddShadow adds a new shadow key to itself.
+func (k *Key) AddShadow(val string) error {
+	if !k.s.f.options.AllowShadows {
+		return errors.New("shadow key is not allowed")
+	}
+	return k.addShadow(val)
+}
+
+// ValueMapper represents a mapping function for values, e.g. os.ExpandEnv
+type ValueMapper func(string) string
+
+// Name returns name of key.
+func (k *Key) Name() string {
+	return k.name
+}
+
+// Value returns raw value of key for performance purpose.
+func (k *Key) Value() string {
+	return k.value
+}
+
+// ValueWithShadows returns raw values of key and its shadows if any.
+func (k *Key) ValueWithShadows() []string {
+	if len(k.shadows) == 0 {
+		return []string{k.value}
+	}
+	vals := make([]string, len(k.shadows)+1)
+	vals[0] = k.value
+	for i := range k.shadows {
+		vals[i+1] = k.shadows[i].value
+	}
+	return vals
+}
+
+// transformValue takes a raw value and transforms to its final string.
+func (k *Key) transformValue(val string) string {
+	if k.s.f.ValueMapper != nil {
+		val = k.s.f.ValueMapper(val)
+	}
+
+	// Fail-fast if no indicate char found for recursive value
+	if !strings.Contains(val, "%") {
+		return val
+	}
+	for i := 0; i < _DEPTH_VALUES; i++ {
+		vr := varPattern.FindString(val)
+		if len(vr) == 0 {
+			break
+		}
+
+		// Take off leading '%(' and trailing ')s'.
+		noption := strings.TrimLeft(vr, "%(")
+		noption = strings.TrimRight(noption, ")s")
+
+		// Search in the same section.
+		nk, err := k.s.GetKey(noption)
+		if err != nil {
+			// Search again in default section.
+			nk, _ = k.s.f.Section("").GetKey(noption)
+		}
+
+		// Substitute by new value and take off leading '%(' and trailing ')s'.
+		val = strings.Replace(val, vr, nk.value, -1)
+	}
+	return val
+}
+
+// String returns string representation of value.
+func (k *Key) String() string {
+	return k.transformValue(k.value)
+}
+
+// Validate accepts a validate function which can
+// return modifed result as key value.
+func (k *Key) Validate(fn func(string) string) string {
+	return fn(k.String())
+}
+
+// parseBool returns the boolean value represented by the string.
+//
+// It accepts 1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On,
+// 0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off.
+// Any other value returns an error.
+func parseBool(str string) (value bool, err error) {
+	switch str {
+	case "1", "t", "T", "true", "TRUE", "True", "YES", "yes", "Yes", "y", "ON", "on", "On":
+		return true, nil
+	case "0", "f", "F", "false", "FALSE", "False", "NO", "no", "No", "n", "OFF", "off", "Off":
+		return false, nil
+	}
+	return false, fmt.Errorf("parsing \"%s\": invalid syntax", str)
+}
+
+// Bool returns bool type value.
+func (k *Key) Bool() (bool, error) {
+	return parseBool(k.String())
+}
+
+// Float64 returns float64 type value.
+func (k *Key) Float64() (float64, error) {
+	return strconv.ParseFloat(k.String(), 64)
+}
+
+// Int returns int type value.
+func (k *Key) Int() (int, error) {
+	return strconv.Atoi(k.String())
+}
+
+// Int64 returns int64 type value.
+func (k *Key) Int64() (int64, error) {
+	return strconv.ParseInt(k.String(), 10, 64)
+}
+
+// Uint returns uint type valued.
+func (k *Key) Uint() (uint, error) {
+	u, e := strconv.ParseUint(k.String(), 10, 64)
+	return uint(u), e
+}
+
+// Uint64 returns uint64 type value.
+func (k *Key) Uint64() (uint64, error) {
+	return strconv.ParseUint(k.String(), 10, 64)
+}
+
+// Duration returns time.Duration type value.
+func (k *Key) Duration() (time.Duration, error) {
+	return time.ParseDuration(k.String())
+}
+
+// TimeFormat parses with given format and returns time.Time type value.
+func (k *Key) TimeFormat(format string) (time.Time, error) {
+	return time.Parse(format, k.String())
+}
+
+// Time parses with RFC3339 format and returns time.Time type value.
+func (k *Key) Time() (time.Time, error) {
+	return k.TimeFormat(time.RFC3339)
+}
+
+// MustString returns default value if key value is empty.
+func (k *Key) MustString(defaultVal string) string {
+	val := k.String()
+	if len(val) == 0 {
+		k.value = defaultVal
+		return defaultVal
+	}
+	return val
+}
+
+// MustBool always returns value without error,
+// it returns false if error occurs.
+func (k *Key) MustBool(defaultVal ...bool) bool {
+	val, err := k.Bool()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatBool(defaultVal[0])
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustFloat64 always returns value without error,
+// it returns 0.0 if error occurs.
+func (k *Key) MustFloat64(defaultVal ...float64) float64 {
+	val, err := k.Float64()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatFloat(defaultVal[0], 'f', -1, 64)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustInt always returns value without error,
+// it returns 0 if error occurs.
+func (k *Key) MustInt(defaultVal ...int) int {
+	val, err := k.Int()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatInt(int64(defaultVal[0]), 10)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustInt64 always returns value without error,
+// it returns 0 if error occurs.
+func (k *Key) MustInt64(defaultVal ...int64) int64 {
+	val, err := k.Int64()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatInt(defaultVal[0], 10)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustUint always returns value without error,
+// it returns 0 if error occurs.
+func (k *Key) MustUint(defaultVal ...uint) uint {
+	val, err := k.Uint()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatUint(uint64(defaultVal[0]), 10)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustUint64 always returns value without error,
+// it returns 0 if error occurs.
+func (k *Key) MustUint64(defaultVal ...uint64) uint64 {
+	val, err := k.Uint64()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = strconv.FormatUint(defaultVal[0], 10)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustDuration always returns value without error,
+// it returns zero value if error occurs.
+func (k *Key) MustDuration(defaultVal ...time.Duration) time.Duration {
+	val, err := k.Duration()
+	if len(defaultVal) > 0 && err != nil {
+		k.value = defaultVal[0].String()
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustTimeFormat always parses with given format and returns value without error,
+// it returns zero value if error occurs.
+func (k *Key) MustTimeFormat(format string, defaultVal ...time.Time) time.Time {
+	val, err := k.TimeFormat(format)
+	if len(defaultVal) > 0 && err != nil {
+		k.value = defaultVal[0].Format(format)
+		return defaultVal[0]
+	}
+	return val
+}
+
+// MustTime always parses with RFC3339 format and returns value without error,
+// it returns zero value if error occurs.
+func (k *Key) MustTime(defaultVal ...time.Time) time.Time {
+	return k.MustTimeFormat(time.RFC3339, defaultVal...)
+}
+
+// In always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) In(defaultVal string, candidates []string) string {
+	val := k.String()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InFloat64 always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InFloat64(defaultVal float64, candidates []float64) float64 {
+	val := k.MustFloat64()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InInt always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InInt(defaultVal int, candidates []int) int {
+	val := k.MustInt()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InInt64 always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InInt64(defaultVal int64, candidates []int64) int64 {
+	val := k.MustInt64()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InUint always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InUint(defaultVal uint, candidates []uint) uint {
+	val := k.MustUint()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InUint64 always returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InUint64(defaultVal uint64, candidates []uint64) uint64 {
+	val := k.MustUint64()
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InTimeFormat always parses with given format and returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InTimeFormat(format string, defaultVal time.Time, candidates []time.Time) time.Time {
+	val := k.MustTimeFormat(format)
+	for _, cand := range candidates {
+		if val == cand {
+			return val
+		}
+	}
+	return defaultVal
+}
+
+// InTime always parses with RFC3339 format and returns value without error,
+// it returns default value if error occurs or doesn't fit into candidates.
+func (k *Key) InTime(defaultVal time.Time, candidates []time.Time) time.Time {
+	return k.InTimeFormat(time.RFC3339, defaultVal, candidates)
+}
+
+// RangeFloat64 checks if value is in given range inclusively,
+// and returns default value if it's not.
+func (k *Key) RangeFloat64(defaultVal, min, max float64) float64 {
+	val := k.MustFloat64()
+	if val < min || val > max {
+		return defaultVal
+	}
+	return val
+}
+
+// RangeInt checks if value is in given range inclusively,
+// and returns default value if it's not.
+func (k *Key) RangeInt(defaultVal, min, max int) int {
+	val := k.MustInt()
+	if val < min || val > max {
+		return defaultVal
+	}
+	return val
+}
+
+// RangeInt64 checks if value is in given range inclusively,
+// and returns default value if it's not.
+func (k *Key) RangeInt64(defaultVal, min, max int64) int64 {
+	val := k.MustInt64()
+	if val < min || val > max {
+		return defaultVal
+	}
+	return val
+}
+
+// RangeTimeFormat checks if value with given format is in given range inclusively,
+// and returns default value if it's not.
+func (k *Key) RangeTimeFormat(format string, defaultVal, min, max time.Time) time.Time {
+	val := k.MustTimeFormat(format)
+	if val.Unix() < min.Unix() || val.Unix() > max.Unix() {
+		return defaultVal
+	}
+	return val
+}
+
+// RangeTime checks if value with RFC3339 format is in given range inclusively,
+// and returns default value if it's not.
+func (k *Key) RangeTime(defaultVal, min, max time.Time) time.Time {
+	return k.RangeTimeFormat(time.RFC3339, defaultVal, min, max)
+}
+
+// Strings returns list of string divided by given delimiter.
+func (k *Key) Strings(delim string) []string {
+	str := k.String()
+	if len(str) == 0 {
+		return []string{}
+	}
+
+	vals := strings.Split(str, delim)
+	for i := range vals {
+		// vals[i] = k.transformValue(strings.TrimSpace(vals[i]))
+		vals[i] = strings.TrimSpace(vals[i])
+	}
+	return vals
+}
+
+// StringsWithShadows returns list of string divided by given delimiter.
+// Shadows will also be appended if any.
+func (k *Key) StringsWithShadows(delim string) []string {
+	vals := k.ValueWithShadows()
+	results := make([]string, 0, len(vals)*2)
+	for i := range vals {
+		if len(vals) == 0 {
+			continue
+		}
+
+		results = append(results, strings.Split(vals[i], delim)...)
+	}
+
+	for i := range results {
+		results[i] = k.transformValue(strings.TrimSpace(results[i]))
+	}
+	return results
+}
+
+// Float64s returns list of float64 divided by given delimiter. Any invalid input will be treated as zero value.
+func (k *Key) Float64s(delim string) []float64 {
+	vals, _ := k.parseFloat64s(k.Strings(delim), true, false)
+	return vals
+}
+
+// Ints returns list of int divided by given delimiter. Any invalid input will be treated as zero value.
+func (k *Key) Ints(delim string) []int {
+	vals, _ := k.parseInts(k.Strings(delim), true, false)
+	return vals
+}
+
+// Int64s returns list of int64 divided by given delimiter. Any invalid input will be treated as zero value.
+func (k *Key) Int64s(delim string) []int64 {
+	vals, _ := k.parseInt64s(k.Strings(delim), true, false)
+	return vals
+}
+
+// Uints returns list of uint divided by given delimiter. Any invalid input will be treated as zero value.
+func (k *Key) Uints(delim string) []uint {
+	vals, _ := k.parseUints(k.Strings(delim), true, false)
+	return vals
+}
+
+// Uint64s returns list of uint64 divided by given delimiter. Any invalid input will be treated as zero value.
+func (k *Key) Uint64s(delim string) []uint64 {
+	vals, _ := k.parseUint64s(k.Strings(delim), true, false)
+	return vals
+}
+
+// TimesFormat parses with given format and returns list of time.Time divided by given delimiter.
+// Any invalid input will be treated as zero value (0001-01-01 00:00:00 +0000 UTC).
+func (k *Key) TimesFormat(format, delim string) []time.Time {
+	vals, _ := k.parseTimesFormat(format, k.Strings(delim), true, false)
+	return vals
+}
+
+// Times parses with RFC3339 format and returns list of time.Time divided by given delimiter.
+// Any invalid input will be treated as zero value (0001-01-01 00:00:00 +0000 UTC).
+func (k *Key) Times(delim string) []time.Time {
+	return k.TimesFormat(time.RFC3339, delim)
+}
+
+// ValidFloat64s returns list of float64 divided by given delimiter. If some value is not float, then
+// it will not be included to result list.
+func (k *Key) ValidFloat64s(delim string) []float64 {
+	vals, _ := k.parseFloat64s(k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidInts returns list of int divided by given delimiter. If some value is not integer, then it will
+// not be included to result list.
+func (k *Key) ValidInts(delim string) []int {
+	vals, _ := k.parseInts(k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidInt64s returns list of int64 divided by given delimiter. If some value is not 64-bit integer,
+// then it will not be included to result list.
+func (k *Key) ValidInt64s(delim string) []int64 {
+	vals, _ := k.parseInt64s(k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidUints returns list of uint divided by given delimiter. If some value is not unsigned integer,
+// then it will not be included to result list.
+func (k *Key) ValidUints(delim string) []uint {
+	vals, _ := k.parseUints(k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidUint64s returns list of uint64 divided by given delimiter. If some value is not 64-bit unsigned
+// integer, then it will not be included to result list.
+func (k *Key) ValidUint64s(delim string) []uint64 {
+	vals, _ := k.parseUint64s(k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidTimesFormat parses with given format and returns list of time.Time divided by given delimiter.
+func (k *Key) ValidTimesFormat(format, delim string) []time.Time {
+	vals, _ := k.parseTimesFormat(format, k.Strings(delim), false, false)
+	return vals
+}
+
+// ValidTimes parses with RFC3339 format and returns list of time.Time divided by given delimiter.
+func (k *Key) ValidTimes(delim string) []time.Time {
+	return k.ValidTimesFormat(time.RFC3339, delim)
+}
+
+// StrictFloat64s returns list of float64 divided by given delimiter or error on first invalid input.
+func (k *Key) StrictFloat64s(delim string) ([]float64, error) {
+	return k.parseFloat64s(k.Strings(delim), false, true)
+}
+
+// StrictInts returns list of int divided by given delimiter or error on first invalid input.
+func (k *Key) StrictInts(delim string) ([]int, error) {
+	return k.parseInts(k.Strings(delim), false, true)
+}
+
+// StrictInt64s returns list of int64 divided by given delimiter or error on first invalid input.
+func (k *Key) StrictInt64s(delim string) ([]int64, error) {
+	return k.parseInt64s(k.Strings(delim), false, true)
+}
+
+// StrictUints returns list of uint divided by given delimiter or error on first invalid input.
+func (k *Key) StrictUints(delim string) ([]uint, error) {
+	return k.parseUints(k.Strings(delim), false, true)
+}
+
+// StrictUint64s returns list of uint64 divided by given delimiter or error on first invalid input.
+func (k *Key) StrictUint64s(delim string) ([]uint64, error) {
+	return k.parseUint64s(k.Strings(delim), false, true)
+}
+
+// StrictTimesFormat parses with given format and returns list of time.Time divided by given delimiter
+// or error on first invalid input.
+func (k *Key) StrictTimesFormat(format, delim string) ([]time.Time, error) {
+	return k.parseTimesFormat(format, k.Strings(delim), false, true)
+}
+
+// StrictTimes parses with RFC3339 format and returns list of time.Time divided by given delimiter
+// or error on first invalid input.
+func (k *Key) StrictTimes(delim string) ([]time.Time, error) {
+	return k.StrictTimesFormat(time.RFC3339, delim)
+}
+
+// parseFloat64s transforms strings to float64s.
+func (k *Key) parseFloat64s(strs []string, addInvalid, returnOnInvalid bool) ([]float64, error) {
+	vals := make([]float64, 0, len(strs))
+	for _, str := range strs {
+		val, err := strconv.ParseFloat(str, 64)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, val)
+		}
+	}
+	return vals, nil
+}
+
+// parseInts transforms strings to ints.
+func (k *Key) parseInts(strs []string, addInvalid, returnOnInvalid bool) ([]int, error) {
+	vals := make([]int, 0, len(strs))
+	for _, str := range strs {
+		val, err := strconv.Atoi(str)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, val)
+		}
+	}
+	return vals, nil
+}
+
+// parseInt64s transforms strings to int64s.
+func (k *Key) parseInt64s(strs []string, addInvalid, returnOnInvalid bool) ([]int64, error) {
+	vals := make([]int64, 0, len(strs))
+	for _, str := range strs {
+		val, err := strconv.ParseInt(str, 10, 64)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, val)
+		}
+	}
+	return vals, nil
+}
+
+// parseUints transforms strings to uints.
+func (k *Key) parseUints(strs []string, addInvalid, returnOnInvalid bool) ([]uint, error) {
+	vals := make([]uint, 0, len(strs))
+	for _, str := range strs {
+		val, err := strconv.ParseUint(str, 10, 0)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, uint(val))
+		}
+	}
+	return vals, nil
+}
+
+// parseUint64s transforms strings to uint64s.
+func (k *Key) parseUint64s(strs []string, addInvalid, returnOnInvalid bool) ([]uint64, error) {
+	vals := make([]uint64, 0, len(strs))
+	for _, str := range strs {
+		val, err := strconv.ParseUint(str, 10, 64)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, val)
+		}
+	}
+	return vals, nil
+}
+
+// parseTimesFormat transforms strings to times in given format.
+func (k *Key) parseTimesFormat(format string, strs []string, addInvalid, returnOnInvalid bool) ([]time.Time, error) {
+	vals := make([]time.Time, 0, len(strs))
+	for _, str := range strs {
+		val, err := time.Parse(format, str)
+		if err != nil && returnOnInvalid {
+			return nil, err
+		}
+		if err == nil || addInvalid {
+			vals = append(vals, val)
+		}
+	}
+	return vals, nil
+}
+
+// SetValue changes key value.
+func (k *Key) SetValue(v string) {
+	if k.s.f.BlockMode {
+		k.s.f.lock.Lock()
+		defer k.s.f.lock.Unlock()
+	}
+
+	k.value = v
+	k.s.keysHash[k.name] = v
+}
diff --git a/vendor/github.com/go-ini/ini/key_test.go b/vendor/github.com/go-ini/ini/key_test.go
new file mode 100644
index 00000000..1281d5bf
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/key_test.go
@@ -0,0 +1,573 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"bytes"
+	"fmt"
+	"strings"
+	"testing"
+	"time"
+
+	. "github.com/smartystreets/goconvey/convey"
+)
+
+func Test_Key(t *testing.T) {
+	Convey("Test getting and setting values", t, func() {
+		cfg, err := Load([]byte(_CONF_DATA), "testdata/conf.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		Convey("Get values in default section", func() {
+			sec := cfg.Section("")
+			So(sec, ShouldNotBeNil)
+			So(sec.Key("NAME").Value(), ShouldEqual, "ini")
+			So(sec.Key("NAME").String(), ShouldEqual, "ini")
+			So(sec.Key("NAME").Validate(func(in string) string {
+				return in
+			}), ShouldEqual, "ini")
+			So(sec.Key("NAME").Comment, ShouldEqual, "; Package name")
+			So(sec.Key("IMPORT_PATH").String(), ShouldEqual, "gopkg.in/ini.v1")
+		})
+
+		Convey("Get values in non-default section", func() {
+			sec := cfg.Section("author")
+			So(sec, ShouldNotBeNil)
+			So(sec.Key("NAME").String(), ShouldEqual, "Unknwon")
+			So(sec.Key("GITHUB").String(), ShouldEqual, "https://github.com/Unknwon")
+
+			sec = cfg.Section("package")
+			So(sec, ShouldNotBeNil)
+			So(sec.Key("CLONE_URL").String(), ShouldEqual, "https://gopkg.in/ini.v1")
+		})
+
+		Convey("Get auto-increment key names", func() {
+			keys := cfg.Section("features").Keys()
+			for i, k := range keys {
+				So(k.Name(), ShouldEqual, fmt.Sprintf("#%d", i+1))
+			}
+		})
+
+		Convey("Get parent-keys that are available to the child section", func() {
+			parentKeys := cfg.Section("package.sub").ParentKeys()
+			for _, k := range parentKeys {
+				So(k.Name(), ShouldEqual, "CLONE_URL")
+			}
+		})
+
+		Convey("Get overwrite value", func() {
+			So(cfg.Section("author").Key("E-MAIL").String(), ShouldEqual, "u@gogs.io")
+		})
+
+		Convey("Get sections", func() {
+			sections := cfg.Sections()
+			for i, name := range []string{DEFAULT_SECTION, "author", "package", "package.sub", "features", "types", "array", "note", "comments", "advance"} {
+				So(sections[i].Name(), ShouldEqual, name)
+			}
+		})
+
+		Convey("Get parent section value", func() {
+			So(cfg.Section("package.sub").Key("CLONE_URL").String(), ShouldEqual, "https://gopkg.in/ini.v1")
+			So(cfg.Section("package.fake.sub").Key("CLONE_URL").String(), ShouldEqual, "https://gopkg.in/ini.v1")
+		})
+
+		Convey("Get multiple line value", func() {
+			So(cfg.Section("author").Key("BIO").String(), ShouldEqual, "Gopher.\nCoding addict.\nGood man.\n")
+		})
+
+		Convey("Get values with type", func() {
+			sec := cfg.Section("types")
+			v1, err := sec.Key("BOOL").Bool()
+			So(err, ShouldBeNil)
+			So(v1, ShouldBeTrue)
+
+			v1, err = sec.Key("BOOL_FALSE").Bool()
+			So(err, ShouldBeNil)
+			So(v1, ShouldBeFalse)
+
+			v2, err := sec.Key("FLOAT64").Float64()
+			So(err, ShouldBeNil)
+			So(v2, ShouldEqual, 1.25)
+
+			v3, err := sec.Key("INT").Int()
+			So(err, ShouldBeNil)
+			So(v3, ShouldEqual, 10)
+
+			v4, err := sec.Key("INT").Int64()
+			So(err, ShouldBeNil)
+			So(v4, ShouldEqual, 10)
+
+			v5, err := sec.Key("UINT").Uint()
+			So(err, ShouldBeNil)
+			So(v5, ShouldEqual, 3)
+
+			v6, err := sec.Key("UINT").Uint64()
+			So(err, ShouldBeNil)
+			So(v6, ShouldEqual, 3)
+
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			v7, err := sec.Key("TIME").Time()
+			So(err, ShouldBeNil)
+			So(v7.String(), ShouldEqual, t.String())
+
+			Convey("Must get values with type", func() {
+				So(sec.Key("STRING").MustString("404"), ShouldEqual, "str")
+				So(sec.Key("BOOL").MustBool(), ShouldBeTrue)
+				So(sec.Key("FLOAT64").MustFloat64(), ShouldEqual, 1.25)
+				So(sec.Key("INT").MustInt(), ShouldEqual, 10)
+				So(sec.Key("INT").MustInt64(), ShouldEqual, 10)
+				So(sec.Key("UINT").MustUint(), ShouldEqual, 3)
+				So(sec.Key("UINT").MustUint64(), ShouldEqual, 3)
+				So(sec.Key("TIME").MustTime().String(), ShouldEqual, t.String())
+
+				dur, err := time.ParseDuration("2h45m")
+				So(err, ShouldBeNil)
+				So(sec.Key("DURATION").MustDuration().Seconds(), ShouldEqual, dur.Seconds())
+
+				Convey("Must get values with default value", func() {
+					So(sec.Key("STRING_404").MustString("404"), ShouldEqual, "404")
+					So(sec.Key("BOOL_404").MustBool(true), ShouldBeTrue)
+					So(sec.Key("FLOAT64_404").MustFloat64(2.5), ShouldEqual, 2.5)
+					So(sec.Key("INT_404").MustInt(15), ShouldEqual, 15)
+					So(sec.Key("INT64_404").MustInt64(15), ShouldEqual, 15)
+					So(sec.Key("UINT_404").MustUint(6), ShouldEqual, 6)
+					So(sec.Key("UINT64_404").MustUint64(6), ShouldEqual, 6)
+
+					t, err := time.Parse(time.RFC3339, "2014-01-01T20:17:05Z")
+					So(err, ShouldBeNil)
+					So(sec.Key("TIME_404").MustTime(t).String(), ShouldEqual, t.String())
+
+					So(sec.Key("DURATION_404").MustDuration(dur).Seconds(), ShouldEqual, dur.Seconds())
+
+					Convey("Must should set default as key value", func() {
+						So(sec.Key("STRING_404").String(), ShouldEqual, "404")
+						So(sec.Key("BOOL_404").String(), ShouldEqual, "true")
+						So(sec.Key("FLOAT64_404").String(), ShouldEqual, "2.5")
+						So(sec.Key("INT_404").String(), ShouldEqual, "15")
+						So(sec.Key("INT64_404").String(), ShouldEqual, "15")
+						So(sec.Key("UINT_404").String(), ShouldEqual, "6")
+						So(sec.Key("UINT64_404").String(), ShouldEqual, "6")
+						So(sec.Key("TIME_404").String(), ShouldEqual, "2014-01-01T20:17:05Z")
+						So(sec.Key("DURATION_404").String(), ShouldEqual, "2h45m0s")
+					})
+				})
+			})
+		})
+
+		Convey("Get value with candidates", func() {
+			sec := cfg.Section("types")
+			So(sec.Key("STRING").In("", []string{"str", "arr", "types"}), ShouldEqual, "str")
+			So(sec.Key("FLOAT64").InFloat64(0, []float64{1.25, 2.5, 3.75}), ShouldEqual, 1.25)
+			So(sec.Key("INT").InInt(0, []int{10, 20, 30}), ShouldEqual, 10)
+			So(sec.Key("INT").InInt64(0, []int64{10, 20, 30}), ShouldEqual, 10)
+			So(sec.Key("UINT").InUint(0, []uint{3, 6, 9}), ShouldEqual, 3)
+			So(sec.Key("UINT").InUint64(0, []uint64{3, 6, 9}), ShouldEqual, 3)
+
+			zt, err := time.Parse(time.RFC3339, "0001-01-01T01:00:00Z")
+			So(err, ShouldBeNil)
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			So(sec.Key("TIME").InTime(zt, []time.Time{t, time.Now(), time.Now().Add(1 * time.Second)}).String(), ShouldEqual, t.String())
+
+			Convey("Get value with candidates and default value", func() {
+				So(sec.Key("STRING_404").In("str", []string{"str", "arr", "types"}), ShouldEqual, "str")
+				So(sec.Key("FLOAT64_404").InFloat64(1.25, []float64{1.25, 2.5, 3.75}), ShouldEqual, 1.25)
+				So(sec.Key("INT_404").InInt(10, []int{10, 20, 30}), ShouldEqual, 10)
+				So(sec.Key("INT64_404").InInt64(10, []int64{10, 20, 30}), ShouldEqual, 10)
+				So(sec.Key("UINT_404").InUint(3, []uint{3, 6, 9}), ShouldEqual, 3)
+				So(sec.Key("UINT_404").InUint64(3, []uint64{3, 6, 9}), ShouldEqual, 3)
+				So(sec.Key("TIME_404").InTime(t, []time.Time{time.Now(), time.Now(), time.Now().Add(1 * time.Second)}).String(), ShouldEqual, t.String())
+			})
+		})
+
+		Convey("Get values in range", func() {
+			sec := cfg.Section("types")
+			So(sec.Key("FLOAT64").RangeFloat64(0, 1, 2), ShouldEqual, 1.25)
+			So(sec.Key("INT").RangeInt(0, 10, 20), ShouldEqual, 10)
+			So(sec.Key("INT").RangeInt64(0, 10, 20), ShouldEqual, 10)
+
+			minT, err := time.Parse(time.RFC3339, "0001-01-01T01:00:00Z")
+			So(err, ShouldBeNil)
+			midT, err := time.Parse(time.RFC3339, "2013-01-01T01:00:00Z")
+			So(err, ShouldBeNil)
+			maxT, err := time.Parse(time.RFC3339, "9999-01-01T01:00:00Z")
+			So(err, ShouldBeNil)
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			So(sec.Key("TIME").RangeTime(t, minT, maxT).String(), ShouldEqual, t.String())
+
+			Convey("Get value in range with default value", func() {
+				So(sec.Key("FLOAT64").RangeFloat64(5, 0, 1), ShouldEqual, 5)
+				So(sec.Key("INT").RangeInt(7, 0, 5), ShouldEqual, 7)
+				So(sec.Key("INT").RangeInt64(7, 0, 5), ShouldEqual, 7)
+				So(sec.Key("TIME").RangeTime(t, minT, midT).String(), ShouldEqual, t.String())
+			})
+		})
+
+		Convey("Get values into slice", func() {
+			sec := cfg.Section("array")
+			So(strings.Join(sec.Key("STRINGS").Strings(","), ","), ShouldEqual, "en,zh,de")
+			So(len(sec.Key("STRINGS_404").Strings(",")), ShouldEqual, 0)
+
+			vals1 := sec.Key("FLOAT64S").Float64s(",")
+			float64sEqual(vals1, 1.1, 2.2, 3.3)
+
+			vals2 := sec.Key("INTS").Ints(",")
+			intsEqual(vals2, 1, 2, 3)
+
+			vals3 := sec.Key("INTS").Int64s(",")
+			int64sEqual(vals3, 1, 2, 3)
+
+			vals4 := sec.Key("UINTS").Uints(",")
+			uintsEqual(vals4, 1, 2, 3)
+
+			vals5 := sec.Key("UINTS").Uint64s(",")
+			uint64sEqual(vals5, 1, 2, 3)
+
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			vals6 := sec.Key("TIMES").Times(",")
+			timesEqual(vals6, t, t, t)
+		})
+
+		Convey("Get valid values into slice", func() {
+			sec := cfg.Section("array")
+			vals1 := sec.Key("FLOAT64S").ValidFloat64s(",")
+			float64sEqual(vals1, 1.1, 2.2, 3.3)
+
+			vals2 := sec.Key("INTS").ValidInts(",")
+			intsEqual(vals2, 1, 2, 3)
+
+			vals3 := sec.Key("INTS").ValidInt64s(",")
+			int64sEqual(vals3, 1, 2, 3)
+
+			vals4 := sec.Key("UINTS").ValidUints(",")
+			uintsEqual(vals4, 1, 2, 3)
+
+			vals5 := sec.Key("UINTS").ValidUint64s(",")
+			uint64sEqual(vals5, 1, 2, 3)
+
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			vals6 := sec.Key("TIMES").ValidTimes(",")
+			timesEqual(vals6, t, t, t)
+		})
+
+		Convey("Get values one type into slice of another type", func() {
+			sec := cfg.Section("array")
+			vals1 := sec.Key("STRINGS").ValidFloat64s(",")
+			So(vals1, ShouldBeEmpty)
+
+			vals2 := sec.Key("STRINGS").ValidInts(",")
+			So(vals2, ShouldBeEmpty)
+
+			vals3 := sec.Key("STRINGS").ValidInt64s(",")
+			So(vals3, ShouldBeEmpty)
+
+			vals4 := sec.Key("STRINGS").ValidUints(",")
+			So(vals4, ShouldBeEmpty)
+
+			vals5 := sec.Key("STRINGS").ValidUint64s(",")
+			So(vals5, ShouldBeEmpty)
+
+			vals6 := sec.Key("STRINGS").ValidTimes(",")
+			So(vals6, ShouldBeEmpty)
+		})
+
+		Convey("Get valid values into slice without errors", func() {
+			sec := cfg.Section("array")
+			vals1, err := sec.Key("FLOAT64S").StrictFloat64s(",")
+			So(err, ShouldBeNil)
+			float64sEqual(vals1, 1.1, 2.2, 3.3)
+
+			vals2, err := sec.Key("INTS").StrictInts(",")
+			So(err, ShouldBeNil)
+			intsEqual(vals2, 1, 2, 3)
+
+			vals3, err := sec.Key("INTS").StrictInt64s(",")
+			So(err, ShouldBeNil)
+			int64sEqual(vals3, 1, 2, 3)
+
+			vals4, err := sec.Key("UINTS").StrictUints(",")
+			So(err, ShouldBeNil)
+			uintsEqual(vals4, 1, 2, 3)
+
+			vals5, err := sec.Key("UINTS").StrictUint64s(",")
+			So(err, ShouldBeNil)
+			uint64sEqual(vals5, 1, 2, 3)
+
+			t, err := time.Parse(time.RFC3339, "2015-01-01T20:17:05Z")
+			So(err, ShouldBeNil)
+			vals6, err := sec.Key("TIMES").StrictTimes(",")
+			So(err, ShouldBeNil)
+			timesEqual(vals6, t, t, t)
+		})
+
+		Convey("Get invalid values into slice", func() {
+			sec := cfg.Section("array")
+			vals1, err := sec.Key("STRINGS").StrictFloat64s(",")
+			So(vals1, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+
+			vals2, err := sec.Key("STRINGS").StrictInts(",")
+			So(vals2, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+
+			vals3, err := sec.Key("STRINGS").StrictInt64s(",")
+			So(vals3, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+
+			vals4, err := sec.Key("STRINGS").StrictUints(",")
+			So(vals4, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+
+			vals5, err := sec.Key("STRINGS").StrictUint64s(",")
+			So(vals5, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+
+			vals6, err := sec.Key("STRINGS").StrictTimes(",")
+			So(vals6, ShouldBeEmpty)
+			So(err, ShouldNotBeNil)
+		})
+
+		Convey("Get key hash", func() {
+			cfg.Section("").KeysHash()
+		})
+
+		Convey("Set key value", func() {
+			k := cfg.Section("author").Key("NAME")
+			k.SetValue("无闻")
+			So(k.String(), ShouldEqual, "无闻")
+		})
+
+		Convey("Get key strings", func() {
+			So(strings.Join(cfg.Section("types").KeyStrings(), ","), ShouldEqual, "STRING,BOOL,BOOL_FALSE,FLOAT64,INT,TIME,DURATION,UINT")
+		})
+
+		Convey("Delete a key", func() {
+			cfg.Section("package.sub").DeleteKey("UNUSED_KEY")
+			_, err := cfg.Section("package.sub").GetKey("UNUSED_KEY")
+			So(err, ShouldNotBeNil)
+		})
+
+		Convey("Has Key (backwards compatible)", func() {
+			sec := cfg.Section("package.sub")
+			haskey1 := sec.Haskey("UNUSED_KEY")
+			haskey2 := sec.Haskey("CLONE_URL")
+			haskey3 := sec.Haskey("CLONE_URL_NO")
+			So(haskey1, ShouldBeTrue)
+			So(haskey2, ShouldBeTrue)
+			So(haskey3, ShouldBeFalse)
+		})
+
+		Convey("Has Key", func() {
+			sec := cfg.Section("package.sub")
+			haskey1 := sec.HasKey("UNUSED_KEY")
+			haskey2 := sec.HasKey("CLONE_URL")
+			haskey3 := sec.HasKey("CLONE_URL_NO")
+			So(haskey1, ShouldBeTrue)
+			So(haskey2, ShouldBeTrue)
+			So(haskey3, ShouldBeFalse)
+		})
+
+		Convey("Has Value", func() {
+			sec := cfg.Section("author")
+			hasvalue1 := sec.HasValue("Unknwon")
+			hasvalue2 := sec.HasValue("doc")
+			So(hasvalue1, ShouldBeTrue)
+			So(hasvalue2, ShouldBeFalse)
+		})
+	})
+
+	Convey("Test getting and setting bad values", t, func() {
+		cfg, err := Load([]byte(_CONF_DATA), "testdata/conf.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		Convey("Create new key with empty name", func() {
+			k, err := cfg.Section("").NewKey("", "")
+			So(err, ShouldNotBeNil)
+			So(k, ShouldBeNil)
+		})
+
+		Convey("Create new section with empty name", func() {
+			s, err := cfg.NewSection("")
+			So(err, ShouldNotBeNil)
+			So(s, ShouldBeNil)
+		})
+
+		Convey("Create new sections with empty name", func() {
+			So(cfg.NewSections(""), ShouldNotBeNil)
+		})
+
+		Convey("Get section that not exists", func() {
+			s, err := cfg.GetSection("404")
+			So(err, ShouldNotBeNil)
+			So(s, ShouldBeNil)
+
+			s = cfg.Section("404")
+			So(s, ShouldNotBeNil)
+		})
+	})
+
+	Convey("Test key hash clone", t, func() {
+		cfg, err := Load([]byte(strings.Replace("network=tcp,addr=127.0.0.1:6379,db=4,pool_size=100,idle_timeout=180", ",", "\n", -1)))
+		So(err, ShouldBeNil)
+		for _, v := range cfg.Section("").KeysHash() {
+			So(len(v), ShouldBeGreaterThan, 0)
+		}
+	})
+
+	Convey("Key has empty value", t, func() {
+		_conf := `key1=
+key2= ; comment`
+		cfg, err := Load([]byte(_conf))
+		So(err, ShouldBeNil)
+		So(cfg.Section("").Key("key1").Value(), ShouldBeEmpty)
+	})
+}
+
+const _CONF_GIT_CONFIG = `
+[remote "origin"]
+        url = https://github.com/Antergone/test1.git
+        url = https://github.com/Antergone/test2.git
+`
+
+func Test_Key_Shadows(t *testing.T) {
+	Convey("Shadows keys", t, func() {
+		Convey("Disable shadows", func() {
+			cfg, err := Load([]byte(_CONF_GIT_CONFIG))
+			So(err, ShouldBeNil)
+			So(cfg.Section(`remote "origin"`).Key("url").String(), ShouldEqual, "https://github.com/Antergone/test2.git")
+		})
+
+		Convey("Enable shadows", func() {
+			cfg, err := ShadowLoad([]byte(_CONF_GIT_CONFIG))
+			So(err, ShouldBeNil)
+			So(cfg.Section(`remote "origin"`).Key("url").String(), ShouldEqual, "https://github.com/Antergone/test1.git")
+			So(strings.Join(cfg.Section(`remote "origin"`).Key("url").ValueWithShadows(), " "), ShouldEqual,
+				"https://github.com/Antergone/test1.git https://github.com/Antergone/test2.git")
+
+			Convey("Save with shadows", func() {
+				var buf bytes.Buffer
+				_, err := cfg.WriteTo(&buf)
+				So(err, ShouldBeNil)
+				So(buf.String(), ShouldEqual, `[remote "origin"]
+url = https://github.com/Antergone/test1.git
+url = https://github.com/Antergone/test2.git
+
+`)
+			})
+		})
+	})
+}
+
+func newTestFile(block bool) *File {
+	c, _ := Load([]byte(_CONF_DATA))
+	c.BlockMode = block
+	return c
+}
+
+func Benchmark_Key_Value(b *testing.B) {
+	c := newTestFile(true)
+	for i := 0; i < b.N; i++ {
+		c.Section("").Key("NAME").Value()
+	}
+}
+
+func Benchmark_Key_Value_NonBlock(b *testing.B) {
+	c := newTestFile(false)
+	for i := 0; i < b.N; i++ {
+		c.Section("").Key("NAME").Value()
+	}
+}
+
+func Benchmark_Key_Value_ViaSection(b *testing.B) {
+	c := newTestFile(true)
+	sec := c.Section("")
+	for i := 0; i < b.N; i++ {
+		sec.Key("NAME").Value()
+	}
+}
+
+func Benchmark_Key_Value_ViaSection_NonBlock(b *testing.B) {
+	c := newTestFile(false)
+	sec := c.Section("")
+	for i := 0; i < b.N; i++ {
+		sec.Key("NAME").Value()
+	}
+}
+
+func Benchmark_Key_Value_Direct(b *testing.B) {
+	c := newTestFile(true)
+	key := c.Section("").Key("NAME")
+	for i := 0; i < b.N; i++ {
+		key.Value()
+	}
+}
+
+func Benchmark_Key_Value_Direct_NonBlock(b *testing.B) {
+	c := newTestFile(false)
+	key := c.Section("").Key("NAME")
+	for i := 0; i < b.N; i++ {
+		key.Value()
+	}
+}
+
+func Benchmark_Key_String(b *testing.B) {
+	c := newTestFile(true)
+	for i := 0; i < b.N; i++ {
+		_ = c.Section("").Key("NAME").String()
+	}
+}
+
+func Benchmark_Key_String_NonBlock(b *testing.B) {
+	c := newTestFile(false)
+	for i := 0; i < b.N; i++ {
+		_ = c.Section("").Key("NAME").String()
+	}
+}
+
+func Benchmark_Key_String_ViaSection(b *testing.B) {
+	c := newTestFile(true)
+	sec := c.Section("")
+	for i := 0; i < b.N; i++ {
+		_ = sec.Key("NAME").String()
+	}
+}
+
+func Benchmark_Key_String_ViaSection_NonBlock(b *testing.B) {
+	c := newTestFile(false)
+	sec := c.Section("")
+	for i := 0; i < b.N; i++ {
+		_ = sec.Key("NAME").String()
+	}
+}
+
+func Benchmark_Key_SetValue(b *testing.B) {
+	c := newTestFile(true)
+	for i := 0; i < b.N; i++ {
+		c.Section("").Key("NAME").SetValue("10")
+	}
+}
+
+func Benchmark_Key_SetValue_VisSection(b *testing.B) {
+	c := newTestFile(true)
+	sec := c.Section("")
+	for i := 0; i < b.N; i++ {
+		sec.Key("NAME").SetValue("10")
+	}
+}
diff --git a/vendor/github.com/go-ini/ini/parser.go b/vendor/github.com/go-ini/ini/parser.go
new file mode 100644
index 00000000..69d54762
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/parser.go
@@ -0,0 +1,361 @@
+// Copyright 2015 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"bufio"
+	"bytes"
+	"fmt"
+	"io"
+	"strconv"
+	"strings"
+	"unicode"
+)
+
+type tokenType int
+
+const (
+	_TOKEN_INVALID tokenType = iota
+	_TOKEN_COMMENT
+	_TOKEN_SECTION
+	_TOKEN_KEY
+)
+
+type parser struct {
+	buf     *bufio.Reader
+	isEOF   bool
+	count   int
+	comment *bytes.Buffer
+}
+
+func newParser(r io.Reader) *parser {
+	return &parser{
+		buf:     bufio.NewReader(r),
+		count:   1,
+		comment: &bytes.Buffer{},
+	}
+}
+
+// BOM handles header of UTF-8, UTF-16 LE and UTF-16 BE's BOM format.
+// http://en.wikipedia.org/wiki/Byte_order_mark#Representations_of_byte_order_marks_by_encoding
+func (p *parser) BOM() error {
+	mask, err := p.buf.Peek(2)
+	if err != nil && err != io.EOF {
+		return err
+	} else if len(mask) < 2 {
+		return nil
+	}
+
+	switch {
+	case mask[0] == 254 && mask[1] == 255:
+		fallthrough
+	case mask[0] == 255 && mask[1] == 254:
+		p.buf.Read(mask)
+	case mask[0] == 239 && mask[1] == 187:
+		mask, err := p.buf.Peek(3)
+		if err != nil && err != io.EOF {
+			return err
+		} else if len(mask) < 3 {
+			return nil
+		}
+		if mask[2] == 191 {
+			p.buf.Read(mask)
+		}
+	}
+	return nil
+}
+
+func (p *parser) readUntil(delim byte) ([]byte, error) {
+	data, err := p.buf.ReadBytes(delim)
+	if err != nil {
+		if err == io.EOF {
+			p.isEOF = true
+		} else {
+			return nil, err
+		}
+	}
+	return data, nil
+}
+
+func cleanComment(in []byte) ([]byte, bool) {
+	i := bytes.IndexAny(in, "#;")
+	if i == -1 {
+		return nil, false
+	}
+	return in[i:], true
+}
+
+func readKeyName(in []byte) (string, int, error) {
+	line := string(in)
+
+	// Check if key name surrounded by quotes.
+	var keyQuote string
+	if line[0] == '"' {
+		if len(line) > 6 && string(line[0:3]) == `"""` {
+			keyQuote = `"""`
+		} else {
+			keyQuote = `"`
+		}
+	} else if line[0] == '`' {
+		keyQuote = "`"
+	}
+
+	// Get out key name
+	endIdx := -1
+	if len(keyQuote) > 0 {
+		startIdx := len(keyQuote)
+		// FIXME: fail case -> """"""name"""=value
+		pos := strings.Index(line[startIdx:], keyQuote)
+		if pos == -1 {
+			return "", -1, fmt.Errorf("missing closing key quote: %s", line)
+		}
+		pos += startIdx
+
+		// Find key-value delimiter
+		i := strings.IndexAny(line[pos+startIdx:], "=:")
+		if i < 0 {
+			return "", -1, ErrDelimiterNotFound{line}
+		}
+		endIdx = pos + i
+		return strings.TrimSpace(line[startIdx:pos]), endIdx + startIdx + 1, nil
+	}
+
+	endIdx = strings.IndexAny(line, "=:")
+	if endIdx < 0 {
+		return "", -1, ErrDelimiterNotFound{line}
+	}
+	return strings.TrimSpace(line[0:endIdx]), endIdx + 1, nil
+}
+
+func (p *parser) readMultilines(line, val, valQuote string) (string, error) {
+	for {
+		data, err := p.readUntil('\n')
+		if err != nil {
+			return "", err
+		}
+		next := string(data)
+
+		pos := strings.LastIndex(next, valQuote)
+		if pos > -1 {
+			val += next[:pos]
+
+			comment, has := cleanComment([]byte(next[pos:]))
+			if has {
+				p.comment.Write(bytes.TrimSpace(comment))
+			}
+			break
+		}
+		val += next
+		if p.isEOF {
+			return "", fmt.Errorf("missing closing key quote from '%s' to '%s'", line, next)
+		}
+	}
+	return val, nil
+}
+
+func (p *parser) readContinuationLines(val string) (string, error) {
+	for {
+		data, err := p.readUntil('\n')
+		if err != nil {
+			return "", err
+		}
+		next := strings.TrimSpace(string(data))
+
+		if len(next) == 0 {
+			break
+		}
+		val += next
+		if val[len(val)-1] != '\\' {
+			break
+		}
+		val = val[:len(val)-1]
+	}
+	return val, nil
+}
+
+// hasSurroundedQuote check if and only if the first and last characters
+// are quotes \" or \'.
+// It returns false if any other parts also contain same kind of quotes.
+func hasSurroundedQuote(in string, quote byte) bool {
+	return len(in) >= 2 && in[0] == quote && in[len(in)-1] == quote &&
+		strings.IndexByte(in[1:], quote) == len(in)-2
+}
+
+func (p *parser) readValue(in []byte, ignoreContinuation, ignoreInlineComment bool) (string, error) {
+	line := strings.TrimLeftFunc(string(in), unicode.IsSpace)
+	if len(line) == 0 {
+		return "", nil
+	}
+
+	var valQuote string
+	if len(line) > 3 && string(line[0:3]) == `"""` {
+		valQuote = `"""`
+	} else if line[0] == '`' {
+		valQuote = "`"
+	}
+
+	if len(valQuote) > 0 {
+		startIdx := len(valQuote)
+		pos := strings.LastIndex(line[startIdx:], valQuote)
+		// Check for multi-line value
+		if pos == -1 {
+			return p.readMultilines(line, line[startIdx:], valQuote)
+		}
+
+		return line[startIdx : pos+startIdx], nil
+	}
+
+	// Won't be able to reach here if value only contains whitespace
+	line = strings.TrimSpace(line)
+
+	// Check continuation lines when desired
+	if !ignoreContinuation && line[len(line)-1] == '\\' {
+		return p.readContinuationLines(line[:len(line)-1])
+	}
+
+	// Check if ignore inline comment
+	if !ignoreInlineComment {
+		i := strings.IndexAny(line, "#;")
+		if i > -1 {
+			p.comment.WriteString(line[i:])
+			line = strings.TrimSpace(line[:i])
+		}
+	}
+
+	// Trim single quotes
+	if hasSurroundedQuote(line, '\'') ||
+		hasSurroundedQuote(line, '"') {
+		line = line[1 : len(line)-1]
+	}
+	return line, nil
+}
+
+// parse parses data through an io.Reader.
+func (f *File) parse(reader io.Reader) (err error) {
+	p := newParser(reader)
+	if err = p.BOM(); err != nil {
+		return fmt.Errorf("BOM: %v", err)
+	}
+
+	// Ignore error because default section name is never empty string.
+	section, _ := f.NewSection(DEFAULT_SECTION)
+
+	var line []byte
+	var inUnparseableSection bool
+	for !p.isEOF {
+		line, err = p.readUntil('\n')
+		if err != nil {
+			return err
+		}
+
+		line = bytes.TrimLeftFunc(line, unicode.IsSpace)
+		if len(line) == 0 {
+			continue
+		}
+
+		// Comments
+		if line[0] == '#' || line[0] == ';' {
+			// Note: we do not care ending line break,
+			// it is needed for adding second line,
+			// so just clean it once at the end when set to value.
+			p.comment.Write(line)
+			continue
+		}
+
+		// Section
+		if line[0] == '[' {
+			// Read to the next ']' (TODO: support quoted strings)
+			// TODO(unknwon): use LastIndexByte when stop supporting Go1.4
+			closeIdx := bytes.LastIndex(line, []byte("]"))
+			if closeIdx == -1 {
+				return fmt.Errorf("unclosed section: %s", line)
+			}
+
+			name := string(line[1:closeIdx])
+			section, err = f.NewSection(name)
+			if err != nil {
+				return err
+			}
+
+			comment, has := cleanComment(line[closeIdx+1:])
+			if has {
+				p.comment.Write(comment)
+			}
+
+			section.Comment = strings.TrimSpace(p.comment.String())
+
+			// Reset aotu-counter and comments
+			p.comment.Reset()
+			p.count = 1
+
+			inUnparseableSection = false
+			for i := range f.options.UnparseableSections {
+				if f.options.UnparseableSections[i] == name ||
+					(f.options.Insensitive && strings.ToLower(f.options.UnparseableSections[i]) == strings.ToLower(name)) {
+					inUnparseableSection = true
+					continue
+				}
+			}
+			continue
+		}
+
+		if inUnparseableSection {
+			section.isRawSection = true
+			section.rawBody += string(line)
+			continue
+		}
+
+		kname, offset, err := readKeyName(line)
+		if err != nil {
+			// Treat as boolean key when desired, and whole line is key name.
+			if IsErrDelimiterNotFound(err) && f.options.AllowBooleanKeys {
+				kname, err := p.readValue(line, f.options.IgnoreContinuation, f.options.IgnoreInlineComment)
+				if err != nil {
+					return err
+				}
+				key, err := section.NewBooleanKey(kname)
+				if err != nil {
+					return err
+				}
+				key.Comment = strings.TrimSpace(p.comment.String())
+				p.comment.Reset()
+				continue
+			}
+			return err
+		}
+
+		// Auto increment.
+		isAutoIncr := false
+		if kname == "-" {
+			isAutoIncr = true
+			kname = "#" + strconv.Itoa(p.count)
+			p.count++
+		}
+
+		value, err := p.readValue(line[offset:], f.options.IgnoreContinuation, f.options.IgnoreInlineComment)
+		if err != nil {
+			return err
+		}
+
+		key, err := section.NewKey(kname, value)
+		if err != nil {
+			return err
+		}
+		key.isAutoIncrement = isAutoIncr
+		key.Comment = strings.TrimSpace(p.comment.String())
+		p.comment.Reset()
+	}
+	return nil
+}
diff --git a/vendor/github.com/go-ini/ini/parser_test.go b/vendor/github.com/go-ini/ini/parser_test.go
new file mode 100644
index 00000000..05258195
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/parser_test.go
@@ -0,0 +1,42 @@
+// Copyright 2016 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"testing"
+
+	. "github.com/smartystreets/goconvey/convey"
+)
+
+func Test_BOM(t *testing.T) {
+	Convey("Test handling BOM", t, func() {
+		Convey("UTF-8-BOM", func() {
+			cfg, err := Load("testdata/UTF-8-BOM.ini")
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+
+			So(cfg.Section("author").Key("E-MAIL").String(), ShouldEqual, "u@gogs.io")
+		})
+
+		Convey("UTF-16-LE-BOM", func() {
+			cfg, err := Load("testdata/UTF-16-LE-BOM.ini")
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+		})
+
+		Convey("UTF-16-BE-BOM", func() {
+		})
+	})
+}
diff --git a/vendor/github.com/go-ini/ini/section.go b/vendor/github.com/go-ini/ini/section.go
new file mode 100644
index 00000000..94f7375e
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/section.go
@@ -0,0 +1,248 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"errors"
+	"fmt"
+	"strings"
+)
+
+// Section represents a config section.
+type Section struct {
+	f        *File
+	Comment  string
+	name     string
+	keys     map[string]*Key
+	keyList  []string
+	keysHash map[string]string
+
+	isRawSection bool
+	rawBody      string
+}
+
+func newSection(f *File, name string) *Section {
+	return &Section{
+		f:        f,
+		name:     name,
+		keys:     make(map[string]*Key),
+		keyList:  make([]string, 0, 10),
+		keysHash: make(map[string]string),
+	}
+}
+
+// Name returns name of Section.
+func (s *Section) Name() string {
+	return s.name
+}
+
+// Body returns rawBody of Section if the section was marked as unparseable.
+// It still follows the other rules of the INI format surrounding leading/trailing whitespace.
+func (s *Section) Body() string {
+	return strings.TrimSpace(s.rawBody)
+}
+
+// NewKey creates a new key to given section.
+func (s *Section) NewKey(name, val string) (*Key, error) {
+	if len(name) == 0 {
+		return nil, errors.New("error creating new key: empty key name")
+	} else if s.f.options.Insensitive {
+		name = strings.ToLower(name)
+	}
+
+	if s.f.BlockMode {
+		s.f.lock.Lock()
+		defer s.f.lock.Unlock()
+	}
+
+	if inSlice(name, s.keyList) {
+		if s.f.options.AllowShadows {
+			if err := s.keys[name].addShadow(val); err != nil {
+				return nil, err
+			}
+		} else {
+			s.keys[name].value = val
+		}
+		return s.keys[name], nil
+	}
+
+	s.keyList = append(s.keyList, name)
+	s.keys[name] = newKey(s, name, val)
+	s.keysHash[name] = val
+	return s.keys[name], nil
+}
+
+// NewBooleanKey creates a new boolean type key to given section.
+func (s *Section) NewBooleanKey(name string) (*Key, error) {
+	key, err := s.NewKey(name, "true")
+	if err != nil {
+		return nil, err
+	}
+
+	key.isBooleanType = true
+	return key, nil
+}
+
+// GetKey returns key in section by given name.
+func (s *Section) GetKey(name string) (*Key, error) {
+	// FIXME: change to section level lock?
+	if s.f.BlockMode {
+		s.f.lock.RLock()
+	}
+	if s.f.options.Insensitive {
+		name = strings.ToLower(name)
+	}
+	key := s.keys[name]
+	if s.f.BlockMode {
+		s.f.lock.RUnlock()
+	}
+
+	if key == nil {
+		// Check if it is a child-section.
+		sname := s.name
+		for {
+			if i := strings.LastIndex(sname, "."); i > -1 {
+				sname = sname[:i]
+				sec, err := s.f.GetSection(sname)
+				if err != nil {
+					continue
+				}
+				return sec.GetKey(name)
+			} else {
+				break
+			}
+		}
+		return nil, fmt.Errorf("error when getting key of section '%s': key '%s' not exists", s.name, name)
+	}
+	return key, nil
+}
+
+// HasKey returns true if section contains a key with given name.
+func (s *Section) HasKey(name string) bool {
+	key, _ := s.GetKey(name)
+	return key != nil
+}
+
+// Haskey is a backwards-compatible name for HasKey.
+func (s *Section) Haskey(name string) bool {
+	return s.HasKey(name)
+}
+
+// HasValue returns true if section contains given raw value.
+func (s *Section) HasValue(value string) bool {
+	if s.f.BlockMode {
+		s.f.lock.RLock()
+		defer s.f.lock.RUnlock()
+	}
+
+	for _, k := range s.keys {
+		if value == k.value {
+			return true
+		}
+	}
+	return false
+}
+
+// Key assumes named Key exists in section and returns a zero-value when not.
+func (s *Section) Key(name string) *Key {
+	key, err := s.GetKey(name)
+	if err != nil {
+		// It's OK here because the only possible error is empty key name,
+		// but if it's empty, this piece of code won't be executed.
+		key, _ = s.NewKey(name, "")
+		return key
+	}
+	return key
+}
+
+// Keys returns list of keys of section.
+func (s *Section) Keys() []*Key {
+	keys := make([]*Key, len(s.keyList))
+	for i := range s.keyList {
+		keys[i] = s.Key(s.keyList[i])
+	}
+	return keys
+}
+
+// ParentKeys returns list of keys of parent section.
+func (s *Section) ParentKeys() []*Key {
+	var parentKeys []*Key
+	sname := s.name
+	for {
+		if i := strings.LastIndex(sname, "."); i > -1 {
+			sname = sname[:i]
+			sec, err := s.f.GetSection(sname)
+			if err != nil {
+				continue
+			}
+			parentKeys = append(parentKeys, sec.Keys()...)
+		} else {
+			break
+		}
+
+	}
+	return parentKeys
+}
+
+// KeyStrings returns list of key names of section.
+func (s *Section) KeyStrings() []string {
+	list := make([]string, len(s.keyList))
+	copy(list, s.keyList)
+	return list
+}
+
+// KeysHash returns keys hash consisting of names and values.
+func (s *Section) KeysHash() map[string]string {
+	if s.f.BlockMode {
+		s.f.lock.RLock()
+		defer s.f.lock.RUnlock()
+	}
+
+	hash := map[string]string{}
+	for key, value := range s.keysHash {
+		hash[key] = value
+	}
+	return hash
+}
+
+// DeleteKey deletes a key from section.
+func (s *Section) DeleteKey(name string) {
+	if s.f.BlockMode {
+		s.f.lock.Lock()
+		defer s.f.lock.Unlock()
+	}
+
+	for i, k := range s.keyList {
+		if k == name {
+			s.keyList = append(s.keyList[:i], s.keyList[i+1:]...)
+			delete(s.keys, name)
+			return
+		}
+	}
+}
+
+// ChildSections returns a list of child sections of current section.
+// For example, "[parent.child1]" and "[parent.child12]" are child sections
+// of section "[parent]".
+func (s *Section) ChildSections() []*Section {
+	prefix := s.name + "."
+	children := make([]*Section, 0, 3)
+	for _, name := range s.f.sectionList {
+		if strings.HasPrefix(name, prefix) {
+			children = append(children, s.f.sections[name])
+		}
+	}
+	return children
+}
diff --git a/vendor/github.com/go-ini/ini/section_test.go b/vendor/github.com/go-ini/ini/section_test.go
new file mode 100644
index 00000000..80282c19
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/section_test.go
@@ -0,0 +1,75 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"strings"
+	"testing"
+
+	. "github.com/smartystreets/goconvey/convey"
+)
+
+func Test_Section(t *testing.T) {
+	Convey("Test CRD sections", t, func() {
+		cfg, err := Load([]byte(_CONF_DATA), "testdata/conf.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		Convey("Get section strings", func() {
+			So(strings.Join(cfg.SectionStrings(), ","), ShouldEqual, "DEFAULT,author,package,package.sub,features,types,array,note,comments,advance")
+		})
+
+		Convey("Delete a section", func() {
+			cfg.DeleteSection("")
+			So(cfg.SectionStrings()[0], ShouldNotEqual, DEFAULT_SECTION)
+		})
+
+		Convey("Create new sections", func() {
+			cfg.NewSections("test", "test2")
+			_, err := cfg.GetSection("test")
+			So(err, ShouldBeNil)
+			_, err = cfg.GetSection("test2")
+			So(err, ShouldBeNil)
+		})
+	})
+}
+
+func Test_SectionRaw(t *testing.T) {
+	Convey("Test section raw string", t, func() {
+		cfg, err := LoadSources(
+			LoadOptions{
+				Insensitive: true,
+				UnparseableSections: []string{"core_lesson", "comments"},
+			},
+			"testdata/aicc.ini")
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		Convey("Get section strings", func() {
+			So(strings.Join(cfg.SectionStrings(), ","), ShouldEqual, "DEFAULT,core,core_lesson,comments")
+		})
+
+		Convey("Validate non-raw section", func() {
+			val, err := cfg.Section("core").GetKey("lesson_status")
+			So(err, ShouldBeNil)
+			So(val.String(), ShouldEqual, "C")
+		})
+
+		Convey("Validate raw section", func() {
+			So(cfg.Section("core_lesson").Body(), ShouldEqual, `my lesson state data – 1111111111111111111000000000000000001110000
+111111111111111111100000000000111000000000 – end my lesson state data`)
+		})
+	})
+}
\ No newline at end of file
diff --git a/vendor/github.com/go-ini/ini/struct.go b/vendor/github.com/go-ini/ini/struct.go
new file mode 100644
index 00000000..eeb8daba
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/struct.go
@@ -0,0 +1,500 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"bytes"
+	"errors"
+	"fmt"
+	"reflect"
+	"strings"
+	"time"
+	"unicode"
+)
+
+// NameMapper represents a ini tag name mapper.
+type NameMapper func(string) string
+
+// Built-in name getters.
+var (
+	// AllCapsUnderscore converts to format ALL_CAPS_UNDERSCORE.
+	AllCapsUnderscore NameMapper = func(raw string) string {
+		newstr := make([]rune, 0, len(raw))
+		for i, chr := range raw {
+			if isUpper := 'A' <= chr && chr <= 'Z'; isUpper {
+				if i > 0 {
+					newstr = append(newstr, '_')
+				}
+			}
+			newstr = append(newstr, unicode.ToUpper(chr))
+		}
+		return string(newstr)
+	}
+	// TitleUnderscore converts to format title_underscore.
+	TitleUnderscore NameMapper = func(raw string) string {
+		newstr := make([]rune, 0, len(raw))
+		for i, chr := range raw {
+			if isUpper := 'A' <= chr && chr <= 'Z'; isUpper {
+				if i > 0 {
+					newstr = append(newstr, '_')
+				}
+				chr -= ('A' - 'a')
+			}
+			newstr = append(newstr, chr)
+		}
+		return string(newstr)
+	}
+)
+
+func (s *Section) parseFieldName(raw, actual string) string {
+	if len(actual) > 0 {
+		return actual
+	}
+	if s.f.NameMapper != nil {
+		return s.f.NameMapper(raw)
+	}
+	return raw
+}
+
+func parseDelim(actual string) string {
+	if len(actual) > 0 {
+		return actual
+	}
+	return ","
+}
+
+var reflectTime = reflect.TypeOf(time.Now()).Kind()
+
+// setSliceWithProperType sets proper values to slice based on its type.
+func setSliceWithProperType(key *Key, field reflect.Value, delim string, allowShadow, isStrict bool) error {
+	var strs []string
+	if allowShadow {
+		strs = key.StringsWithShadows(delim)
+	} else {
+		strs = key.Strings(delim)
+	}
+
+	numVals := len(strs)
+	if numVals == 0 {
+		return nil
+	}
+
+	var vals interface{}
+	var err error
+
+	sliceOf := field.Type().Elem().Kind()
+	switch sliceOf {
+	case reflect.String:
+		vals = strs
+	case reflect.Int:
+		vals, err = key.parseInts(strs, true, false)
+	case reflect.Int64:
+		vals, err = key.parseInt64s(strs, true, false)
+	case reflect.Uint:
+		vals, err = key.parseUints(strs, true, false)
+	case reflect.Uint64:
+		vals, err = key.parseUint64s(strs, true, false)
+	case reflect.Float64:
+		vals, err = key.parseFloat64s(strs, true, false)
+	case reflectTime:
+		vals, err = key.parseTimesFormat(time.RFC3339, strs, true, false)
+	default:
+		return fmt.Errorf("unsupported type '[]%s'", sliceOf)
+	}
+	if isStrict {
+		return err
+	}
+
+	slice := reflect.MakeSlice(field.Type(), numVals, numVals)
+	for i := 0; i < numVals; i++ {
+		switch sliceOf {
+		case reflect.String:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]string)[i]))
+		case reflect.Int:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]int)[i]))
+		case reflect.Int64:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]int64)[i]))
+		case reflect.Uint:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]uint)[i]))
+		case reflect.Uint64:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]uint64)[i]))
+		case reflect.Float64:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]float64)[i]))
+		case reflectTime:
+			slice.Index(i).Set(reflect.ValueOf(vals.([]time.Time)[i]))
+		}
+	}
+	field.Set(slice)
+	return nil
+}
+
+func wrapStrictError(err error, isStrict bool) error {
+	if isStrict {
+		return err
+	}
+	return nil
+}
+
+// setWithProperType sets proper value to field based on its type,
+// but it does not return error for failing parsing,
+// because we want to use default value that is already assigned to strcut.
+func setWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string, allowShadow, isStrict bool) error {
+	switch t.Kind() {
+	case reflect.String:
+		if len(key.String()) == 0 {
+			return nil
+		}
+		field.SetString(key.String())
+	case reflect.Bool:
+		boolVal, err := key.Bool()
+		if err != nil {
+			return wrapStrictError(err, isStrict)
+		}
+		field.SetBool(boolVal)
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		durationVal, err := key.Duration()
+		// Skip zero value
+		if err == nil && int(durationVal) > 0 {
+			field.Set(reflect.ValueOf(durationVal))
+			return nil
+		}
+
+		intVal, err := key.Int64()
+		if err != nil {
+			return wrapStrictError(err, isStrict)
+		}
+		field.SetInt(intVal)
+	//	byte is an alias for uint8, so supporting uint8 breaks support for byte
+	case reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		durationVal, err := key.Duration()
+		// Skip zero value
+		if err == nil && int(durationVal) > 0 {
+			field.Set(reflect.ValueOf(durationVal))
+			return nil
+		}
+
+		uintVal, err := key.Uint64()
+		if err != nil {
+			return wrapStrictError(err, isStrict)
+		}
+		field.SetUint(uintVal)
+
+	case reflect.Float32, reflect.Float64:
+		floatVal, err := key.Float64()
+		if err != nil {
+			return wrapStrictError(err, isStrict)
+		}
+		field.SetFloat(floatVal)
+	case reflectTime:
+		timeVal, err := key.Time()
+		if err != nil {
+			return wrapStrictError(err, isStrict)
+		}
+		field.Set(reflect.ValueOf(timeVal))
+	case reflect.Slice:
+		return setSliceWithProperType(key, field, delim, allowShadow, isStrict)
+	default:
+		return fmt.Errorf("unsupported type '%s'", t)
+	}
+	return nil
+}
+
+func parseTagOptions(tag string) (rawName string, omitEmpty bool, allowShadow bool) {
+	opts := strings.SplitN(tag, ",", 3)
+	rawName = opts[0]
+	if len(opts) > 1 {
+		omitEmpty = opts[1] == "omitempty"
+	}
+	if len(opts) > 2 {
+		allowShadow = opts[2] == "allowshadow"
+	}
+	return rawName, omitEmpty, allowShadow
+}
+
+func (s *Section) mapTo(val reflect.Value, isStrict bool) error {
+	if val.Kind() == reflect.Ptr {
+		val = val.Elem()
+	}
+	typ := val.Type()
+
+	for i := 0; i < typ.NumField(); i++ {
+		field := val.Field(i)
+		tpField := typ.Field(i)
+
+		tag := tpField.Tag.Get("ini")
+		if tag == "-" {
+			continue
+		}
+
+		rawName, _, allowShadow := parseTagOptions(tag)
+		fieldName := s.parseFieldName(tpField.Name, rawName)
+		if len(fieldName) == 0 || !field.CanSet() {
+			continue
+		}
+
+		isAnonymous := tpField.Type.Kind() == reflect.Ptr && tpField.Anonymous
+		isStruct := tpField.Type.Kind() == reflect.Struct
+		if isAnonymous {
+			field.Set(reflect.New(tpField.Type.Elem()))
+		}
+
+		if isAnonymous || isStruct {
+			if sec, err := s.f.GetSection(fieldName); err == nil {
+				if err = sec.mapTo(field, isStrict); err != nil {
+					return fmt.Errorf("error mapping field(%s): %v", fieldName, err)
+				}
+				continue
+			}
+		}
+
+		if key, err := s.GetKey(fieldName); err == nil {
+			delim := parseDelim(tpField.Tag.Get("delim"))
+			if err = setWithProperType(tpField.Type, key, field, delim, allowShadow, isStrict); err != nil {
+				return fmt.Errorf("error mapping field(%s): %v", fieldName, err)
+			}
+		}
+	}
+	return nil
+}
+
+// MapTo maps section to given struct.
+func (s *Section) MapTo(v interface{}) error {
+	typ := reflect.TypeOf(v)
+	val := reflect.ValueOf(v)
+	if typ.Kind() == reflect.Ptr {
+		typ = typ.Elem()
+		val = val.Elem()
+	} else {
+		return errors.New("cannot map to non-pointer struct")
+	}
+
+	return s.mapTo(val, false)
+}
+
+// MapTo maps section to given struct in strict mode,
+// which returns all possible error including value parsing error.
+func (s *Section) StrictMapTo(v interface{}) error {
+	typ := reflect.TypeOf(v)
+	val := reflect.ValueOf(v)
+	if typ.Kind() == reflect.Ptr {
+		typ = typ.Elem()
+		val = val.Elem()
+	} else {
+		return errors.New("cannot map to non-pointer struct")
+	}
+
+	return s.mapTo(val, true)
+}
+
+// MapTo maps file to given struct.
+func (f *File) MapTo(v interface{}) error {
+	return f.Section("").MapTo(v)
+}
+
+// MapTo maps file to given struct in strict mode,
+// which returns all possible error including value parsing error.
+func (f *File) StrictMapTo(v interface{}) error {
+	return f.Section("").StrictMapTo(v)
+}
+
+// MapTo maps data sources to given struct with name mapper.
+func MapToWithMapper(v interface{}, mapper NameMapper, source interface{}, others ...interface{}) error {
+	cfg, err := Load(source, others...)
+	if err != nil {
+		return err
+	}
+	cfg.NameMapper = mapper
+	return cfg.MapTo(v)
+}
+
+// StrictMapToWithMapper maps data sources to given struct with name mapper in strict mode,
+// which returns all possible error including value parsing error.
+func StrictMapToWithMapper(v interface{}, mapper NameMapper, source interface{}, others ...interface{}) error {
+	cfg, err := Load(source, others...)
+	if err != nil {
+		return err
+	}
+	cfg.NameMapper = mapper
+	return cfg.StrictMapTo(v)
+}
+
+// MapTo maps data sources to given struct.
+func MapTo(v, source interface{}, others ...interface{}) error {
+	return MapToWithMapper(v, nil, source, others...)
+}
+
+// StrictMapTo maps data sources to given struct in strict mode,
+// which returns all possible error including value parsing error.
+func StrictMapTo(v, source interface{}, others ...interface{}) error {
+	return StrictMapToWithMapper(v, nil, source, others...)
+}
+
+// reflectSliceWithProperType does the opposite thing as setSliceWithProperType.
+func reflectSliceWithProperType(key *Key, field reflect.Value, delim string) error {
+	slice := field.Slice(0, field.Len())
+	if field.Len() == 0 {
+		return nil
+	}
+
+	var buf bytes.Buffer
+	sliceOf := field.Type().Elem().Kind()
+	for i := 0; i < field.Len(); i++ {
+		switch sliceOf {
+		case reflect.String:
+			buf.WriteString(slice.Index(i).String())
+		case reflect.Int, reflect.Int64:
+			buf.WriteString(fmt.Sprint(slice.Index(i).Int()))
+		case reflect.Uint, reflect.Uint64:
+			buf.WriteString(fmt.Sprint(slice.Index(i).Uint()))
+		case reflect.Float64:
+			buf.WriteString(fmt.Sprint(slice.Index(i).Float()))
+		case reflectTime:
+			buf.WriteString(slice.Index(i).Interface().(time.Time).Format(time.RFC3339))
+		default:
+			return fmt.Errorf("unsupported type '[]%s'", sliceOf)
+		}
+		buf.WriteString(delim)
+	}
+	key.SetValue(buf.String()[:buf.Len()-1])
+	return nil
+}
+
+// reflectWithProperType does the opposite thing as setWithProperType.
+func reflectWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string) error {
+	switch t.Kind() {
+	case reflect.String:
+		key.SetValue(field.String())
+	case reflect.Bool:
+		key.SetValue(fmt.Sprint(field.Bool()))
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		key.SetValue(fmt.Sprint(field.Int()))
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		key.SetValue(fmt.Sprint(field.Uint()))
+	case reflect.Float32, reflect.Float64:
+		key.SetValue(fmt.Sprint(field.Float()))
+	case reflectTime:
+		key.SetValue(fmt.Sprint(field.Interface().(time.Time).Format(time.RFC3339)))
+	case reflect.Slice:
+		return reflectSliceWithProperType(key, field, delim)
+	default:
+		return fmt.Errorf("unsupported type '%s'", t)
+	}
+	return nil
+}
+
+// CR: copied from encoding/json/encode.go with modifications of time.Time support.
+// TODO: add more test coverage.
+func isEmptyValue(v reflect.Value) bool {
+	switch v.Kind() {
+	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
+		return v.Len() == 0
+	case reflect.Bool:
+		return !v.Bool()
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		return v.Int() == 0
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
+		return v.Uint() == 0
+	case reflect.Float32, reflect.Float64:
+		return v.Float() == 0
+	case reflect.Interface, reflect.Ptr:
+		return v.IsNil()
+	case reflectTime:
+		t, ok := v.Interface().(time.Time)
+		return ok && t.IsZero()
+	}
+	return false
+}
+
+func (s *Section) reflectFrom(val reflect.Value) error {
+	if val.Kind() == reflect.Ptr {
+		val = val.Elem()
+	}
+	typ := val.Type()
+
+	for i := 0; i < typ.NumField(); i++ {
+		field := val.Field(i)
+		tpField := typ.Field(i)
+
+		tag := tpField.Tag.Get("ini")
+		if tag == "-" {
+			continue
+		}
+
+		opts := strings.SplitN(tag, ",", 2)
+		if len(opts) == 2 && opts[1] == "omitempty" && isEmptyValue(field) {
+			continue
+		}
+
+		fieldName := s.parseFieldName(tpField.Name, opts[0])
+		if len(fieldName) == 0 || !field.CanSet() {
+			continue
+		}
+
+		if (tpField.Type.Kind() == reflect.Ptr && tpField.Anonymous) ||
+			(tpField.Type.Kind() == reflect.Struct && tpField.Type.Name() != "Time") {
+			// Note: The only error here is section doesn't exist.
+			sec, err := s.f.GetSection(fieldName)
+			if err != nil {
+				// Note: fieldName can never be empty here, ignore error.
+				sec, _ = s.f.NewSection(fieldName)
+			}
+			if err = sec.reflectFrom(field); err != nil {
+				return fmt.Errorf("error reflecting field (%s): %v", fieldName, err)
+			}
+			continue
+		}
+
+		// Note: Same reason as secion.
+		key, err := s.GetKey(fieldName)
+		if err != nil {
+			key, _ = s.NewKey(fieldName, "")
+		}
+		if err = reflectWithProperType(tpField.Type, key, field, parseDelim(tpField.Tag.Get("delim"))); err != nil {
+			return fmt.Errorf("error reflecting field (%s): %v", fieldName, err)
+		}
+
+	}
+	return nil
+}
+
+// ReflectFrom reflects secion from given struct.
+func (s *Section) ReflectFrom(v interface{}) error {
+	typ := reflect.TypeOf(v)
+	val := reflect.ValueOf(v)
+	if typ.Kind() == reflect.Ptr {
+		typ = typ.Elem()
+		val = val.Elem()
+	} else {
+		return errors.New("cannot reflect from non-pointer struct")
+	}
+
+	return s.reflectFrom(val)
+}
+
+// ReflectFrom reflects file from given struct.
+func (f *File) ReflectFrom(v interface{}) error {
+	return f.Section("").ReflectFrom(v)
+}
+
+// ReflectFrom reflects data sources from given struct with name mapper.
+func ReflectFromWithMapper(cfg *File, v interface{}, mapper NameMapper) error {
+	cfg.NameMapper = mapper
+	return cfg.ReflectFrom(v)
+}
+
+// ReflectFrom reflects data sources from given struct.
+func ReflectFrom(cfg *File, v interface{}) error {
+	return ReflectFromWithMapper(cfg, v, nil)
+}
diff --git a/vendor/github.com/go-ini/ini/struct_test.go b/vendor/github.com/go-ini/ini/struct_test.go
new file mode 100644
index 00000000..b8ba2529
--- /dev/null
+++ b/vendor/github.com/go-ini/ini/struct_test.go
@@ -0,0 +1,352 @@
+// Copyright 2014 Unknwon
+//
+// Licensed under the Apache License, Version 2.0 (the "License"): you may
+// not use this file except in compliance with the License. You may obtain
+// a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+// License for the specific language governing permissions and limitations
+// under the License.
+
+package ini
+
+import (
+	"bytes"
+	"fmt"
+	"strings"
+	"testing"
+	"time"
+
+	. "github.com/smartystreets/goconvey/convey"
+)
+
+type testNested struct {
+	Cities      []string `delim:"|"`
+	Visits      []time.Time
+	Years       []int
+	Numbers     []int64
+	Ages        []uint
+	Populations []uint64
+	Coordinates []float64
+	Note        string
+	Unused      int `ini:"-"`
+}
+
+type testEmbeded struct {
+	GPA float64
+}
+
+type testStruct struct {
+	Name         string `ini:"NAME"`
+	Age          int
+	Male         bool
+	Money        float64
+	Born         time.Time
+	Time         time.Duration `ini:"Duration"`
+	Others       testNested
+	*testEmbeded `ini:"grade"`
+	Unused       int `ini:"-"`
+	Unsigned     uint
+	Omitted      bool     `ini:"omitthis,omitempty"`
+	Shadows      []string `ini:",,allowshadow"`
+	ShadowInts   []int    `ini:"Shadows,,allowshadow"`
+}
+
+const _CONF_DATA_STRUCT = `
+NAME = Unknwon
+Age = 21
+Male = true
+Money = 1.25
+Born = 1993-10-07T20:17:05Z
+Duration = 2h45m
+Unsigned = 3
+omitthis = true
+Shadows = 1, 2
+Shadows = 3, 4
+
+[Others]
+Cities = HangZhou|Boston
+Visits = 1993-10-07T20:17:05Z, 1993-10-07T20:17:05Z
+Years = 1993,1994
+Numbers = 10010,10086
+Ages = 18,19
+Populations = 12345678,98765432
+Coordinates = 192.168,10.11
+Note = Hello world!
+
+[grade]
+GPA = 2.8
+
+[foo.bar]
+Here = there
+When = then
+`
+
+type unsupport struct {
+	Byte byte
+}
+
+type unsupport2 struct {
+	Others struct {
+		Cities byte
+	}
+}
+
+type unsupport3 struct {
+	Cities byte
+}
+
+type unsupport4 struct {
+	*unsupport3 `ini:"Others"`
+}
+
+type defaultValue struct {
+	Name   string
+	Age    int
+	Male   bool
+	Money  float64
+	Born   time.Time
+	Cities []string
+}
+
+type fooBar struct {
+	Here, When string
+}
+
+const _INVALID_DATA_CONF_STRUCT = `
+Name = 
+Age = age
+Male = 123
+Money = money
+Born = nil
+Cities = 
+`
+
+func Test_Struct(t *testing.T) {
+	Convey("Map to struct", t, func() {
+		Convey("Map file to struct", func() {
+			ts := new(testStruct)
+			So(MapTo(ts, []byte(_CONF_DATA_STRUCT)), ShouldBeNil)
+
+			So(ts.Name, ShouldEqual, "Unknwon")
+			So(ts.Age, ShouldEqual, 21)
+			So(ts.Male, ShouldBeTrue)
+			So(ts.Money, ShouldEqual, 1.25)
+			So(ts.Unsigned, ShouldEqual, 3)
+
+			t, err := time.Parse(time.RFC3339, "1993-10-07T20:17:05Z")
+			So(err, ShouldBeNil)
+			So(ts.Born.String(), ShouldEqual, t.String())
+
+			dur, err := time.ParseDuration("2h45m")
+			So(err, ShouldBeNil)
+			So(ts.Time.Seconds(), ShouldEqual, dur.Seconds())
+
+			So(strings.Join(ts.Others.Cities, ","), ShouldEqual, "HangZhou,Boston")
+			So(ts.Others.Visits[0].String(), ShouldEqual, t.String())
+			So(fmt.Sprint(ts.Others.Years), ShouldEqual, "[1993 1994]")
+			So(fmt.Sprint(ts.Others.Numbers), ShouldEqual, "[10010 10086]")
+			So(fmt.Sprint(ts.Others.Ages), ShouldEqual, "[18 19]")
+			So(fmt.Sprint(ts.Others.Populations), ShouldEqual, "[12345678 98765432]")
+			So(fmt.Sprint(ts.Others.Coordinates), ShouldEqual, "[192.168 10.11]")
+			So(ts.Others.Note, ShouldEqual, "Hello world!")
+			So(ts.testEmbeded.GPA, ShouldEqual, 2.8)
+		})
+
+		Convey("Map section to struct", func() {
+			foobar := new(fooBar)
+			f, err := Load([]byte(_CONF_DATA_STRUCT))
+			So(err, ShouldBeNil)
+
+			So(f.Section("foo.bar").MapTo(foobar), ShouldBeNil)
+			So(foobar.Here, ShouldEqual, "there")
+			So(foobar.When, ShouldEqual, "then")
+		})
+
+		Convey("Map to non-pointer struct", func() {
+			cfg, err := Load([]byte(_CONF_DATA_STRUCT))
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+
+			So(cfg.MapTo(testStruct{}), ShouldNotBeNil)
+		})
+
+		Convey("Map to unsupported type", func() {
+			cfg, err := Load([]byte(_CONF_DATA_STRUCT))
+			So(err, ShouldBeNil)
+			So(cfg, ShouldNotBeNil)
+
+			cfg.NameMapper = func(raw string) string {
+				if raw == "Byte" {
+					return "NAME"
+				}
+				return raw
+			}
+			So(cfg.MapTo(&unsupport{}), ShouldNotBeNil)
+			So(cfg.MapTo(&unsupport2{}), ShouldNotBeNil)
+			So(cfg.MapTo(&unsupport4{}), ShouldNotBeNil)
+		})
+
+		Convey("Map to omitempty field", func() {
+			ts := new(testStruct)
+			So(MapTo(ts, []byte(_CONF_DATA_STRUCT)), ShouldBeNil)
+
+			So(ts.Omitted, ShouldEqual, true)
+		})
+
+		Convey("Map with shadows", func() {
+			cfg, err := LoadSources(LoadOptions{AllowShadows: true}, []byte(_CONF_DATA_STRUCT))
+			So(err, ShouldBeNil)
+			ts := new(testStruct)
+			So(cfg.MapTo(ts), ShouldBeNil)
+
+			So(strings.Join(ts.Shadows, " "), ShouldEqual, "1 2 3 4")
+			So(fmt.Sprintf("%v", ts.ShadowInts), ShouldEqual, "[1 2 3 4]")
+		})
+
+		Convey("Map from invalid data source", func() {
+			So(MapTo(&testStruct{}, "hi"), ShouldNotBeNil)
+		})
+
+		Convey("Map to wrong types and gain default values", func() {
+			cfg, err := Load([]byte(_INVALID_DATA_CONF_STRUCT))
+			So(err, ShouldBeNil)
+
+			t, err := time.Parse(time.RFC3339, "1993-10-07T20:17:05Z")
+			So(err, ShouldBeNil)
+			dv := &defaultValue{"Joe", 10, true, 1.25, t, []string{"HangZhou", "Boston"}}
+			So(cfg.MapTo(dv), ShouldBeNil)
+			So(dv.Name, ShouldEqual, "Joe")
+			So(dv.Age, ShouldEqual, 10)
+			So(dv.Male, ShouldBeTrue)
+			So(dv.Money, ShouldEqual, 1.25)
+			So(dv.Born.String(), ShouldEqual, t.String())
+			So(strings.Join(dv.Cities, ","), ShouldEqual, "HangZhou,Boston")
+		})
+	})
+
+	Convey("Map to struct in strict mode", t, func() {
+		cfg, err := Load([]byte(`
+name=bruce
+age=a30`))
+		So(err, ShouldBeNil)
+
+		type Strict struct {
+			Name string `ini:"name"`
+			Age  int    `ini:"age"`
+		}
+		s := new(Strict)
+
+		So(cfg.Section("").StrictMapTo(s), ShouldNotBeNil)
+	})
+
+	Convey("Reflect from struct", t, func() {
+		type Embeded struct {
+			Dates       []time.Time `delim:"|"`
+			Places      []string
+			Years       []int
+			Numbers     []int64
+			Ages        []uint
+			Populations []uint64
+			Coordinates []float64
+			None        []int
+		}
+		type Author struct {
+			Name      string `ini:"NAME"`
+			Male      bool
+			Age       int
+			Height    uint
+			GPA       float64
+			Date      time.Time
+			NeverMind string `ini:"-"`
+			*Embeded  `ini:"infos"`
+		}
+
+		t, err := time.Parse(time.RFC3339, "1993-10-07T20:17:05Z")
+		So(err, ShouldBeNil)
+		a := &Author{"Unknwon", true, 21, 100, 2.8, t, "",
+			&Embeded{
+				[]time.Time{t, t},
+				[]string{"HangZhou", "Boston"},
+				[]int{1993, 1994},
+				[]int64{10010, 10086},
+				[]uint{18, 19},
+				[]uint64{12345678, 98765432},
+				[]float64{192.168, 10.11},
+				[]int{},
+			}}
+		cfg := Empty()
+		So(ReflectFrom(cfg, a), ShouldBeNil)
+
+		var buf bytes.Buffer
+		_, err = cfg.WriteTo(&buf)
+		So(err, ShouldBeNil)
+		So(buf.String(), ShouldEqual, `NAME   = Unknwon
+Male   = true
+Age    = 21
+Height = 100
+GPA    = 2.8
+Date   = 1993-10-07T20:17:05Z
+
+[infos]
+Dates       = 1993-10-07T20:17:05Z|1993-10-07T20:17:05Z
+Places      = HangZhou,Boston
+Years       = 1993,1994
+Numbers     = 10010,10086
+Ages        = 18,19
+Populations = 12345678,98765432
+Coordinates = 192.168,10.11
+None        = 
+
+`)
+
+		Convey("Reflect from non-point struct", func() {
+			So(ReflectFrom(cfg, Author{}), ShouldNotBeNil)
+		})
+
+		Convey("Reflect from struct with omitempty", func() {
+			cfg := Empty()
+			type SpecialStruct struct {
+				FirstName  string    `ini:"first_name"`
+				LastName   string    `ini:"last_name"`
+				JustOmitMe string    `ini:"omitempty"`
+				LastLogin  time.Time `ini:"last_login,omitempty"`
+				LastLogin2 time.Time `ini:",omitempty"`
+				NotEmpty   int       `ini:"omitempty"`
+			}
+
+			So(ReflectFrom(cfg, &SpecialStruct{FirstName: "John", LastName: "Doe", NotEmpty: 9}), ShouldBeNil)
+
+			var buf bytes.Buffer
+			_, err = cfg.WriteTo(&buf)
+			So(buf.String(), ShouldEqual, `first_name = John
+last_name  = Doe
+omitempty  = 9
+
+`)
+		})
+	})
+}
+
+type testMapper struct {
+	PackageName string
+}
+
+func Test_NameGetter(t *testing.T) {
+	Convey("Test name mappers", t, func() {
+		So(MapToWithMapper(&testMapper{}, TitleUnderscore, []byte("packag_name=ini")), ShouldBeNil)
+
+		cfg, err := Load([]byte("PACKAGE_NAME=ini"))
+		So(err, ShouldBeNil)
+		So(cfg, ShouldNotBeNil)
+
+		cfg.NameMapper = AllCapsUnderscore
+		tg := new(testMapper)
+		So(cfg.MapTo(tg), ShouldBeNil)
+		So(tg.PackageName, ShouldEqual, "ini")
+	})
+}
diff --git a/vendor/github.com/Sirupsen/logrus/.gitignore b/vendor/github.com/sirupsen/logrus/.gitignore
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/.gitignore
rename to vendor/github.com/sirupsen/logrus/.gitignore
diff --git a/vendor/github.com/sirupsen/logrus/.travis.yml b/vendor/github.com/sirupsen/logrus/.travis.yml
new file mode 100644
index 00000000..a23296a5
--- /dev/null
+++ b/vendor/github.com/sirupsen/logrus/.travis.yml
@@ -0,0 +1,15 @@
+language: go
+go:
+  - 1.6.x
+  - 1.7.x
+  - 1.8.x
+  - tip
+env:
+  - GOMAXPROCS=4 GORACE=halt_on_error=1
+install:
+  - go get github.com/stretchr/testify/assert
+  - go get gopkg.in/gemnasium/logrus-airbrake-hook.v2
+  - go get golang.org/x/sys/unix
+  - go get golang.org/x/sys/windows
+script:
+  - go test -race -v ./...
diff --git a/vendor/github.com/Sirupsen/logrus/CHANGELOG.md b/vendor/github.com/sirupsen/logrus/CHANGELOG.md
similarity index 86%
rename from vendor/github.com/Sirupsen/logrus/CHANGELOG.md
rename to vendor/github.com/sirupsen/logrus/CHANGELOG.md
index 747e4d89..8236d8b6 100644
--- a/vendor/github.com/Sirupsen/logrus/CHANGELOG.md
+++ b/vendor/github.com/sirupsen/logrus/CHANGELOG.md
@@ -1,3 +1,22 @@
+# 1.0.3
+
+* Replace example files with testable examples
+
+# 1.0.2
+
+* bug: quote non-string values in text formatter (#583)
+* Make (*Logger) SetLevel a public method
+
+# 1.0.1
+
+* bug: fix escaping in text formatter (#575)
+
+# 1.0.0
+
+* Officially changed name to lower-case
+* bug: colors on Windows 10 (#541)
+* bug: fix race in accessing level (#512)
+
 # 0.11.5
 
 * feature: add writer and writerlevel to entry (#372)
diff --git a/vendor/github.com/Sirupsen/logrus/LICENSE b/vendor/github.com/sirupsen/logrus/LICENSE
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/LICENSE
rename to vendor/github.com/sirupsen/logrus/LICENSE
diff --git a/vendor/github.com/Sirupsen/logrus/README.md b/vendor/github.com/sirupsen/logrus/README.md
similarity index 89%
rename from vendor/github.com/Sirupsen/logrus/README.md
rename to vendor/github.com/sirupsen/logrus/README.md
index 46dda859..5f656c3e 100644
--- a/vendor/github.com/Sirupsen/logrus/README.md
+++ b/vendor/github.com/sirupsen/logrus/README.md
@@ -1,17 +1,24 @@
-# Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:"/>&nbsp;[![Build Status](https://travis-ci.org/Sirupsen/logrus.svg?branch=master)](https://travis-ci.org/Sirupsen/logrus)&nbsp;[![GoDoc](https://godoc.org/github.com/Sirupsen/logrus?status.svg)](https://godoc.org/github.com/Sirupsen/logrus)
-
-**Seeing weird case-sensitive problems?** See [this
-issue](https://github.com/sirupsen/logrus/issues/451#issuecomment-264332021).
-This change has been reverted. I apologize for causing this. I greatly
-underestimated the impact this would have. Logrus strives for stability and
-backwards compatibility and failed to provide that.
+# Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:"/>&nbsp;[![Build Status](https://travis-ci.org/sirupsen/logrus.svg?branch=master)](https://travis-ci.org/sirupsen/logrus)&nbsp;[![GoDoc](https://godoc.org/github.com/sirupsen/logrus?status.svg)](https://godoc.org/github.com/sirupsen/logrus)
 
 Logrus is a structured logger for Go (golang), completely API compatible with
-the standard library logger. [Godoc][godoc]. **Please note the Logrus API is not
-yet stable (pre 1.0). Logrus itself is completely stable and has been used in
-many large deployments. The core API is unlikely to change much but please
-version control your Logrus to make sure you aren't fetching latest `master` on
-every build.**
+the standard library logger.
+
+**Seeing weird case-sensitive problems?** It's in the past been possible to
+import Logrus as both upper- and lower-case. Due to the Go package environment,
+this caused issues in the community and we needed a standard. Some environments
+experienced problems with the upper-case variant, so the lower-case was decided.
+Everything using `logrus` will need to use the lower-case:
+`github.com/sirupsen/logrus`. Any package that isn't, should be changed.
+
+To fix Glide, see [these
+comments](https://github.com/sirupsen/logrus/issues/553#issuecomment-306591437).
+For an in-depth explanation of the casing issue, see [this
+comment](https://github.com/sirupsen/logrus/issues/570#issuecomment-313933276).
+
+**Are you interested in assisting in maintaining Logrus?** Currently I have a
+lot of obligations, and I am unable to provide Logrus with the maintainership it
+needs. If you'd like to help, please reach out to me at `simon at author's
+username dot com`.
 
 Nicely color-coded in development (when a TTY is attached, otherwise just
 plain text):
@@ -165,7 +172,7 @@ func main() {
 
 #### Fields
 
-Logrus encourages careful, structured logging though logging fields instead of
+Logrus encourages careful, structured logging through logging fields instead of
 long, unparseable error messages. For example, instead of: `log.Fatalf("Failed
 to send event %s to topic %s with key %d")`, you should log the much more
 discoverable:
@@ -240,6 +247,7 @@ Note: Syslog hook also support connecting to local syslog (Ex. "/dev/log" or "/v
 | [Airbrake](https://github.com/gemnasium/logrus-airbrake-hook) | Send errors to the Airbrake API V3. Uses the official [`gobrake`](https://github.com/airbrake/gobrake) behind the scenes. |
 | [Amazon Kinesis](https://github.com/evalphobia/logrus_kinesis) | Hook for logging to [Amazon Kinesis](https://aws.amazon.com/kinesis/) |
 | [Amqp-Hook](https://github.com/vladoatanasov/logrus_amqp) | Hook for logging to Amqp broker (Like RabbitMQ) |
+| [AzureTableHook](https://github.com/kpfaulkner/azuretablehook/) | Hook for logging to Azure Table Storage|
 | [Bugsnag](https://github.com/Shopify/logrus-bugsnag/blob/master/bugsnag.go) | Send errors to the Bugsnag exception tracking service. |
 | [DeferPanic](https://github.com/deferpanic/dp-logrus) | Hook for logging to DeferPanic |
 | [Discordrus](https://github.com/kz/discordrus) | Hook for logging to [Discord](https://discordapp.com/) |
@@ -253,7 +261,7 @@ Note: Syslog hook also support connecting to local syslog (Ex. "/dev/log" or "/v
 | [InfluxDB](https://github.com/Abramovic/logrus_influxdb) | Hook for logging to influxdb |
 | [Influxus](http://github.com/vlad-doru/influxus) | Hook for concurrently logging to [InfluxDB](http://influxdata.com/) |
 | [Journalhook](https://github.com/wercker/journalhook) | Hook for logging to `systemd-journald` |
-| [KafkaLogrus](https://github.com/goibibo/KafkaLogrus) | Hook for logging to kafka |
+| [KafkaLogrus](https://github.com/tracer0tong/kafkalogrus) | Hook for logging to Kafka |
 | [LFShook](https://github.com/rifflock/lfshook) | Hook for logging to the local filesystem |
 | [Logentries](https://github.com/jcftang/logentriesrus) | Hook for logging to [Logentries](https://logentries.com/) |
 | [Logentrus](https://github.com/puddingfactory/logentrus) | Hook for logging to [Logentries](https://logentries.com/) |
@@ -261,6 +269,7 @@ Note: Syslog hook also support connecting to local syslog (Ex. "/dev/log" or "/v
 | [Logrusly](https://github.com/sebest/logrusly) | Send logs to [Loggly](https://www.loggly.com/) |
 | [Logstash](https://github.com/bshuster-repo/logrus-logstash-hook) | Hook for logging to [Logstash](https://www.elastic.co/products/logstash) |
 | [Mail](https://github.com/zbindenren/logrus_mail) | Hook for sending exceptions via mail |
+| [Mattermost](https://github.com/shuLhan/mattermost-integration/tree/master/hooks/logrus) | Hook for logging to [Mattermost](https://mattermost.com/) |
 | [Mongodb](https://github.com/weekface/mgorus) | Hook for logging to mongodb |
 | [NATS-Hook](https://github.com/rybit/nats_logrus_hook) | Hook for logging to [NATS](https://nats.io) |
 | [Octokit](https://github.com/dorajistyle/logrus-octokit-hook) | Hook for logging to github via octokit |
@@ -275,10 +284,13 @@ Note: Syslog hook also support connecting to local syslog (Ex. "/dev/log" or "/v
 | [Slackrus](https://github.com/johntdyer/slackrus) | Hook for Slack chat. |
 | [Stackdriver](https://github.com/knq/sdhook) | Hook for logging to [Google Stackdriver](https://cloud.google.com/logging/) |
 | [Sumorus](https://github.com/doublefree/sumorus) | Hook for logging to [SumoLogic](https://www.sumologic.com/)|
-| [Syslog](https://github.com/Sirupsen/logrus/blob/master/hooks/syslog/syslog.go) | Send errors to remote syslog server. Uses standard library `log/syslog` behind the scenes. |
+| [Syslog](https://github.com/sirupsen/logrus/blob/master/hooks/syslog/syslog.go) | Send errors to remote syslog server. Uses standard library `log/syslog` behind the scenes. |
+| [Syslog TLS](https://github.com/shinji62/logrus-syslog-ng) | Send errors to remote syslog server with TLS support. |
+| [Telegram](https://github.com/rossmcdonald/telegram_hook) | Hook for logging errors to [Telegram](https://telegram.org/) |
 | [TraceView](https://github.com/evalphobia/logrus_appneta) | Hook for logging to [AppNeta TraceView](https://www.appneta.com/products/traceview/) |
 | [Typetalk](https://github.com/dragon3/logrus-typetalk-hook) | Hook for logging to [Typetalk](https://www.typetalk.in/) |
 | [logz.io](https://github.com/ripcurld00d/logrus-logzio-hook) | Hook for logging to [logz.io](https://logz.io), a Log as a Service using Logstash |
+| [SQS-Hook](https://github.com/tsarpaul/logrus_sqs) | Hook for logging to [Amazon Simple Queue Service (SQS)](https://aws.amazon.com/sqs/) |
 
 #### Level logging
 
@@ -362,6 +374,7 @@ The built-in logging formatters are:
 
 Third party logging formatters:
 
+* [`FluentdFormatter`](https://github.com/joonix/log). Formats entries that can by parsed by Kubernetes and Google Container Engine.
 * [`logstash`](https://github.com/bshuster-repo/logrus-logstash-hook). Logs fields as [Logstash](http://logstash.net) Events.
 * [`prefixed`](https://github.com/x-cray/logrus-prefixed-formatter). Displays log entry source along with alternative layout.
 * [`zalgo`](https://github.com/aybabtme/logzalgo). Invoking the P͉̫o̳̼̊w̖͈̰͎e̬͔̭͂r͚̼̹̲ ̫͓͉̳͈ō̠͕͖̚f̝͍̠ ͕̲̞͖͑Z̖̫̤̫ͪa͉̬͈̗l͖͎g̳̥o̰̥̅!̣͔̲̻͊̄ ̙̘̦̹̦.
@@ -442,13 +455,13 @@ Logrus has a built in facility for asserting the presence of log messages. This
 ```go
 import(
   "github.com/sirupsen/logrus"
-  "github.com/sirupsen/logrus/hooks/null"
+  "github.com/sirupsen/logrus/hooks/test"
   "github.com/stretchr/testify/assert"
   "testing"
 )
 
 func TestSomething(t*testing.T){
-  logger, hook := null.NewNullLogger()
+  logger, hook := test.NewNullLogger()
   logger.Error("Helloerror")
 
   assert.Equal(t, 1, len(hook.Entries))
diff --git a/vendor/github.com/Sirupsen/logrus/alt_exit.go b/vendor/github.com/sirupsen/logrus/alt_exit.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/alt_exit.go
rename to vendor/github.com/sirupsen/logrus/alt_exit.go
diff --git a/vendor/github.com/Sirupsen/logrus/alt_exit_test.go b/vendor/github.com/sirupsen/logrus/alt_exit_test.go
similarity index 63%
rename from vendor/github.com/Sirupsen/logrus/alt_exit_test.go
rename to vendor/github.com/sirupsen/logrus/alt_exit_test.go
index 022b7783..a08b1a89 100644
--- a/vendor/github.com/Sirupsen/logrus/alt_exit_test.go
+++ b/vendor/github.com/sirupsen/logrus/alt_exit_test.go
@@ -2,7 +2,10 @@ package logrus
 
 import (
 	"io/ioutil"
+	"log"
+	"os"
 	"os/exec"
+	"path/filepath"
 	"testing"
 	"time"
 )
@@ -11,30 +14,36 @@ func TestRegister(t *testing.T) {
 	current := len(handlers)
 	RegisterExitHandler(func() {})
 	if len(handlers) != current+1 {
-		t.Fatalf("can't add handler")
+		t.Fatalf("expected %d handlers, got %d", current+1, len(handlers))
 	}
 }
 
 func TestHandler(t *testing.T) {
-	gofile := "/tmp/testprog.go"
+	tempDir, err := ioutil.TempDir("", "test_handler")
+	if err != nil {
+		log.Fatalf("can't create temp dir. %q", err)
+	}
+	defer os.RemoveAll(tempDir)
+
+	gofile := filepath.Join(tempDir, "gofile.go")
 	if err := ioutil.WriteFile(gofile, testprog, 0666); err != nil {
-		t.Fatalf("can't create go file")
+		t.Fatalf("can't create go file. %q", err)
 	}
 
-	outfile := "/tmp/testprog.out"
+	outfile := filepath.Join(tempDir, "outfile.out")
 	arg := time.Now().UTC().String()
-	err := exec.Command("go", "run", gofile, outfile, arg).Run()
+	err = exec.Command("go", "run", gofile, outfile, arg).Run()
 	if err == nil {
 		t.Fatalf("completed normally, should have failed")
 	}
 
 	data, err := ioutil.ReadFile(outfile)
 	if err != nil {
-		t.Fatalf("can't read output file %s", outfile)
+		t.Fatalf("can't read output file %s. %q", outfile, err)
 	}
 
 	if string(data) != arg {
-		t.Fatalf("bad data")
+		t.Fatalf("bad data. Expected %q, got %q", data, arg)
 	}
 }
 
@@ -44,7 +53,7 @@ var testprog = []byte(`
 package main
 
 import (
-	"github.com/Sirupsen/logrus"
+	"github.com/sirupsen/logrus"
 	"flag"
 	"fmt"
 	"io/ioutil"
diff --git a/vendor/github.com/sirupsen/logrus/appveyor.yml b/vendor/github.com/sirupsen/logrus/appveyor.yml
new file mode 100644
index 00000000..96c2ce15
--- /dev/null
+++ b/vendor/github.com/sirupsen/logrus/appveyor.yml
@@ -0,0 +1,14 @@
+version: "{build}"
+platform: x64
+clone_folder: c:\gopath\src\github.com\sirupsen\logrus
+environment:  
+  GOPATH: c:\gopath
+branches:  
+  only:
+    - master
+install:  
+  - set PATH=%GOPATH%\bin;c:\go\bin;%PATH%
+  - go version
+build_script:  
+  - go get -t
+  - go test
diff --git a/vendor/github.com/Sirupsen/logrus/doc.go b/vendor/github.com/sirupsen/logrus/doc.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/doc.go
rename to vendor/github.com/sirupsen/logrus/doc.go
diff --git a/vendor/github.com/Sirupsen/logrus/entry.go b/vendor/github.com/sirupsen/logrus/entry.go
similarity index 96%
rename from vendor/github.com/Sirupsen/logrus/entry.go
rename to vendor/github.com/sirupsen/logrus/entry.go
index 320e5d5b..1fad45e0 100644
--- a/vendor/github.com/Sirupsen/logrus/entry.go
+++ b/vendor/github.com/sirupsen/logrus/entry.go
@@ -35,6 +35,7 @@ type Entry struct {
 	Time time.Time
 
 	// Level the log entry was logged at: Debug, Info, Warn, Error, Fatal or Panic
+	// This field will be set on entry firing and the value will be equal to the one in Logger struct field.
 	Level Level
 
 	// Message passed to Debug, Info, Warn, Error, Fatal or Panic
@@ -93,7 +94,10 @@ func (entry Entry) log(level Level, msg string) {
 	entry.Level = level
 	entry.Message = msg
 
-	if err := entry.Logger.Hooks.Fire(level, &entry); err != nil {
+	entry.Logger.mu.Lock()
+	err := entry.Logger.Hooks.Fire(level, &entry)
+	entry.Logger.mu.Unlock()
+	if err != nil {
 		entry.Logger.mu.Lock()
 		fmt.Fprintf(os.Stderr, "Failed to fire hook: %v\n", err)
 		entry.Logger.mu.Unlock()
diff --git a/vendor/github.com/Sirupsen/logrus/entry_test.go b/vendor/github.com/sirupsen/logrus/entry_test.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/entry_test.go
rename to vendor/github.com/sirupsen/logrus/entry_test.go
diff --git a/vendor/github.com/sirupsen/logrus/example_basic_test.go b/vendor/github.com/sirupsen/logrus/example_basic_test.go
new file mode 100644
index 00000000..a2acf550
--- /dev/null
+++ b/vendor/github.com/sirupsen/logrus/example_basic_test.go
@@ -0,0 +1,69 @@
+package logrus_test
+
+import (
+	"github.com/sirupsen/logrus"
+	"os"
+)
+
+func Example_basic() {
+	var log = logrus.New()
+	log.Formatter = new(logrus.JSONFormatter)
+	log.Formatter = new(logrus.TextFormatter)                     //default
+	log.Formatter.(*logrus.TextFormatter).DisableTimestamp = true // remove timestamp from test output
+	log.Level = logrus.DebugLevel
+	log.Out = os.Stdout
+
+	// file, err := os.OpenFile("logrus.log", os.O_CREATE|os.O_WRONLY, 0666)
+	// if err == nil {
+	// 	log.Out = file
+	// } else {
+	// 	log.Info("Failed to log to file, using default stderr")
+	// }
+
+	defer func() {
+		err := recover()
+		if err != nil {
+			entry := err.(*logrus.Entry)
+			log.WithFields(logrus.Fields{
+				"omg":         true,
+				"err_animal":  entry.Data["animal"],
+				"err_size":    entry.Data["size"],
+				"err_level":   entry.Level,
+				"err_message": entry.Message,
+				"number":      100,
+			}).Error("The ice breaks!") // or use Fatal() to force the process to exit with a nonzero code
+		}
+	}()
+
+	log.WithFields(logrus.Fields{
+		"animal": "walrus",
+		"number": 8,
+	}).Debug("Started observing beach")
+
+	log.WithFields(logrus.Fields{
+		"animal": "walrus",
+		"size":   10,
+	}).Info("A group of walrus emerges from the ocean")
+
+	log.WithFields(logrus.Fields{
+		"omg":    true,
+		"number": 122,
+	}).Warn("The group's number increased tremendously!")
+
+	log.WithFields(logrus.Fields{
+		"temperature": -4,
+	}).Debug("Temperature changes")
+
+	log.WithFields(logrus.Fields{
+		"animal": "orca",
+		"size":   9009,
+	}).Panic("It's over 9000!")
+
+	// Output:
+	// level=debug msg="Started observing beach" animal=walrus number=8
+	// level=info msg="A group of walrus emerges from the ocean" animal=walrus size=10
+	// level=warning msg="The group's number increased tremendously!" number=122 omg=true
+	// level=debug msg="Temperature changes" temperature=-4
+	// level=panic msg="It's over 9000!" animal=orca size=9009
+	// level=error msg="The ice breaks!" err_animal=orca err_level=panic err_message="It's over 9000!" err_size=9009 number=100 omg=true
+}
diff --git a/vendor/github.com/sirupsen/logrus/example_hook_test.go b/vendor/github.com/sirupsen/logrus/example_hook_test.go
new file mode 100644
index 00000000..d4ddffca
--- /dev/null
+++ b/vendor/github.com/sirupsen/logrus/example_hook_test.go
@@ -0,0 +1,35 @@
+package logrus_test
+
+import (
+	"github.com/sirupsen/logrus"
+	"gopkg.in/gemnasium/logrus-airbrake-hook.v2"
+	"os"
+)
+
+func Example_hook() {
+	var log = logrus.New()
+	log.Formatter = new(logrus.TextFormatter)                     // default
+	log.Formatter.(*logrus.TextFormatter).DisableTimestamp = true // remove timestamp from test output
+	log.Hooks.Add(airbrake.NewHook(123, "xyz", "development"))
+	log.Out = os.Stdout
+
+	log.WithFields(logrus.Fields{
+		"animal": "walrus",
+		"size":   10,
+	}).Info("A group of walrus emerges from the ocean")
+
+	log.WithFields(logrus.Fields{
+		"omg":    true,
+		"number": 122,
+	}).Warn("The group's number increased tremendously!")
+
+	log.WithFields(logrus.Fields{
+		"omg":    true,
+		"number": 100,
+	}).Error("The ice breaks!")
+
+	// Output:
+	// level=info msg="A group of walrus emerges from the ocean" animal=walrus size=10
+	// level=warning msg="The group's number increased tremendously!" number=122 omg=true
+	// level=error msg="The ice breaks!" number=100 omg=true
+}
diff --git a/vendor/github.com/Sirupsen/logrus/exported.go b/vendor/github.com/sirupsen/logrus/exported.go
similarity index 99%
rename from vendor/github.com/Sirupsen/logrus/exported.go
rename to vendor/github.com/sirupsen/logrus/exported.go
index 1aeaa90b..013183ed 100644
--- a/vendor/github.com/Sirupsen/logrus/exported.go
+++ b/vendor/github.com/sirupsen/logrus/exported.go
@@ -31,7 +31,7 @@ func SetFormatter(formatter Formatter) {
 func SetLevel(level Level) {
 	std.mu.Lock()
 	defer std.mu.Unlock()
-	std.setLevel(level)
+	std.SetLevel(level)
 }
 
 // GetLevel returns the standard logger level.
diff --git a/vendor/github.com/Sirupsen/logrus/formatter.go b/vendor/github.com/sirupsen/logrus/formatter.go
similarity index 96%
rename from vendor/github.com/Sirupsen/logrus/formatter.go
rename to vendor/github.com/sirupsen/logrus/formatter.go
index b5fbe934..b183ff5b 100644
--- a/vendor/github.com/Sirupsen/logrus/formatter.go
+++ b/vendor/github.com/sirupsen/logrus/formatter.go
@@ -2,7 +2,7 @@ package logrus
 
 import "time"
 
-const DefaultTimestampFormat = time.RFC3339
+const defaultTimestampFormat = time.RFC3339
 
 // The Formatter interface is used to implement a custom Formatter. It takes an
 // `Entry`. It exposes all the fields, including the default ones:
diff --git a/vendor/github.com/Sirupsen/logrus/formatter_bench_test.go b/vendor/github.com/sirupsen/logrus/formatter_bench_test.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/formatter_bench_test.go
rename to vendor/github.com/sirupsen/logrus/formatter_bench_test.go
diff --git a/vendor/github.com/Sirupsen/logrus/hook_test.go b/vendor/github.com/sirupsen/logrus/hook_test.go
similarity index 83%
rename from vendor/github.com/Sirupsen/logrus/hook_test.go
rename to vendor/github.com/sirupsen/logrus/hook_test.go
index 13f34cb6..4fea7514 100644
--- a/vendor/github.com/Sirupsen/logrus/hook_test.go
+++ b/vendor/github.com/sirupsen/logrus/hook_test.go
@@ -1,6 +1,7 @@
 package logrus
 
 import (
+	"sync"
 	"testing"
 
 	"github.com/stretchr/testify/assert"
@@ -120,3 +121,24 @@ func TestErrorHookShouldFireOnError(t *testing.T) {
 		assert.Equal(t, hook.Fired, true)
 	})
 }
+
+func TestAddHookRace(t *testing.T) {
+	var wg sync.WaitGroup
+	wg.Add(2)
+	hook := new(ErrorHook)
+	LogAndAssertJSON(t, func(log *Logger) {
+		go func() {
+			defer wg.Done()
+			log.AddHook(hook)
+		}()
+		go func() {
+			defer wg.Done()
+			log.Error("test")
+		}()
+		wg.Wait()
+	}, func(fields Fields) {
+		// the line may have been logged
+		// before the hook was added, so we can't
+		// actually assert on the hook
+	})
+}
diff --git a/vendor/github.com/Sirupsen/logrus/hooks.go b/vendor/github.com/sirupsen/logrus/hooks.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/hooks.go
rename to vendor/github.com/sirupsen/logrus/hooks.go
diff --git a/vendor/github.com/Sirupsen/logrus/json_formatter.go b/vendor/github.com/sirupsen/logrus/json_formatter.go
similarity index 82%
rename from vendor/github.com/Sirupsen/logrus/json_formatter.go
rename to vendor/github.com/sirupsen/logrus/json_formatter.go
index e787ea17..fb01c1b1 100644
--- a/vendor/github.com/Sirupsen/logrus/json_formatter.go
+++ b/vendor/github.com/sirupsen/logrus/json_formatter.go
@@ -6,8 +6,11 @@ import (
 )
 
 type fieldKey string
+
+// FieldMap allows customization of the key names for default fields.
 type FieldMap map[fieldKey]string
 
+// Default key names for the default fields
 const (
 	FieldKeyMsg   = "msg"
 	FieldKeyLevel = "level"
@@ -22,6 +25,7 @@ func (f FieldMap) resolve(key fieldKey) string {
 	return string(key)
 }
 
+// JSONFormatter formats logs into parsable json
 type JSONFormatter struct {
 	// TimestampFormat sets the format used for marshaling timestamps.
 	TimestampFormat string
@@ -29,7 +33,7 @@ type JSONFormatter struct {
 	// DisableTimestamp allows disabling automatic timestamps in output
 	DisableTimestamp bool
 
-	// FieldMap allows users to customize the names of keys for various fields.
+	// FieldMap allows users to customize the names of keys for default fields.
 	// As an example:
 	// formatter := &JSONFormatter{
 	//   	FieldMap: FieldMap{
@@ -41,6 +45,7 @@ type JSONFormatter struct {
 	FieldMap FieldMap
 }
 
+// Format renders a single log entry
 func (f *JSONFormatter) Format(entry *Entry) ([]byte, error) {
 	data := make(Fields, len(entry.Data)+3)
 	for k, v := range entry.Data {
@@ -57,7 +62,7 @@ func (f *JSONFormatter) Format(entry *Entry) ([]byte, error) {
 
 	timestampFormat := f.TimestampFormat
 	if timestampFormat == "" {
-		timestampFormat = DefaultTimestampFormat
+		timestampFormat = defaultTimestampFormat
 	}
 
 	if !f.DisableTimestamp {
diff --git a/vendor/github.com/Sirupsen/logrus/json_formatter_test.go b/vendor/github.com/sirupsen/logrus/json_formatter_test.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/json_formatter_test.go
rename to vendor/github.com/sirupsen/logrus/json_formatter_test.go
diff --git a/vendor/github.com/Sirupsen/logrus/logger.go b/vendor/github.com/sirupsen/logrus/logger.go
similarity index 97%
rename from vendor/github.com/Sirupsen/logrus/logger.go
rename to vendor/github.com/sirupsen/logrus/logger.go
index 370fff5d..fdaf8a65 100644
--- a/vendor/github.com/Sirupsen/logrus/logger.go
+++ b/vendor/github.com/sirupsen/logrus/logger.go
@@ -25,7 +25,7 @@ type Logger struct {
 	Formatter Formatter
 	// The logging level the logger should log at. This is typically (and defaults
 	// to) `logrus.Info`, which allows Info(), Warn(), Error() and Fatal() to be
-	// logged. `logrus.Debug` is useful in
+	// logged.
 	Level Level
 	// Used to sync writing to the log. Locking is enabled by Default
 	mu MutexWrap
@@ -312,6 +312,12 @@ func (logger *Logger) level() Level {
 	return Level(atomic.LoadUint32((*uint32)(&logger.Level)))
 }
 
-func (logger *Logger) setLevel(level Level) {
+func (logger *Logger) SetLevel(level Level) {
 	atomic.StoreUint32((*uint32)(&logger.Level), uint32(level))
 }
+
+func (logger *Logger) AddHook(hook Hook) {
+	logger.mu.Lock()
+	defer logger.mu.Unlock()
+	logger.Hooks.Add(hook)
+}
diff --git a/vendor/github.com/Sirupsen/logrus/logger_bench_test.go b/vendor/github.com/sirupsen/logrus/logger_bench_test.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/logger_bench_test.go
rename to vendor/github.com/sirupsen/logrus/logger_bench_test.go
diff --git a/vendor/github.com/Sirupsen/logrus/logrus.go b/vendor/github.com/sirupsen/logrus/logrus.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/logrus.go
rename to vendor/github.com/sirupsen/logrus/logrus.go
diff --git a/vendor/github.com/Sirupsen/logrus/logrus_test.go b/vendor/github.com/sirupsen/logrus/logrus_test.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/logrus_test.go
rename to vendor/github.com/sirupsen/logrus/logrus_test.go
diff --git a/vendor/github.com/sirupsen/logrus/terminal_bsd.go b/vendor/github.com/sirupsen/logrus/terminal_bsd.go
new file mode 100644
index 00000000..d7b3893f
--- /dev/null
+++ b/vendor/github.com/sirupsen/logrus/terminal_bsd.go
@@ -0,0 +1,10 @@
+// +build darwin freebsd openbsd netbsd dragonfly
+// +build !appengine
+
+package logrus
+
+import "golang.org/x/sys/unix"
+
+const ioctlReadTermios = unix.TIOCGETA
+
+type Termios unix.Termios
diff --git a/vendor/github.com/Sirupsen/logrus/terminal_linux.go b/vendor/github.com/sirupsen/logrus/terminal_linux.go
similarity index 70%
rename from vendor/github.com/Sirupsen/logrus/terminal_linux.go
rename to vendor/github.com/sirupsen/logrus/terminal_linux.go
index 308160ca..88d7298e 100644
--- a/vendor/github.com/Sirupsen/logrus/terminal_linux.go
+++ b/vendor/github.com/sirupsen/logrus/terminal_linux.go
@@ -7,8 +7,8 @@
 
 package logrus
 
-import "syscall"
+import "golang.org/x/sys/unix"
 
-const ioctlReadTermios = syscall.TCGETS
+const ioctlReadTermios = unix.TCGETS
 
-type Termios syscall.Termios
+type Termios unix.Termios
diff --git a/vendor/github.com/Sirupsen/logrus/text_formatter.go b/vendor/github.com/sirupsen/logrus/text_formatter.go
similarity index 82%
rename from vendor/github.com/Sirupsen/logrus/text_formatter.go
rename to vendor/github.com/sirupsen/logrus/text_formatter.go
index ba888540..be412aa9 100644
--- a/vendor/github.com/Sirupsen/logrus/text_formatter.go
+++ b/vendor/github.com/sirupsen/logrus/text_formatter.go
@@ -3,10 +3,14 @@ package logrus
 import (
 	"bytes"
 	"fmt"
+	"io"
+	"os"
 	"sort"
 	"strings"
 	"sync"
 	"time"
+
+	"golang.org/x/crypto/ssh/terminal"
 )
 
 const (
@@ -14,7 +18,7 @@ const (
 	red     = 31
 	green   = 32
 	yellow  = 33
-	blue    = 34
+	blue    = 36
 	gray    = 37
 )
 
@@ -26,6 +30,7 @@ func init() {
 	baseTimestamp = time.Now()
 }
 
+// TextFormatter formats logs into text
 type TextFormatter struct {
 	// Set to true to bypass checking for a TTY before outputting colors.
 	ForceColors bool
@@ -52,10 +57,6 @@ type TextFormatter struct {
 	// QuoteEmptyFields will wrap empty fields in quotes if true
 	QuoteEmptyFields bool
 
-	// QuoteCharacter can be set to the override the default quoting character "
-	// with something else. For example: ', or `.
-	QuoteCharacter string
-
 	// Whether the logger's out is to a terminal
 	isTerminal bool
 
@@ -63,14 +64,21 @@ type TextFormatter struct {
 }
 
 func (f *TextFormatter) init(entry *Entry) {
-	if len(f.QuoteCharacter) == 0 {
-		f.QuoteCharacter = "\""
-	}
 	if entry.Logger != nil {
-		f.isTerminal = IsTerminal(entry.Logger.Out)
+		f.isTerminal = f.checkIfTerminal(entry.Logger.Out)
+	}
+}
+
+func (f *TextFormatter) checkIfTerminal(w io.Writer) bool {
+	switch v := w.(type) {
+	case *os.File:
+		return terminal.IsTerminal(int(v.Fd()))
+	default:
+		return false
 	}
 }
 
+// Format renders a single log entry
 func (f *TextFormatter) Format(entry *Entry) ([]byte, error) {
 	var b *bytes.Buffer
 	keys := make([]string, 0, len(entry.Data))
@@ -95,7 +103,7 @@ func (f *TextFormatter) Format(entry *Entry) ([]byte, error) {
 
 	timestampFormat := f.TimestampFormat
 	if timestampFormat == "" {
-		timestampFormat = DefaultTimestampFormat
+		timestampFormat = defaultTimestampFormat
 	}
 	if isColored {
 		f.printColored(b, entry, keys, timestampFormat)
@@ -153,7 +161,7 @@ func (f *TextFormatter) needsQuoting(text string) bool {
 		if !((ch >= 'a' && ch <= 'z') ||
 			(ch >= 'A' && ch <= 'Z') ||
 			(ch >= '0' && ch <= '9') ||
-			ch == '-' || ch == '.') {
+			ch == '-' || ch == '.' || ch == '_' || ch == '/' || ch == '@' || ch == '^' || ch == '+') {
 			return true
 		}
 	}
@@ -161,29 +169,23 @@ func (f *TextFormatter) needsQuoting(text string) bool {
 }
 
 func (f *TextFormatter) appendKeyValue(b *bytes.Buffer, key string, value interface{}) {
-
+	if b.Len() > 0 {
+		b.WriteByte(' ')
+	}
 	b.WriteString(key)
 	b.WriteByte('=')
 	f.appendValue(b, value)
-	b.WriteByte(' ')
 }
 
 func (f *TextFormatter) appendValue(b *bytes.Buffer, value interface{}) {
-	switch value := value.(type) {
-	case string:
-		if !f.needsQuoting(value) {
-			b.WriteString(value)
-		} else {
-			fmt.Fprintf(b, "%s%v%s", f.QuoteCharacter, value, f.QuoteCharacter)
-		}
-	case error:
-		errmsg := value.Error()
-		if !f.needsQuoting(errmsg) {
-			b.WriteString(errmsg)
-		} else {
-			fmt.Fprintf(b, "%s%v%s", f.QuoteCharacter, errmsg, f.QuoteCharacter)
-		}
-	default:
-		fmt.Fprint(b, value)
+	stringVal, ok := value.(string)
+	if !ok {
+		stringVal = fmt.Sprint(value)
+	}
+
+	if !f.needsQuoting(stringVal) {
+		b.WriteString(stringVal)
+	} else {
+		b.WriteString(fmt.Sprintf("%q", stringVal))
 	}
 }
diff --git a/vendor/github.com/Sirupsen/logrus/text_formatter_test.go b/vendor/github.com/sirupsen/logrus/text_formatter_test.go
similarity index 52%
rename from vendor/github.com/Sirupsen/logrus/text_formatter_test.go
rename to vendor/github.com/sirupsen/logrus/text_formatter_test.go
index 9793b5f3..d93b931e 100644
--- a/vendor/github.com/Sirupsen/logrus/text_formatter_test.go
+++ b/vendor/github.com/sirupsen/logrus/text_formatter_test.go
@@ -3,18 +3,38 @@ package logrus
 import (
 	"bytes"
 	"errors"
+	"fmt"
 	"strings"
 	"testing"
 	"time"
 )
 
+func TestFormatting(t *testing.T) {
+	tf := &TextFormatter{DisableColors: true}
+
+	testCases := []struct {
+		value    string
+		expected string
+	}{
+		{`foo`, "time=\"0001-01-01T00:00:00Z\" level=panic test=foo\n"},
+	}
+
+	for _, tc := range testCases {
+		b, _ := tf.Format(WithField("test", tc.value))
+
+		if string(b) != tc.expected {
+			t.Errorf("formatting expected for %q (result was %q instead of %q)", tc.value, string(b), tc.expected)
+		}
+	}
+}
+
 func TestQuoting(t *testing.T) {
 	tf := &TextFormatter{DisableColors: true}
 
 	checkQuoting := func(q bool, value interface{}) {
 		b, _ := tf.Format(WithField("test", value))
 		idx := bytes.Index(b, ([]byte)("test="))
-		cont := bytes.Contains(b[idx+5:], []byte(tf.QuoteCharacter))
+		cont := bytes.Contains(b[idx+5:], []byte("\""))
 		if cont != q {
 			if q {
 				t.Errorf("quoting expected for: %#v", value)
@@ -28,24 +48,18 @@ func TestQuoting(t *testing.T) {
 	checkQuoting(false, "abcd")
 	checkQuoting(false, "v1.0")
 	checkQuoting(false, "1234567890")
-	checkQuoting(true, "/foobar")
+	checkQuoting(false, "/foobar")
+	checkQuoting(false, "foo_bar")
+	checkQuoting(false, "foo@bar")
+	checkQuoting(false, "foobar^")
+	checkQuoting(false, "+/-_^@f.oobar")
+	checkQuoting(true, "foobar$")
+	checkQuoting(true, "&foobar")
 	checkQuoting(true, "x y")
 	checkQuoting(true, "x,y")
 	checkQuoting(false, errors.New("invalid"))
 	checkQuoting(true, errors.New("invalid argument"))
 
-	// Test for custom quote character.
-	tf.QuoteCharacter = "`"
-	checkQuoting(false, "")
-	checkQuoting(false, "abcd")
-	checkQuoting(true, "/foobar")
-	checkQuoting(true, errors.New("invalid argument"))
-
-	// Test for multi-character quotes.
-	tf.QuoteCharacter = "§~±"
-	checkQuoting(false, "abcd")
-	checkQuoting(true, errors.New("invalid argument"))
-
 	// Test for quoting empty fields.
 	tf.QuoteEmptyFields = true
 	checkQuoting(true, "")
@@ -53,13 +67,53 @@ func TestQuoting(t *testing.T) {
 	checkQuoting(true, errors.New("invalid argument"))
 }
 
+func TestEscaping(t *testing.T) {
+	tf := &TextFormatter{DisableColors: true}
+
+	testCases := []struct {
+		value    string
+		expected string
+	}{
+		{`ba"r`, `ba\"r`},
+		{`ba'r`, `ba'r`},
+	}
+
+	for _, tc := range testCases {
+		b, _ := tf.Format(WithField("test", tc.value))
+		if !bytes.Contains(b, []byte(tc.expected)) {
+			t.Errorf("escaping expected for %q (result was %q instead of %q)", tc.value, string(b), tc.expected)
+		}
+	}
+}
+
+func TestEscaping_Interface(t *testing.T) {
+	tf := &TextFormatter{DisableColors: true}
+
+	ts := time.Now()
+
+	testCases := []struct {
+		value    interface{}
+		expected string
+	}{
+		{ts, fmt.Sprintf("\"%s\"", ts.String())},
+		{errors.New("error: something went wrong"), "\"error: something went wrong\""},
+	}
+
+	for _, tc := range testCases {
+		b, _ := tf.Format(WithField("test", tc.value))
+		if !bytes.Contains(b, []byte(tc.expected)) {
+			t.Errorf("escaping expected for %q (result was %q instead of %q)", tc.value, string(b), tc.expected)
+		}
+	}
+}
+
 func TestTimestampFormat(t *testing.T) {
 	checkTimeStr := func(format string) {
 		customFormatter := &TextFormatter{DisableColors: true, TimestampFormat: format}
 		customStr, _ := customFormatter.Format(WithField("test", "test"))
 		timeStart := bytes.Index(customStr, ([]byte)("time="))
 		timeEnd := bytes.Index(customStr, ([]byte)("level="))
-		timeStr := customStr[timeStart+5+len(customFormatter.QuoteCharacter) : timeEnd-1-len(customFormatter.QuoteCharacter)]
+		timeStr := customStr[timeStart+5+len("\"") : timeEnd-1-len("\"")]
 		if format == "" {
 			format = time.RFC3339
 		}
diff --git a/vendor/github.com/Sirupsen/logrus/writer.go b/vendor/github.com/sirupsen/logrus/writer.go
similarity index 100%
rename from vendor/github.com/Sirupsen/logrus/writer.go
rename to vendor/github.com/sirupsen/logrus/writer.go
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/terminal.go b/vendor/golang.org/x/crypto/ssh/terminal/terminal.go
new file mode 100644
index 00000000..18379a93
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/terminal.go
@@ -0,0 +1,951 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package terminal
+
+import (
+	"bytes"
+	"io"
+	"sync"
+	"unicode/utf8"
+)
+
+// EscapeCodes contains escape sequences that can be written to the terminal in
+// order to achieve different styles of text.
+type EscapeCodes struct {
+	// Foreground colors
+	Black, Red, Green, Yellow, Blue, Magenta, Cyan, White []byte
+
+	// Reset all attributes
+	Reset []byte
+}
+
+var vt100EscapeCodes = EscapeCodes{
+	Black:   []byte{keyEscape, '[', '3', '0', 'm'},
+	Red:     []byte{keyEscape, '[', '3', '1', 'm'},
+	Green:   []byte{keyEscape, '[', '3', '2', 'm'},
+	Yellow:  []byte{keyEscape, '[', '3', '3', 'm'},
+	Blue:    []byte{keyEscape, '[', '3', '4', 'm'},
+	Magenta: []byte{keyEscape, '[', '3', '5', 'm'},
+	Cyan:    []byte{keyEscape, '[', '3', '6', 'm'},
+	White:   []byte{keyEscape, '[', '3', '7', 'm'},
+
+	Reset: []byte{keyEscape, '[', '0', 'm'},
+}
+
+// Terminal contains the state for running a VT100 terminal that is capable of
+// reading lines of input.
+type Terminal struct {
+	// AutoCompleteCallback, if non-null, is called for each keypress with
+	// the full input line and the current position of the cursor (in
+	// bytes, as an index into |line|). If it returns ok=false, the key
+	// press is processed normally. Otherwise it returns a replacement line
+	// and the new cursor position.
+	AutoCompleteCallback func(line string, pos int, key rune) (newLine string, newPos int, ok bool)
+
+	// Escape contains a pointer to the escape codes for this terminal.
+	// It's always a valid pointer, although the escape codes themselves
+	// may be empty if the terminal doesn't support them.
+	Escape *EscapeCodes
+
+	// lock protects the terminal and the state in this object from
+	// concurrent processing of a key press and a Write() call.
+	lock sync.Mutex
+
+	c      io.ReadWriter
+	prompt []rune
+
+	// line is the current line being entered.
+	line []rune
+	// pos is the logical position of the cursor in line
+	pos int
+	// echo is true if local echo is enabled
+	echo bool
+	// pasteActive is true iff there is a bracketed paste operation in
+	// progress.
+	pasteActive bool
+
+	// cursorX contains the current X value of the cursor where the left
+	// edge is 0. cursorY contains the row number where the first row of
+	// the current line is 0.
+	cursorX, cursorY int
+	// maxLine is the greatest value of cursorY so far.
+	maxLine int
+
+	termWidth, termHeight int
+
+	// outBuf contains the terminal data to be sent.
+	outBuf []byte
+	// remainder contains the remainder of any partial key sequences after
+	// a read. It aliases into inBuf.
+	remainder []byte
+	inBuf     [256]byte
+
+	// history contains previously entered commands so that they can be
+	// accessed with the up and down keys.
+	history stRingBuffer
+	// historyIndex stores the currently accessed history entry, where zero
+	// means the immediately previous entry.
+	historyIndex int
+	// When navigating up and down the history it's possible to return to
+	// the incomplete, initial line. That value is stored in
+	// historyPending.
+	historyPending string
+}
+
+// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is
+// a local terminal, that terminal must first have been put into raw mode.
+// prompt is a string that is written at the start of each input line (i.e.
+// "> ").
+func NewTerminal(c io.ReadWriter, prompt string) *Terminal {
+	return &Terminal{
+		Escape:       &vt100EscapeCodes,
+		c:            c,
+		prompt:       []rune(prompt),
+		termWidth:    80,
+		termHeight:   24,
+		echo:         true,
+		historyIndex: -1,
+	}
+}
+
+const (
+	keyCtrlD     = 4
+	keyCtrlU     = 21
+	keyEnter     = '\r'
+	keyEscape    = 27
+	keyBackspace = 127
+	keyUnknown   = 0xd800 /* UTF-16 surrogate area */ + iota
+	keyUp
+	keyDown
+	keyLeft
+	keyRight
+	keyAltLeft
+	keyAltRight
+	keyHome
+	keyEnd
+	keyDeleteWord
+	keyDeleteLine
+	keyClearScreen
+	keyPasteStart
+	keyPasteEnd
+)
+
+var (
+	crlf       = []byte{'\r', '\n'}
+	pasteStart = []byte{keyEscape, '[', '2', '0', '0', '~'}
+	pasteEnd   = []byte{keyEscape, '[', '2', '0', '1', '~'}
+)
+
+// bytesToKey tries to parse a key sequence from b. If successful, it returns
+// the key and the remainder of the input. Otherwise it returns utf8.RuneError.
+func bytesToKey(b []byte, pasteActive bool) (rune, []byte) {
+	if len(b) == 0 {
+		return utf8.RuneError, nil
+	}
+
+	if !pasteActive {
+		switch b[0] {
+		case 1: // ^A
+			return keyHome, b[1:]
+		case 5: // ^E
+			return keyEnd, b[1:]
+		case 8: // ^H
+			return keyBackspace, b[1:]
+		case 11: // ^K
+			return keyDeleteLine, b[1:]
+		case 12: // ^L
+			return keyClearScreen, b[1:]
+		case 23: // ^W
+			return keyDeleteWord, b[1:]
+		}
+	}
+
+	if b[0] != keyEscape {
+		if !utf8.FullRune(b) {
+			return utf8.RuneError, b
+		}
+		r, l := utf8.DecodeRune(b)
+		return r, b[l:]
+	}
+
+	if !pasteActive && len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {
+		switch b[2] {
+		case 'A':
+			return keyUp, b[3:]
+		case 'B':
+			return keyDown, b[3:]
+		case 'C':
+			return keyRight, b[3:]
+		case 'D':
+			return keyLeft, b[3:]
+		case 'H':
+			return keyHome, b[3:]
+		case 'F':
+			return keyEnd, b[3:]
+		}
+	}
+
+	if !pasteActive && len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {
+		switch b[5] {
+		case 'C':
+			return keyAltRight, b[6:]
+		case 'D':
+			return keyAltLeft, b[6:]
+		}
+	}
+
+	if !pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteStart) {
+		return keyPasteStart, b[6:]
+	}
+
+	if pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteEnd) {
+		return keyPasteEnd, b[6:]
+	}
+
+	// If we get here then we have a key that we don't recognise, or a
+	// partial sequence. It's not clear how one should find the end of a
+	// sequence without knowing them all, but it seems that [a-zA-Z~] only
+	// appears at the end of a sequence.
+	for i, c := range b[0:] {
+		if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '~' {
+			return keyUnknown, b[i+1:]
+		}
+	}
+
+	return utf8.RuneError, b
+}
+
+// queue appends data to the end of t.outBuf
+func (t *Terminal) queue(data []rune) {
+	t.outBuf = append(t.outBuf, []byte(string(data))...)
+}
+
+var eraseUnderCursor = []rune{' ', keyEscape, '[', 'D'}
+var space = []rune{' '}
+
+func isPrintable(key rune) bool {
+	isInSurrogateArea := key >= 0xd800 && key <= 0xdbff
+	return key >= 32 && !isInSurrogateArea
+}
+
+// moveCursorToPos appends data to t.outBuf which will move the cursor to the
+// given, logical position in the text.
+func (t *Terminal) moveCursorToPos(pos int) {
+	if !t.echo {
+		return
+	}
+
+	x := visualLength(t.prompt) + pos
+	y := x / t.termWidth
+	x = x % t.termWidth
+
+	up := 0
+	if y < t.cursorY {
+		up = t.cursorY - y
+	}
+
+	down := 0
+	if y > t.cursorY {
+		down = y - t.cursorY
+	}
+
+	left := 0
+	if x < t.cursorX {
+		left = t.cursorX - x
+	}
+
+	right := 0
+	if x > t.cursorX {
+		right = x - t.cursorX
+	}
+
+	t.cursorX = x
+	t.cursorY = y
+	t.move(up, down, left, right)
+}
+
+func (t *Terminal) move(up, down, left, right int) {
+	movement := make([]rune, 3*(up+down+left+right))
+	m := movement
+	for i := 0; i < up; i++ {
+		m[0] = keyEscape
+		m[1] = '['
+		m[2] = 'A'
+		m = m[3:]
+	}
+	for i := 0; i < down; i++ {
+		m[0] = keyEscape
+		m[1] = '['
+		m[2] = 'B'
+		m = m[3:]
+	}
+	for i := 0; i < left; i++ {
+		m[0] = keyEscape
+		m[1] = '['
+		m[2] = 'D'
+		m = m[3:]
+	}
+	for i := 0; i < right; i++ {
+		m[0] = keyEscape
+		m[1] = '['
+		m[2] = 'C'
+		m = m[3:]
+	}
+
+	t.queue(movement)
+}
+
+func (t *Terminal) clearLineToRight() {
+	op := []rune{keyEscape, '[', 'K'}
+	t.queue(op)
+}
+
+const maxLineLength = 4096
+
+func (t *Terminal) setLine(newLine []rune, newPos int) {
+	if t.echo {
+		t.moveCursorToPos(0)
+		t.writeLine(newLine)
+		for i := len(newLine); i < len(t.line); i++ {
+			t.writeLine(space)
+		}
+		t.moveCursorToPos(newPos)
+	}
+	t.line = newLine
+	t.pos = newPos
+}
+
+func (t *Terminal) advanceCursor(places int) {
+	t.cursorX += places
+	t.cursorY += t.cursorX / t.termWidth
+	if t.cursorY > t.maxLine {
+		t.maxLine = t.cursorY
+	}
+	t.cursorX = t.cursorX % t.termWidth
+
+	if places > 0 && t.cursorX == 0 {
+		// Normally terminals will advance the current position
+		// when writing a character. But that doesn't happen
+		// for the last character in a line. However, when
+		// writing a character (except a new line) that causes
+		// a line wrap, the position will be advanced two
+		// places.
+		//
+		// So, if we are stopping at the end of a line, we
+		// need to write a newline so that our cursor can be
+		// advanced to the next line.
+		t.outBuf = append(t.outBuf, '\r', '\n')
+	}
+}
+
+func (t *Terminal) eraseNPreviousChars(n int) {
+	if n == 0 {
+		return
+	}
+
+	if t.pos < n {
+		n = t.pos
+	}
+	t.pos -= n
+	t.moveCursorToPos(t.pos)
+
+	copy(t.line[t.pos:], t.line[n+t.pos:])
+	t.line = t.line[:len(t.line)-n]
+	if t.echo {
+		t.writeLine(t.line[t.pos:])
+		for i := 0; i < n; i++ {
+			t.queue(space)
+		}
+		t.advanceCursor(n)
+		t.moveCursorToPos(t.pos)
+	}
+}
+
+// countToLeftWord returns then number of characters from the cursor to the
+// start of the previous word.
+func (t *Terminal) countToLeftWord() int {
+	if t.pos == 0 {
+		return 0
+	}
+
+	pos := t.pos - 1
+	for pos > 0 {
+		if t.line[pos] != ' ' {
+			break
+		}
+		pos--
+	}
+	for pos > 0 {
+		if t.line[pos] == ' ' {
+			pos++
+			break
+		}
+		pos--
+	}
+
+	return t.pos - pos
+}
+
+// countToRightWord returns then number of characters from the cursor to the
+// start of the next word.
+func (t *Terminal) countToRightWord() int {
+	pos := t.pos
+	for pos < len(t.line) {
+		if t.line[pos] == ' ' {
+			break
+		}
+		pos++
+	}
+	for pos < len(t.line) {
+		if t.line[pos] != ' ' {
+			break
+		}
+		pos++
+	}
+	return pos - t.pos
+}
+
+// visualLength returns the number of visible glyphs in s.
+func visualLength(runes []rune) int {
+	inEscapeSeq := false
+	length := 0
+
+	for _, r := range runes {
+		switch {
+		case inEscapeSeq:
+			if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') {
+				inEscapeSeq = false
+			}
+		case r == '\x1b':
+			inEscapeSeq = true
+		default:
+			length++
+		}
+	}
+
+	return length
+}
+
+// handleKey processes the given key and, optionally, returns a line of text
+// that the user has entered.
+func (t *Terminal) handleKey(key rune) (line string, ok bool) {
+	if t.pasteActive && key != keyEnter {
+		t.addKeyToLine(key)
+		return
+	}
+
+	switch key {
+	case keyBackspace:
+		if t.pos == 0 {
+			return
+		}
+		t.eraseNPreviousChars(1)
+	case keyAltLeft:
+		// move left by a word.
+		t.pos -= t.countToLeftWord()
+		t.moveCursorToPos(t.pos)
+	case keyAltRight:
+		// move right by a word.
+		t.pos += t.countToRightWord()
+		t.moveCursorToPos(t.pos)
+	case keyLeft:
+		if t.pos == 0 {
+			return
+		}
+		t.pos--
+		t.moveCursorToPos(t.pos)
+	case keyRight:
+		if t.pos == len(t.line) {
+			return
+		}
+		t.pos++
+		t.moveCursorToPos(t.pos)
+	case keyHome:
+		if t.pos == 0 {
+			return
+		}
+		t.pos = 0
+		t.moveCursorToPos(t.pos)
+	case keyEnd:
+		if t.pos == len(t.line) {
+			return
+		}
+		t.pos = len(t.line)
+		t.moveCursorToPos(t.pos)
+	case keyUp:
+		entry, ok := t.history.NthPreviousEntry(t.historyIndex + 1)
+		if !ok {
+			return "", false
+		}
+		if t.historyIndex == -1 {
+			t.historyPending = string(t.line)
+		}
+		t.historyIndex++
+		runes := []rune(entry)
+		t.setLine(runes, len(runes))
+	case keyDown:
+		switch t.historyIndex {
+		case -1:
+			return
+		case 0:
+			runes := []rune(t.historyPending)
+			t.setLine(runes, len(runes))
+			t.historyIndex--
+		default:
+			entry, ok := t.history.NthPreviousEntry(t.historyIndex - 1)
+			if ok {
+				t.historyIndex--
+				runes := []rune(entry)
+				t.setLine(runes, len(runes))
+			}
+		}
+	case keyEnter:
+		t.moveCursorToPos(len(t.line))
+		t.queue([]rune("\r\n"))
+		line = string(t.line)
+		ok = true
+		t.line = t.line[:0]
+		t.pos = 0
+		t.cursorX = 0
+		t.cursorY = 0
+		t.maxLine = 0
+	case keyDeleteWord:
+		// Delete zero or more spaces and then one or more characters.
+		t.eraseNPreviousChars(t.countToLeftWord())
+	case keyDeleteLine:
+		// Delete everything from the current cursor position to the
+		// end of line.
+		for i := t.pos; i < len(t.line); i++ {
+			t.queue(space)
+			t.advanceCursor(1)
+		}
+		t.line = t.line[:t.pos]
+		t.moveCursorToPos(t.pos)
+	case keyCtrlD:
+		// Erase the character under the current position.
+		// The EOF case when the line is empty is handled in
+		// readLine().
+		if t.pos < len(t.line) {
+			t.pos++
+			t.eraseNPreviousChars(1)
+		}
+	case keyCtrlU:
+		t.eraseNPreviousChars(t.pos)
+	case keyClearScreen:
+		// Erases the screen and moves the cursor to the home position.
+		t.queue([]rune("\x1b[2J\x1b[H"))
+		t.queue(t.prompt)
+		t.cursorX, t.cursorY = 0, 0
+		t.advanceCursor(visualLength(t.prompt))
+		t.setLine(t.line, t.pos)
+	default:
+		if t.AutoCompleteCallback != nil {
+			prefix := string(t.line[:t.pos])
+			suffix := string(t.line[t.pos:])
+
+			t.lock.Unlock()
+			newLine, newPos, completeOk := t.AutoCompleteCallback(prefix+suffix, len(prefix), key)
+			t.lock.Lock()
+
+			if completeOk {
+				t.setLine([]rune(newLine), utf8.RuneCount([]byte(newLine)[:newPos]))
+				return
+			}
+		}
+		if !isPrintable(key) {
+			return
+		}
+		if len(t.line) == maxLineLength {
+			return
+		}
+		t.addKeyToLine(key)
+	}
+	return
+}
+
+// addKeyToLine inserts the given key at the current position in the current
+// line.
+func (t *Terminal) addKeyToLine(key rune) {
+	if len(t.line) == cap(t.line) {
+		newLine := make([]rune, len(t.line), 2*(1+len(t.line)))
+		copy(newLine, t.line)
+		t.line = newLine
+	}
+	t.line = t.line[:len(t.line)+1]
+	copy(t.line[t.pos+1:], t.line[t.pos:])
+	t.line[t.pos] = key
+	if t.echo {
+		t.writeLine(t.line[t.pos:])
+	}
+	t.pos++
+	t.moveCursorToPos(t.pos)
+}
+
+func (t *Terminal) writeLine(line []rune) {
+	for len(line) != 0 {
+		remainingOnLine := t.termWidth - t.cursorX
+		todo := len(line)
+		if todo > remainingOnLine {
+			todo = remainingOnLine
+		}
+		t.queue(line[:todo])
+		t.advanceCursor(visualLength(line[:todo]))
+		line = line[todo:]
+	}
+}
+
+// writeWithCRLF writes buf to w but replaces all occurrences of \n with \r\n.
+func writeWithCRLF(w io.Writer, buf []byte) (n int, err error) {
+	for len(buf) > 0 {
+		i := bytes.IndexByte(buf, '\n')
+		todo := len(buf)
+		if i >= 0 {
+			todo = i
+		}
+
+		var nn int
+		nn, err = w.Write(buf[:todo])
+		n += nn
+		if err != nil {
+			return n, err
+		}
+		buf = buf[todo:]
+
+		if i >= 0 {
+			if _, err = w.Write(crlf); err != nil {
+				return n, err
+			}
+			n += 1
+			buf = buf[1:]
+		}
+	}
+
+	return n, nil
+}
+
+func (t *Terminal) Write(buf []byte) (n int, err error) {
+	t.lock.Lock()
+	defer t.lock.Unlock()
+
+	if t.cursorX == 0 && t.cursorY == 0 {
+		// This is the easy case: there's nothing on the screen that we
+		// have to move out of the way.
+		return writeWithCRLF(t.c, buf)
+	}
+
+	// We have a prompt and possibly user input on the screen. We
+	// have to clear it first.
+	t.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)
+	t.cursorX = 0
+	t.clearLineToRight()
+
+	for t.cursorY > 0 {
+		t.move(1 /* up */, 0, 0, 0)
+		t.cursorY--
+		t.clearLineToRight()
+	}
+
+	if _, err = t.c.Write(t.outBuf); err != nil {
+		return
+	}
+	t.outBuf = t.outBuf[:0]
+
+	if n, err = writeWithCRLF(t.c, buf); err != nil {
+		return
+	}
+
+	t.writeLine(t.prompt)
+	if t.echo {
+		t.writeLine(t.line)
+	}
+
+	t.moveCursorToPos(t.pos)
+
+	if _, err = t.c.Write(t.outBuf); err != nil {
+		return
+	}
+	t.outBuf = t.outBuf[:0]
+	return
+}
+
+// ReadPassword temporarily changes the prompt and reads a password, without
+// echo, from the terminal.
+func (t *Terminal) ReadPassword(prompt string) (line string, err error) {
+	t.lock.Lock()
+	defer t.lock.Unlock()
+
+	oldPrompt := t.prompt
+	t.prompt = []rune(prompt)
+	t.echo = false
+
+	line, err = t.readLine()
+
+	t.prompt = oldPrompt
+	t.echo = true
+
+	return
+}
+
+// ReadLine returns a line of input from the terminal.
+func (t *Terminal) ReadLine() (line string, err error) {
+	t.lock.Lock()
+	defer t.lock.Unlock()
+
+	return t.readLine()
+}
+
+func (t *Terminal) readLine() (line string, err error) {
+	// t.lock must be held at this point
+
+	if t.cursorX == 0 && t.cursorY == 0 {
+		t.writeLine(t.prompt)
+		t.c.Write(t.outBuf)
+		t.outBuf = t.outBuf[:0]
+	}
+
+	lineIsPasted := t.pasteActive
+
+	for {
+		rest := t.remainder
+		lineOk := false
+		for !lineOk {
+			var key rune
+			key, rest = bytesToKey(rest, t.pasteActive)
+			if key == utf8.RuneError {
+				break
+			}
+			if !t.pasteActive {
+				if key == keyCtrlD {
+					if len(t.line) == 0 {
+						return "", io.EOF
+					}
+				}
+				if key == keyPasteStart {
+					t.pasteActive = true
+					if len(t.line) == 0 {
+						lineIsPasted = true
+					}
+					continue
+				}
+			} else if key == keyPasteEnd {
+				t.pasteActive = false
+				continue
+			}
+			if !t.pasteActive {
+				lineIsPasted = false
+			}
+			line, lineOk = t.handleKey(key)
+		}
+		if len(rest) > 0 {
+			n := copy(t.inBuf[:], rest)
+			t.remainder = t.inBuf[:n]
+		} else {
+			t.remainder = nil
+		}
+		t.c.Write(t.outBuf)
+		t.outBuf = t.outBuf[:0]
+		if lineOk {
+			if t.echo {
+				t.historyIndex = -1
+				t.history.Add(line)
+			}
+			if lineIsPasted {
+				err = ErrPasteIndicator
+			}
+			return
+		}
+
+		// t.remainder is a slice at the beginning of t.inBuf
+		// containing a partial key sequence
+		readBuf := t.inBuf[len(t.remainder):]
+		var n int
+
+		t.lock.Unlock()
+		n, err = t.c.Read(readBuf)
+		t.lock.Lock()
+
+		if err != nil {
+			return
+		}
+
+		t.remainder = t.inBuf[:n+len(t.remainder)]
+	}
+}
+
+// SetPrompt sets the prompt to be used when reading subsequent lines.
+func (t *Terminal) SetPrompt(prompt string) {
+	t.lock.Lock()
+	defer t.lock.Unlock()
+
+	t.prompt = []rune(prompt)
+}
+
+func (t *Terminal) clearAndRepaintLinePlusNPrevious(numPrevLines int) {
+	// Move cursor to column zero at the start of the line.
+	t.move(t.cursorY, 0, t.cursorX, 0)
+	t.cursorX, t.cursorY = 0, 0
+	t.clearLineToRight()
+	for t.cursorY < numPrevLines {
+		// Move down a line
+		t.move(0, 1, 0, 0)
+		t.cursorY++
+		t.clearLineToRight()
+	}
+	// Move back to beginning.
+	t.move(t.cursorY, 0, 0, 0)
+	t.cursorX, t.cursorY = 0, 0
+
+	t.queue(t.prompt)
+	t.advanceCursor(visualLength(t.prompt))
+	t.writeLine(t.line)
+	t.moveCursorToPos(t.pos)
+}
+
+func (t *Terminal) SetSize(width, height int) error {
+	t.lock.Lock()
+	defer t.lock.Unlock()
+
+	if width == 0 {
+		width = 1
+	}
+
+	oldWidth := t.termWidth
+	t.termWidth, t.termHeight = width, height
+
+	switch {
+	case width == oldWidth:
+		// If the width didn't change then nothing else needs to be
+		// done.
+		return nil
+	case len(t.line) == 0 && t.cursorX == 0 && t.cursorY == 0:
+		// If there is nothing on current line and no prompt printed,
+		// just do nothing
+		return nil
+	case width < oldWidth:
+		// Some terminals (e.g. xterm) will truncate lines that were
+		// too long when shinking. Others, (e.g. gnome-terminal) will
+		// attempt to wrap them. For the former, repainting t.maxLine
+		// works great, but that behaviour goes badly wrong in the case
+		// of the latter because they have doubled every full line.
+
+		// We assume that we are working on a terminal that wraps lines
+		// and adjust the cursor position based on every previous line
+		// wrapping and turning into two. This causes the prompt on
+		// xterms to move upwards, which isn't great, but it avoids a
+		// huge mess with gnome-terminal.
+		if t.cursorX >= t.termWidth {
+			t.cursorX = t.termWidth - 1
+		}
+		t.cursorY *= 2
+		t.clearAndRepaintLinePlusNPrevious(t.maxLine * 2)
+	case width > oldWidth:
+		// If the terminal expands then our position calculations will
+		// be wrong in the future because we think the cursor is
+		// |t.pos| chars into the string, but there will be a gap at
+		// the end of any wrapped line.
+		//
+		// But the position will actually be correct until we move, so
+		// we can move back to the beginning and repaint everything.
+		t.clearAndRepaintLinePlusNPrevious(t.maxLine)
+	}
+
+	_, err := t.c.Write(t.outBuf)
+	t.outBuf = t.outBuf[:0]
+	return err
+}
+
+type pasteIndicatorError struct{}
+
+func (pasteIndicatorError) Error() string {
+	return "terminal: ErrPasteIndicator not correctly handled"
+}
+
+// ErrPasteIndicator may be returned from ReadLine as the error, in addition
+// to valid line data. It indicates that bracketed paste mode is enabled and
+// that the returned line consists only of pasted data. Programs may wish to
+// interpret pasted data more literally than typed data.
+var ErrPasteIndicator = pasteIndicatorError{}
+
+// SetBracketedPasteMode requests that the terminal bracket paste operations
+// with markers. Not all terminals support this but, if it is supported, then
+// enabling this mode will stop any autocomplete callback from running due to
+// pastes. Additionally, any lines that are completely pasted will be returned
+// from ReadLine with the error set to ErrPasteIndicator.
+func (t *Terminal) SetBracketedPasteMode(on bool) {
+	if on {
+		io.WriteString(t.c, "\x1b[?2004h")
+	} else {
+		io.WriteString(t.c, "\x1b[?2004l")
+	}
+}
+
+// stRingBuffer is a ring buffer of strings.
+type stRingBuffer struct {
+	// entries contains max elements.
+	entries []string
+	max     int
+	// head contains the index of the element most recently added to the ring.
+	head int
+	// size contains the number of elements in the ring.
+	size int
+}
+
+func (s *stRingBuffer) Add(a string) {
+	if s.entries == nil {
+		const defaultNumEntries = 100
+		s.entries = make([]string, defaultNumEntries)
+		s.max = defaultNumEntries
+	}
+
+	s.head = (s.head + 1) % s.max
+	s.entries[s.head] = a
+	if s.size < s.max {
+		s.size++
+	}
+}
+
+// NthPreviousEntry returns the value passed to the nth previous call to Add.
+// If n is zero then the immediately prior value is returned, if one, then the
+// next most recent, and so on. If such an element doesn't exist then ok is
+// false.
+func (s *stRingBuffer) NthPreviousEntry(n int) (value string, ok bool) {
+	if n >= s.size {
+		return "", false
+	}
+	index := s.head - n
+	if index < 0 {
+		index += s.max
+	}
+	return s.entries[index], true
+}
+
+// readPasswordLine reads from reader until it finds \n or io.EOF.
+// The slice returned does not include the \n.
+// readPasswordLine also ignores any \r it finds.
+func readPasswordLine(reader io.Reader) ([]byte, error) {
+	var buf [1]byte
+	var ret []byte
+
+	for {
+		n, err := reader.Read(buf[:])
+		if n > 0 {
+			switch buf[0] {
+			case '\n':
+				return ret, nil
+			case '\r':
+				// remove \r from passwords on Windows
+			default:
+				ret = append(ret, buf[0])
+			}
+			continue
+		}
+		if err != nil {
+			if err == io.EOF && len(ret) > 0 {
+				return ret, nil
+			}
+			return ret, err
+		}
+	}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/terminal_test.go b/vendor/golang.org/x/crypto/ssh/terminal/terminal_test.go
new file mode 100644
index 00000000..901c72ab
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/terminal_test.go
@@ -0,0 +1,350 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package terminal
+
+import (
+	"bytes"
+	"io"
+	"os"
+	"testing"
+)
+
+type MockTerminal struct {
+	toSend       []byte
+	bytesPerRead int
+	received     []byte
+}
+
+func (c *MockTerminal) Read(data []byte) (n int, err error) {
+	n = len(data)
+	if n == 0 {
+		return
+	}
+	if n > len(c.toSend) {
+		n = len(c.toSend)
+	}
+	if n == 0 {
+		return 0, io.EOF
+	}
+	if c.bytesPerRead > 0 && n > c.bytesPerRead {
+		n = c.bytesPerRead
+	}
+	copy(data, c.toSend[:n])
+	c.toSend = c.toSend[n:]
+	return
+}
+
+func (c *MockTerminal) Write(data []byte) (n int, err error) {
+	c.received = append(c.received, data...)
+	return len(data), nil
+}
+
+func TestClose(t *testing.T) {
+	c := &MockTerminal{}
+	ss := NewTerminal(c, "> ")
+	line, err := ss.ReadLine()
+	if line != "" {
+		t.Errorf("Expected empty line but got: %s", line)
+	}
+	if err != io.EOF {
+		t.Errorf("Error should have been EOF but got: %s", err)
+	}
+}
+
+var keyPressTests = []struct {
+	in             string
+	line           string
+	err            error
+	throwAwayLines int
+}{
+	{
+		err: io.EOF,
+	},
+	{
+		in:   "\r",
+		line: "",
+	},
+	{
+		in:   "foo\r",
+		line: "foo",
+	},
+	{
+		in:   "a\x1b[Cb\r", // right
+		line: "ab",
+	},
+	{
+		in:   "a\x1b[Db\r", // left
+		line: "ba",
+	},
+	{
+		in:   "a\177b\r", // backspace
+		line: "b",
+	},
+	{
+		in: "\x1b[A\r", // up
+	},
+	{
+		in: "\x1b[B\r", // down
+	},
+	{
+		in:   "line\x1b[A\x1b[B\r", // up then down
+		line: "line",
+	},
+	{
+		in:             "line1\rline2\x1b[A\r", // recall previous line.
+		line:           "line1",
+		throwAwayLines: 1,
+	},
+	{
+		// recall two previous lines and append.
+		in:             "line1\rline2\rline3\x1b[A\x1b[Axxx\r",
+		line:           "line1xxx",
+		throwAwayLines: 2,
+	},
+	{
+		// Ctrl-A to move to beginning of line followed by ^K to kill
+		// line.
+		in:   "a b \001\013\r",
+		line: "",
+	},
+	{
+		// Ctrl-A to move to beginning of line, Ctrl-E to move to end,
+		// finally ^K to kill nothing.
+		in:   "a b \001\005\013\r",
+		line: "a b ",
+	},
+	{
+		in:   "\027\r",
+		line: "",
+	},
+	{
+		in:   "a\027\r",
+		line: "",
+	},
+	{
+		in:   "a \027\r",
+		line: "",
+	},
+	{
+		in:   "a b\027\r",
+		line: "a ",
+	},
+	{
+		in:   "a b \027\r",
+		line: "a ",
+	},
+	{
+		in:   "one two thr\x1b[D\027\r",
+		line: "one two r",
+	},
+	{
+		in:   "\013\r",
+		line: "",
+	},
+	{
+		in:   "a\013\r",
+		line: "a",
+	},
+	{
+		in:   "ab\x1b[D\013\r",
+		line: "a",
+	},
+	{
+		in:   "Ξεσκεπάζω\r",
+		line: "Ξεσκεπάζω",
+	},
+	{
+		in:             "£\r\x1b[A\177\r", // non-ASCII char, enter, up, backspace.
+		line:           "",
+		throwAwayLines: 1,
+	},
+	{
+		in:             "£\r££\x1b[A\x1b[B\177\r", // non-ASCII char, enter, 2x non-ASCII, up, down, backspace, enter.
+		line:           "£",
+		throwAwayLines: 1,
+	},
+	{
+		// Ctrl-D at the end of the line should be ignored.
+		in:   "a\004\r",
+		line: "a",
+	},
+	{
+		// a, b, left, Ctrl-D should erase the b.
+		in:   "ab\x1b[D\004\r",
+		line: "a",
+	},
+	{
+		// a, b, c, d, left, left, ^U should erase to the beginning of
+		// the line.
+		in:   "abcd\x1b[D\x1b[D\025\r",
+		line: "cd",
+	},
+	{
+		// Bracketed paste mode: control sequences should be returned
+		// verbatim in paste mode.
+		in:   "abc\x1b[200~de\177f\x1b[201~\177\r",
+		line: "abcde\177",
+	},
+	{
+		// Enter in bracketed paste mode should still work.
+		in:             "abc\x1b[200~d\refg\x1b[201~h\r",
+		line:           "efgh",
+		throwAwayLines: 1,
+	},
+	{
+		// Lines consisting entirely of pasted data should be indicated as such.
+		in:   "\x1b[200~a\r",
+		line: "a",
+		err:  ErrPasteIndicator,
+	},
+}
+
+func TestKeyPresses(t *testing.T) {
+	for i, test := range keyPressTests {
+		for j := 1; j < len(test.in); j++ {
+			c := &MockTerminal{
+				toSend:       []byte(test.in),
+				bytesPerRead: j,
+			}
+			ss := NewTerminal(c, "> ")
+			for k := 0; k < test.throwAwayLines; k++ {
+				_, err := ss.ReadLine()
+				if err != nil {
+					t.Errorf("Throwaway line %d from test %d resulted in error: %s", k, i, err)
+				}
+			}
+			line, err := ss.ReadLine()
+			if line != test.line {
+				t.Errorf("Line resulting from test %d (%d bytes per read) was '%s', expected '%s'", i, j, line, test.line)
+				break
+			}
+			if err != test.err {
+				t.Errorf("Error resulting from test %d (%d bytes per read) was '%v', expected '%v'", i, j, err, test.err)
+				break
+			}
+		}
+	}
+}
+
+func TestPasswordNotSaved(t *testing.T) {
+	c := &MockTerminal{
+		toSend:       []byte("password\r\x1b[A\r"),
+		bytesPerRead: 1,
+	}
+	ss := NewTerminal(c, "> ")
+	pw, _ := ss.ReadPassword("> ")
+	if pw != "password" {
+		t.Fatalf("failed to read password, got %s", pw)
+	}
+	line, _ := ss.ReadLine()
+	if len(line) > 0 {
+		t.Fatalf("password was saved in history")
+	}
+}
+
+var setSizeTests = []struct {
+	width, height int
+}{
+	{40, 13},
+	{80, 24},
+	{132, 43},
+}
+
+func TestTerminalSetSize(t *testing.T) {
+	for _, setSize := range setSizeTests {
+		c := &MockTerminal{
+			toSend:       []byte("password\r\x1b[A\r"),
+			bytesPerRead: 1,
+		}
+		ss := NewTerminal(c, "> ")
+		ss.SetSize(setSize.width, setSize.height)
+		pw, _ := ss.ReadPassword("Password: ")
+		if pw != "password" {
+			t.Fatalf("failed to read password, got %s", pw)
+		}
+		if string(c.received) != "Password: \r\n" {
+			t.Errorf("failed to set the temporary prompt expected %q, got %q", "Password: ", c.received)
+		}
+	}
+}
+
+func TestReadPasswordLineEnd(t *testing.T) {
+	var tests = []struct {
+		input string
+		want  string
+	}{
+		{"\n", ""},
+		{"\r\n", ""},
+		{"test\r\n", "test"},
+		{"testtesttesttes\n", "testtesttesttes"},
+		{"testtesttesttes\r\n", "testtesttesttes"},
+		{"testtesttesttesttest\n", "testtesttesttesttest"},
+		{"testtesttesttesttest\r\n", "testtesttesttesttest"},
+	}
+	for _, test := range tests {
+		buf := new(bytes.Buffer)
+		if _, err := buf.WriteString(test.input); err != nil {
+			t.Fatal(err)
+		}
+
+		have, err := readPasswordLine(buf)
+		if err != nil {
+			t.Errorf("readPasswordLine(%q) failed: %v", test.input, err)
+			continue
+		}
+		if string(have) != test.want {
+			t.Errorf("readPasswordLine(%q) returns %q, but %q is expected", test.input, string(have), test.want)
+			continue
+		}
+
+		if _, err = buf.WriteString(test.input); err != nil {
+			t.Fatal(err)
+		}
+		have, err = readPasswordLine(buf)
+		if err != nil {
+			t.Errorf("readPasswordLine(%q) failed: %v", test.input, err)
+			continue
+		}
+		if string(have) != test.want {
+			t.Errorf("readPasswordLine(%q) returns %q, but %q is expected", test.input, string(have), test.want)
+			continue
+		}
+	}
+}
+
+func TestMakeRawState(t *testing.T) {
+	fd := int(os.Stdout.Fd())
+	if !IsTerminal(fd) {
+		t.Skip("stdout is not a terminal; skipping test")
+	}
+
+	st, err := GetState(fd)
+	if err != nil {
+		t.Fatalf("failed to get terminal state from GetState: %s", err)
+	}
+	defer Restore(fd, st)
+	raw, err := MakeRaw(fd)
+	if err != nil {
+		t.Fatalf("failed to get terminal state from MakeRaw: %s", err)
+	}
+
+	if *st != *raw {
+		t.Errorf("states do not match; was %v, expected %v", raw, st)
+	}
+}
+
+func TestOutputNewlines(t *testing.T) {
+	// \n should be changed to \r\n in terminal output.
+	buf := new(bytes.Buffer)
+	term := NewTerminal(buf, ">")
+
+	term.Write([]byte("1\n2\n"))
+	output := string(buf.Bytes())
+	const expected = "1\r\n2\r\n"
+
+	if output != expected {
+		t.Errorf("incorrect output: was %q, expected %q", output, expected)
+	}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util.go b/vendor/golang.org/x/crypto/ssh/terminal/util.go
new file mode 100644
index 00000000..d0191961
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util.go
@@ -0,0 +1,119 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build darwin dragonfly freebsd linux,!appengine netbsd openbsd
+
+// Package terminal provides support functions for dealing with terminals, as
+// commonly found on UNIX systems.
+//
+// Putting a terminal into raw mode is the most common requirement:
+//
+// 	oldState, err := terminal.MakeRaw(0)
+// 	if err != nil {
+// 	        panic(err)
+// 	}
+// 	defer terminal.Restore(0, oldState)
+package terminal // import "golang.org/x/crypto/ssh/terminal"
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+// State contains the state of a terminal.
+type State struct {
+	termios syscall.Termios
+}
+
+// IsTerminal returns true if the given file descriptor is a terminal.
+func IsTerminal(fd int) bool {
+	var termios syscall.Termios
+	_, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlReadTermios, uintptr(unsafe.Pointer(&termios)), 0, 0, 0)
+	return err == 0
+}
+
+// MakeRaw put the terminal connected to the given file descriptor into raw
+// mode and returns the previous state of the terminal so that it can be
+// restored.
+func MakeRaw(fd int) (*State, error) {
+	var oldState State
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlReadTermios, uintptr(unsafe.Pointer(&oldState.termios)), 0, 0, 0); err != 0 {
+		return nil, err
+	}
+
+	newState := oldState.termios
+	// This attempts to replicate the behaviour documented for cfmakeraw in
+	// the termios(3) manpage.
+	newState.Iflag &^= syscall.IGNBRK | syscall.BRKINT | syscall.PARMRK | syscall.ISTRIP | syscall.INLCR | syscall.IGNCR | syscall.ICRNL | syscall.IXON
+	newState.Oflag &^= syscall.OPOST
+	newState.Lflag &^= syscall.ECHO | syscall.ECHONL | syscall.ICANON | syscall.ISIG | syscall.IEXTEN
+	newState.Cflag &^= syscall.CSIZE | syscall.PARENB
+	newState.Cflag |= syscall.CS8
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlWriteTermios, uintptr(unsafe.Pointer(&newState)), 0, 0, 0); err != 0 {
+		return nil, err
+	}
+
+	return &oldState, nil
+}
+
+// GetState returns the current state of a terminal which may be useful to
+// restore the terminal after a signal.
+func GetState(fd int) (*State, error) {
+	var oldState State
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlReadTermios, uintptr(unsafe.Pointer(&oldState.termios)), 0, 0, 0); err != 0 {
+		return nil, err
+	}
+
+	return &oldState, nil
+}
+
+// Restore restores the terminal connected to the given file descriptor to a
+// previous state.
+func Restore(fd int, state *State) error {
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlWriteTermios, uintptr(unsafe.Pointer(&state.termios)), 0, 0, 0); err != 0 {
+		return err
+	}
+	return nil
+}
+
+// GetSize returns the dimensions of the given terminal.
+func GetSize(fd int) (width, height int, err error) {
+	var dimensions [4]uint16
+
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), uintptr(syscall.TIOCGWINSZ), uintptr(unsafe.Pointer(&dimensions)), 0, 0, 0); err != 0 {
+		return -1, -1, err
+	}
+	return int(dimensions[1]), int(dimensions[0]), nil
+}
+
+// passwordReader is an io.Reader that reads from a specific file descriptor.
+type passwordReader int
+
+func (r passwordReader) Read(buf []byte) (int, error) {
+	return syscall.Read(int(r), buf)
+}
+
+// ReadPassword reads a line of input from a terminal without local echo.  This
+// is commonly used for inputting passwords and other sensitive data. The slice
+// returned does not include the \n.
+func ReadPassword(fd int) ([]byte, error) {
+	var oldState syscall.Termios
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlReadTermios, uintptr(unsafe.Pointer(&oldState)), 0, 0, 0); err != 0 {
+		return nil, err
+	}
+
+	newState := oldState
+	newState.Lflag &^= syscall.ECHO
+	newState.Lflag |= syscall.ICANON | syscall.ISIG
+	newState.Iflag |= syscall.ICRNL
+	if _, _, err := syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlWriteTermios, uintptr(unsafe.Pointer(&newState)), 0, 0, 0); err != 0 {
+		return nil, err
+	}
+
+	defer func() {
+		syscall.Syscall6(syscall.SYS_IOCTL, uintptr(fd), ioctlWriteTermios, uintptr(unsafe.Pointer(&oldState)), 0, 0, 0)
+	}()
+
+	return readPasswordLine(passwordReader(fd))
+}
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util_bsd.go b/vendor/golang.org/x/crypto/ssh/terminal/util_bsd.go
new file mode 100644
index 00000000..9c1ffd14
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util_bsd.go
@@ -0,0 +1,12 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build darwin dragonfly freebsd netbsd openbsd
+
+package terminal
+
+import "syscall"
+
+const ioctlReadTermios = syscall.TIOCGETA
+const ioctlWriteTermios = syscall.TIOCSETA
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util_linux.go b/vendor/golang.org/x/crypto/ssh/terminal/util_linux.go
new file mode 100644
index 00000000..5883b22d
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util_linux.go
@@ -0,0 +1,11 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package terminal
+
+// These constants are declared here, rather than importing
+// them from the syscall package as some syscall packages, even
+// on linux, for example gccgo, do not declare them.
+const ioctlReadTermios = 0x5401  // syscall.TCGETS
+const ioctlWriteTermios = 0x5402 // syscall.TCSETS
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go b/vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
new file mode 100644
index 00000000..799f049f
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
@@ -0,0 +1,58 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package terminal provides support functions for dealing with terminals, as
+// commonly found on UNIX systems.
+//
+// Putting a terminal into raw mode is the most common requirement:
+//
+// 	oldState, err := terminal.MakeRaw(0)
+// 	if err != nil {
+// 	        panic(err)
+// 	}
+// 	defer terminal.Restore(0, oldState)
+package terminal
+
+import (
+	"fmt"
+	"runtime"
+)
+
+type State struct{}
+
+// IsTerminal returns true if the given file descriptor is a terminal.
+func IsTerminal(fd int) bool {
+	return false
+}
+
+// MakeRaw put the terminal connected to the given file descriptor into raw
+// mode and returns the previous state of the terminal so that it can be
+// restored.
+func MakeRaw(fd int) (*State, error) {
+	return nil, fmt.Errorf("terminal: MakeRaw not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
+}
+
+// GetState returns the current state of a terminal which may be useful to
+// restore the terminal after a signal.
+func GetState(fd int) (*State, error) {
+	return nil, fmt.Errorf("terminal: GetState not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
+}
+
+// Restore restores the terminal connected to the given file descriptor to a
+// previous state.
+func Restore(fd int, state *State) error {
+	return fmt.Errorf("terminal: Restore not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
+}
+
+// GetSize returns the dimensions of the given terminal.
+func GetSize(fd int) (width, height int, err error) {
+	return 0, 0, fmt.Errorf("terminal: GetSize not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
+}
+
+// ReadPassword reads a line of input from a terminal without local echo.  This
+// is commonly used for inputting passwords and other sensitive data. The slice
+// returned does not include the \n.
+func ReadPassword(fd int) ([]byte, error) {
+	return nil, fmt.Errorf("terminal: ReadPassword not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
+}
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go b/vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
new file mode 100644
index 00000000..a2e1b57d
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
@@ -0,0 +1,128 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build solaris
+
+package terminal // import "golang.org/x/crypto/ssh/terminal"
+
+import (
+	"golang.org/x/sys/unix"
+	"io"
+	"syscall"
+)
+
+// State contains the state of a terminal.
+type State struct {
+	state *unix.Termios
+}
+
+// IsTerminal returns true if the given file descriptor is a terminal.
+func IsTerminal(fd int) bool {
+	_, err := unix.IoctlGetTermio(fd, unix.TCGETA)
+	return err == nil
+}
+
+// ReadPassword reads a line of input from a terminal without local echo.  This
+// is commonly used for inputting passwords and other sensitive data. The slice
+// returned does not include the \n.
+func ReadPassword(fd int) ([]byte, error) {
+	// see also: http://src.illumos.org/source/xref/illumos-gate/usr/src/lib/libast/common/uwin/getpass.c
+	val, err := unix.IoctlGetTermios(fd, unix.TCGETS)
+	if err != nil {
+		return nil, err
+	}
+	oldState := *val
+
+	newState := oldState
+	newState.Lflag &^= syscall.ECHO
+	newState.Lflag |= syscall.ICANON | syscall.ISIG
+	newState.Iflag |= syscall.ICRNL
+	err = unix.IoctlSetTermios(fd, unix.TCSETS, &newState)
+	if err != nil {
+		return nil, err
+	}
+
+	defer unix.IoctlSetTermios(fd, unix.TCSETS, &oldState)
+
+	var buf [16]byte
+	var ret []byte
+	for {
+		n, err := syscall.Read(fd, buf[:])
+		if err != nil {
+			return nil, err
+		}
+		if n == 0 {
+			if len(ret) == 0 {
+				return nil, io.EOF
+			}
+			break
+		}
+		if buf[n-1] == '\n' {
+			n--
+		}
+		ret = append(ret, buf[:n]...)
+		if n < len(buf) {
+			break
+		}
+	}
+
+	return ret, nil
+}
+
+// MakeRaw puts the terminal connected to the given file descriptor into raw
+// mode and returns the previous state of the terminal so that it can be
+// restored.
+// see http://cr.illumos.org/~webrev/andy_js/1060/
+func MakeRaw(fd int) (*State, error) {
+	oldTermiosPtr, err := unix.IoctlGetTermios(fd, unix.TCGETS)
+	if err != nil {
+		return nil, err
+	}
+	oldTermios := *oldTermiosPtr
+
+	newTermios := oldTermios
+	newTermios.Iflag &^= syscall.IGNBRK | syscall.BRKINT | syscall.PARMRK | syscall.ISTRIP | syscall.INLCR | syscall.IGNCR | syscall.ICRNL | syscall.IXON
+	newTermios.Oflag &^= syscall.OPOST
+	newTermios.Lflag &^= syscall.ECHO | syscall.ECHONL | syscall.ICANON | syscall.ISIG | syscall.IEXTEN
+	newTermios.Cflag &^= syscall.CSIZE | syscall.PARENB
+	newTermios.Cflag |= syscall.CS8
+	newTermios.Cc[unix.VMIN] = 1
+	newTermios.Cc[unix.VTIME] = 0
+
+	if err := unix.IoctlSetTermios(fd, unix.TCSETS, &newTermios); err != nil {
+		return nil, err
+	}
+
+	return &State{
+		state: oldTermiosPtr,
+	}, nil
+}
+
+// Restore restores the terminal connected to the given file descriptor to a
+// previous state.
+func Restore(fd int, oldState *State) error {
+	return unix.IoctlSetTermios(fd, unix.TCSETS, oldState.state)
+}
+
+// GetState returns the current state of a terminal which may be useful to
+// restore the terminal after a signal.
+func GetState(fd int) (*State, error) {
+	oldTermiosPtr, err := unix.IoctlGetTermios(fd, unix.TCGETS)
+	if err != nil {
+		return nil, err
+	}
+
+	return &State{
+		state: oldTermiosPtr,
+	}, nil
+}
+
+// GetSize returns the dimensions of the given terminal.
+func GetSize(fd int) (width, height int, err error) {
+	ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)
+	if err != nil {
+		return 0, 0, err
+	}
+	return int(ws.Col), int(ws.Row), nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/terminal/util_windows.go b/vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
new file mode 100644
index 00000000..e0a1f36c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
@@ -0,0 +1,155 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build windows
+
+// Package terminal provides support functions for dealing with terminals, as
+// commonly found on UNIX systems.
+//
+// Putting a terminal into raw mode is the most common requirement:
+//
+// 	oldState, err := terminal.MakeRaw(0)
+// 	if err != nil {
+// 	        panic(err)
+// 	}
+// 	defer terminal.Restore(0, oldState)
+package terminal
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+const (
+	enableLineInput       = 2
+	enableEchoInput       = 4
+	enableProcessedInput  = 1
+	enableWindowInput     = 8
+	enableMouseInput      = 16
+	enableInsertMode      = 32
+	enableQuickEditMode   = 64
+	enableExtendedFlags   = 128
+	enableAutoPosition    = 256
+	enableProcessedOutput = 1
+	enableWrapAtEolOutput = 2
+)
+
+var kernel32 = syscall.NewLazyDLL("kernel32.dll")
+
+var (
+	procGetConsoleMode             = kernel32.NewProc("GetConsoleMode")
+	procSetConsoleMode             = kernel32.NewProc("SetConsoleMode")
+	procGetConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
+)
+
+type (
+	short int16
+	word  uint16
+
+	coord struct {
+		x short
+		y short
+	}
+	smallRect struct {
+		left   short
+		top    short
+		right  short
+		bottom short
+	}
+	consoleScreenBufferInfo struct {
+		size              coord
+		cursorPosition    coord
+		attributes        word
+		window            smallRect
+		maximumWindowSize coord
+	}
+)
+
+type State struct {
+	mode uint32
+}
+
+// IsTerminal returns true if the given file descriptor is a terminal.
+func IsTerminal(fd int) bool {
+	var st uint32
+	r, _, e := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(fd), uintptr(unsafe.Pointer(&st)), 0)
+	return r != 0 && e == 0
+}
+
+// MakeRaw put the terminal connected to the given file descriptor into raw
+// mode and returns the previous state of the terminal so that it can be
+// restored.
+func MakeRaw(fd int) (*State, error) {
+	var st uint32
+	_, _, e := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(fd), uintptr(unsafe.Pointer(&st)), 0)
+	if e != 0 {
+		return nil, error(e)
+	}
+	raw := st &^ (enableEchoInput | enableProcessedInput | enableLineInput | enableProcessedOutput)
+	_, _, e = syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(fd), uintptr(raw), 0)
+	if e != 0 {
+		return nil, error(e)
+	}
+	return &State{st}, nil
+}
+
+// GetState returns the current state of a terminal which may be useful to
+// restore the terminal after a signal.
+func GetState(fd int) (*State, error) {
+	var st uint32
+	_, _, e := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(fd), uintptr(unsafe.Pointer(&st)), 0)
+	if e != 0 {
+		return nil, error(e)
+	}
+	return &State{st}, nil
+}
+
+// Restore restores the terminal connected to the given file descriptor to a
+// previous state.
+func Restore(fd int, state *State) error {
+	_, _, err := syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(fd), uintptr(state.mode), 0)
+	return err
+}
+
+// GetSize returns the dimensions of the given terminal.
+func GetSize(fd int) (width, height int, err error) {
+	var info consoleScreenBufferInfo
+	_, _, e := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(fd), uintptr(unsafe.Pointer(&info)), 0)
+	if e != 0 {
+		return 0, 0, error(e)
+	}
+	return int(info.size.x), int(info.size.y), nil
+}
+
+// passwordReader is an io.Reader that reads from a specific Windows HANDLE.
+type passwordReader int
+
+func (r passwordReader) Read(buf []byte) (int, error) {
+	return syscall.Read(syscall.Handle(r), buf)
+}
+
+// ReadPassword reads a line of input from a terminal without local echo.  This
+// is commonly used for inputting passwords and other sensitive data. The slice
+// returned does not include the \n.
+func ReadPassword(fd int) ([]byte, error) {
+	var st uint32
+	_, _, e := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(fd), uintptr(unsafe.Pointer(&st)), 0)
+	if e != 0 {
+		return nil, error(e)
+	}
+	old := st
+
+	st &^= (enableEchoInput)
+	st |= (enableProcessedInput | enableLineInput | enableProcessedOutput)
+	_, _, e = syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(fd), uintptr(st), 0)
+	if e != 0 {
+		return nil, error(e)
+	}
+
+	defer func() {
+		syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(fd), uintptr(old), 0)
+	}()
+
+	return readPasswordLine(passwordReader(fd))
+}
